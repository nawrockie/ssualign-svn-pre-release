#!/usr/bin/perl
#
# ssu-align.pl
# Eric Nawrocki
# EPN, Wed Oct 29 10:12:05 2008
#
# Usage: perl ssu-align.pl
#             <SSU rRNA CM file with >= 1 CMs>
#             <target database sequence file name>
#             <output root for output files>
#             <parameter file minimally defining:
#                $cmsearch = path to 'cmsearch' infernal app
#                $cmalign  = path to 'cmalign' infernal app
#                $esl_sfetch   = path to 'esl-sfetch' easel miniapp
#              and optionally defining (if -n or -p enabled): 
#                $cluster_prefix = prefix for perl ssu-align.pl commands
#                $cluster_suffix = suffix for perl ssu-align.pl commands
#             
# Synopsis:
# Aligns SSU sequences to SSU CMs.
# Given a CM file with >=1 SSU CMs and a target sequence file with putative
# SSU sequences: 
# Step 1. define likely start/ends (seq boundaries) to align using cmsearch 
#         in viterbi HMM mode (or forward HMM mode if -F).
# Step 2. extract those subsequences into a new target fasta file.
# Step 3. sequences in new fasta file from step 2 are aligned to the CM.
#
# If more than x>1 CMs exist in the CM file, then x new subsequence files 
# are created in Step 2, one for each CM and containing the sequences that
# score highest to that CM. Then in Step 3, each CM is used to align it's 
# target file. For example the CM file may contain archael, bacterial, and 
# eukaryotic CMs, and step 1 will 'classify' each seq as arc, bac, or euk, 
# and then in Step 3 the appropriate CM is used to align each sequence. 
#
# Options from :
#    -F     : allow file clobbering
#    -s     : only search target sequence file for hits, skip alignment step
#    -a     : only align  target sequence file, skip initial search step 
#    -u     : do not truncate seqs to HMM predicted start/end, align full seqs\n\t";
#    -w     : use the HMM forward algorithm for searching, not HMM viterbi
#    -b <x> : minimum cmsearch hit bit score to allow for a surviving subsequence (default: 100)
#    -l <n> : minimum cmsearch hit length    to allow for a surviving subsequence (default: 1)
#    -n <n> : run in 'prep' mode, split target seq file into multiple files with <n> seqs each
#    -p <n> : run in 'prep' mode, split target seq file into <n> files with equal number of seqs
#    -r <x> : w/-n or -p, filter alns based on seq identity, allow no 2 seqs > <x> identical
#
use Getopt::Std;
use Cwd 'abs_path';
#use strict;

my $usage = 
    "Usage: ssu-align [-options] <cmfile> <sequence file> <output root> <params file>\n";
#    "<SSU rRNA CM file with >= 1 CM>\n\t" .
#    "<target database sequence file name>\n\t" . 
#    "<output root for output files>\n\t" . 
#    "<parameter file minimally defining:\n\t" . 
#    " \$cmsearch = path to 'cmsearch' infernal app\n\t" . 
#    " \$cmalign  = path to 'cmalign' infernal app\n\t" .
#    " \$esl_sfetch   = path to 'esl-sfetch' easel miniapp\n\t" . 
#    " and optionally defining (if -n or -p enabled):\n\t" . 
#    " \$cluster_prefix = prefix for ssu-align commands\n\t" .
#    " \$cluster_suffix = suffix for ssu-align commands>\n\n";
$options_usage  = "where general options are:\n";
$options_usage .= "  -h     : show brief help on version and usage\n";
$options_usage .= "  -F     : allow file clobbering\n";
$options_usage .= "  -s     : only search target sequence file for hits, skip alignment step\n";
$options_usage .= "  -a     : only align  target sequence file, skip initial search step\n"; 
$options_usage .= "  -u     : do not truncate seqs to HMM predicted start/end, align full seqs\n";
$options_usage .= "  -w     : use the HMM forward algorithm for searching, not HMM viterbi\n";
$options_usage .= "  -b <x> : minimum cmsearch hit bit score to allow for a surviving subsequence (default: 100)\n";
$options_usage .= "  -l <n> : minimum cmsearch hit length    to allow for a surviving subsequence (default: 1)\n";
$options_usage .= "  -n <n> : run in 'prep' mode, split target seq file into multiple files with <n> seqs each\n";
$options_usage .= "  -p <n> : run in 'prep' mode, split target seq file into <n> files with equal number of seqs\n";
$options_usage .= "  -r <x> : filter aln based on seq identity, allow no 2 seqs > <x> identical\n\n";

###################
# Process options #
###################
getopts('hFsauwb:l:n:p:r:');
my $do_clobber = 0;
my $do_viterbi = 1;
my $do_forward = 0;
my $min_bit = 100;
my $min_len = 1;
my $do_prep = 0;
my $do_prep_nseq_set = 0;
my $do_prep_nproc_set = 0;
my $prep_nseq = 0;
my $prep_nproc = 0;
my $do_truncate = 1;
my $do_align = 1;
my $do_search = 1;
my $do_filteraln = 0;
my $filter_id = 0.;

my $enabled_options = "";
if (defined $opt_h) { print $usage . "\n"; print $options_usage; exit(1); } 
if (defined $opt_F) { $do_clobber = 1; } 
if (defined $opt_s) { $do_align = 0; $enabled_options .= " -s";} 
if (defined $opt_u) { $do_truncate = 0; $enabled_options .= " -u"; }
if (defined $opt_a) { $do_search = 0; $enabled_options .= " -a";} 
if (defined $opt_w) { $do_forward = 1; $do_viterbi = 0; $enabled_options .= " -w";}
if (defined $opt_b) { $min_bit = $opt_b; $enabled_options .= " -b $opt_b"; } 
if (defined $opt_l) { $min_len = $opt_l; $enabled_options .= " -l $opt_l"; if($min_len <= 0) { printf STDERR ("ERROR, with -l <n>, <n> must be >= 1."); exit(1); } }
if (defined $opt_n) { $do_prep = 1; $do_prep_nseq_set = 1;  $prep_nseq  = $opt_n; }
if (defined $opt_p) { $do_prep = 1; $do_prep_nproc_set = 1; $prep_nproc = $opt_p; }
if (defined $opt_r) { $do_filteraln = 1; $filter_id = $opt_r; $enabled_options .= " -r $opt_r"; if (($r < 0.) || ($r > 1.)) { printf STDERR("ERROR, with -r <x>, valid range is 0. <= <x> <= 1.0.\n"); exit(1); } }

# Check for incompatible option combinations and non-sensical option parameters
if($do_prep_nseq_set  && $do_prep_nproc_set) { printf STDERR ("ERROR, -n and -p are exclusive options, pick one or the other.\n"); exit(1); }
if($do_prep_nseq_set  && $prep_nseq < 1)     { printf STDERR ("ERROR, with -n <n>, <n> must be at least 1.\n"); exit(1); }
if($do_prep_nproc_set && $prep_nproc <= 1)   { printf STDERR ("ERROR, with -p <n>, <n> must be at least 2.\n"); exit(1); }
if(scalar(@ARGV) != 4) {   
    print "Incorrect number of command line arguments.\n";
    print $usage;
    print "\nTo see more help on available options, do ssu-align -h\n\n";
    exit(1);
}
my ($cm_file, $target_file, $out_root, $params_file) = @ARGV;

#####################
# Preliminary stuff #
#####################
# not sure if I should make the vars in validate_input_files private with my()
my ($my_cmsearch, $my_cmalign, $my_esl_sfetch, $my_esl_weight);
validate_input_files(\$my_cmsearch, \$my_cmalign, \$my_esl_sfetch, \$my_esl_weight, $do_filteraln);

$nseq_target_file = determine_num_seqs($target_file);

my $out_dir      = $out_root;
my $out_dir_root = $out_dir . "/" . $out_root;
create_output_dir($do_clobber, $out_dir, $cm_file); 
my $my_cm_file_copy = $out_dir . "/" . $cm_file;

process_cm_file($do_prep, $my_cm_file_copy, $out_root, \@indi_cm_name_A, \@indi_cm_file_name_A, \@indi_cm_clen_A, \@indi_cm_nbif_A);
my $ncm = scalar(@indi_cm_file_name_A); 
if((!$do_search) && ($ncm > 1)) { printf("ERROR, the -a option only works if the CM file contains exactly 1 CM, $cm_file has $ncm CMs in it.\n"); exit(1); }

if($do_prep) { prepare_and_exit($do_align, $cm_file, $params_file, $do_prep_nproc_set, $do_prep_nseq_set, $prep_nproc, $prep_nseq, $target_file, $out_dir, $out_root, $cluster_prefix, $cluster_suffix, $nseq_target_file, scalar(@indi_cm_file_name_A), $esl_weight, $do_filteraln, $filter_id); } 

# if we get here, $do_prep is FALSE

############################################################################
# Step 1: Define sequence ends (and classify seqs if > 1 CM) with cmsearch #
############################################################################
my $tab_file;
my $max_file_name_width; 
if($do_search) { 
    search_sequences_with_each_cm($my_cmsearch, $my_cm_file_copy, $target_file, $out_dir_root, $nseq_target_file, $do_viterbi, \@indi_cm_file_name_A, \@indi_cm_clen_A, \@indi_cm_nbif_A, \$tab_file, \$max_file_name_width);
}
else { 
    $max_file_name_width = 30;
}
##############################
# Step 2: Extract subsequences
##############################
my %new_target_file_per_cm_name_H = ();
if($do_search) { 
    classify_and_extract_subseqs($do_truncate, $min_bit, $min_len, $tab_file, $target_file, $out_dir_root, $my_esl_sfetch, $max_file_name_width, \@indi_cm_name_A, \%new_target_file_per_cm_name_H); 
}
else { 
    $new_target_file_per_cm_name_H{$indi_cm_name_A[0]} = $target_file;
    #system("cp %s %s\n", $target_file ($out_dir_root . "." . $indi_cm_name_A[0] . ".sseq.fa")
}
###########################
# Step 3: Align sequences #
###########################
if($do_align) {
    align_subseqs($out_dir_root, $my_cmalign, $max_file_name_width, $my_esl_weight, $do_filteraln, $filter_id, \@indi_cm_name_A, \@indi_cm_file_name_A, \@indi_cm_clen_A, \%new_target_file_per_cm_name_H); 
}

# success, exit normally
exit(0); 

###############
# subroutines #
###############

#####################################################################
# subroutine: validate_input_files()
# incept:     EPN, Mon Nov  3 15:05:56 2008
# 
# purpose:    Validate that required files exist. Read the parameters
#             parameters file <$params_file> and verify that the
#             required variables defining locations of programs we
#             need to be able to run are defined, and that those
#             programs exist.
# 
# returns:    Nothing, if it returns, everything is valid.
# 
# exits:      If a required file does not exist, a required variable
#             is not set, or a required program does not exist. The
#             program prints a message to STDERR explaining why it's
#             exiting early and then exits with non-zero status.
#
####################################################################
sub validate_input_files { 
    my $narg_expected = 5;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, validate_input_files() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($cmsearch_ref, $cmalign_ref, $esl_sfetch_ref, $esl_weight_ref, $do_filteraln) = @_;

    #make sure ARGV files exist
    if(!(-e $cm_file))       { printf STDERR ("ERROR, CM file $cm_file does not exist.\n"); exit(1); }
    if(!(-e $target_file))   { printf STDERR ("ERROR, target sequence file $target_file does not exist.\n"); exit(1); }
    if(!(-e $params_file))   { printf STDERR ("ERROR, parmater file does not exist.\n"); exit(1); }
    if($cm_file !~ m/\.cm$/) { printf STDERR ("ERROR, CM file name must end with \".cm\", $cm_file does not.\n"); exit(1); }

    #Read parameter file
    $cmsearch = "";
    $cmalign = "";
    $esl_sfetch = "";
    $esl_weight = "";
    $cluster_prefix = "";
    $cluster_suffix = "";
    require $params_file;
    #get ssu-align.pl location
    $ssualign = abs_path($0);
    # check to make sure required variables were set and are valid
    if($cmsearch eq "")       { printf STDERR ("ERROR, \$cmsearch not defined in parameter file.\n"); exit(1); }
    if($cmalign  eq "")       { printf STDERR ("ERROR, \$cmalign not defined in parameter file.\n"); exit(1); }
    if($esl_sfetch   eq "")       { printf STDERR ("ERROR, \$esl_sfetch not defined in parameter file.\n"); exit(1); }
    if($do_filteraln) { 
	if($esl_weight   eq "")       { printf STDERR ("ERROR, -r enabled, but \$esl_weight not defined in parameter file.\n"); exit(1); }
    }
    # required variable paths can't have ~ prefix indicating home dir
    if($cmsearch =~ /^~/)     { printf STDERR ("ERROR, \$cmsearch definition must be absolute path, \~ cannot be used as shortcut for home directory.\n"); exit(1); }
    if($cmalign  =~ /^~/)     { printf STDERR ("ERROR, \$cmalign definition must be absolute path, \~ cannot be used as shortcut for home directory.\n"); exit(1); }
    if($esl_sfetch   =~ /^~/)     { printf STDERR ("ERROR, \$esl_sfetch definition must be absolute path, \~ cannot be used as shortcut for home directory.\n"); exit(1); }
    if($do_filteraln) { 
	if($esl_weight   =~ /^~/)     { printf STDERR ("ERROR, \$esl_weight definition must be absolute path, \~ cannot be used as shortcut for home directory.\n"); exit(1); }
    }
    # required variable paths can't have "../" prefix indicating up-one-dir
    if($cmsearch =~ /^\.\./)  { printf STDERR ("ERROR, \$cmsearch definition must be absolute path, \.\.\/ cannot be used as shortcut for up-one-directory.\n"); exit(1); }
    if($cmalign  =~ /^\.\./)  { printf STDERR ("ERROR, \$cmalign definition must be absolute path, \.\.\/ cannot be used as shortcut for up-one-directory.\n"); exit(1); }
    if($esl_sfetch   =~ /^\.\./)  { printf STDERR ("ERROR, \$esl_sfetch definition must be absolute path, \.\.\/ cannot be used as shortcut for up-one-directory.\n"); exit(1); }
    if($do_filteraln) { 
	if($esl_weight  =~ /^\.\./)  { printf STDERR ("ERROR, \$esl_weight definition must be absolute path, \.\.\/ cannot be used as shortcut for up-one-directory.\n"); exit(1); }
    }
    # required variable paths can't have "./" prefix indicating current dir
    if($cmsearch =~ /^\./)    { printf STDERR ("ERROR, \$cmsearch definition must be absolute path, \.\/ cannot be used as shortcut for current directory.\n"); exit(1); }
    if($cmalign  =~ /^\./)    { printf STDERR ("ERROR, \$cmalign definition must be absolute path, \.\/ cannot be used as shortcut for current directory.\n"); exit(1); }
    if($esl_sfetch   =~ /^\./)    { printf STDERR ("ERROR, \$esl_sfetch definition must be absolute path, \.\/ cannot be used as shortcut for current directory.\n"); exit(1); }
    if($do_filteraln) { 
	if($esl_sfetch   =~ /^\./)    { printf STDERR ("ERROR, \$esl_weight definition must be absolute path, \.\/ cannot be used as shortcut for current directory.\n"); exit(1); }
    }    
    # required variable paths must exist
    if(!(-e $cmsearch))       { printf STDERR ("ERROR, cmsearch executable $cmsearch does not exist.\n"); exit(1); }
    if(!(-e $cmalign))        { printf STDERR ("ERROR, cmalign executable $cmsearch does not exist.\n"); exit(1); }
    if(!(-e $esl_sfetch))         { printf STDERR ("ERROR, esl-sfetch executable $esl_sfetch does not exist.\n"); exit(1); }
    if($do_filteraln) { 
	if(!(-e $esl_weight))         { printf STDERR ("ERROR, esl-weight executable $esl_weight does not exist.\n"); exit(1); }
    }    
    $$cmsearch_ref = $cmsearch;
    $$cmalign_ref  = $cmalign;
    $$esl_sfetch_ref   = $esl_sfetch;
    $$esl_weight_ref   = $esl_weight;
    return;
}

#####################################################################
# subroutine: determine_num_seqs()
# incept:     EPN, Mon Nov  3 15:18:52 2008
# 
# purpose:    Count the number of sequences in the FASTA file 
#             <$target_file>.
# 
# returns:    <$nseq_target_file> number of sequences in 
#             <$target_file>.
# 
####################################################################
sub determine_num_seqs { 
    my $narg_expected = 1;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, determine_num_seqs() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($file) = $_[0];

    if(!(-e $file)) { printf STDERR ("ERROR, determine_num_seqs(), file $file does not exist.\n"); exit(1); }
    my $output = `grep \"\^\>\" $file | nl | tail -1`;
    chomp $output;
    $output =~ s/^\s+//;
    $output =~ s/\s+.*$//;
    my $nseq = $output;
    return $nseq;
}

#####################################################################
# subroutine: create_output_dir()
# incept:     EPN, Mon Nov  3 15:22:26 2008
# 
# purpose:    Create a new directory <$outdir> for the output files. 
#             If the directory already exists and <$do_clobber>, 
#             delete all of the files within it.
# 
# returns:    Nothing.
#
# exits:      If the directory already exists and <$do_clobber> is
#             FALSE. If a system call unexpectedly fails and returns 
#             a non-zero status code. 
# 
####################################################################
sub create_output_dir { 
    my $narg_expected = 3;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, create_output_dir() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($do_clobber, $out_dir, $cm_file) = @_;

    # create output directory
    if(-d $out_dir) { 
	if(!($do_clobber)) { 
	    printf STDERR ("ERROR, output directory $out_dir already exists. Delete it or use -F to overwrite it.\n"); exit(1); 
	}
	else { # dir exists, but -F enabled, so we remove it
	    if($out_dir eq "") { printf STDERR ("ERROR, trying to create directory named \"\"\n"); exit(1); }
	    system("rm -rf $out_dir/*");
	    if(($? >> 8) != 0) { printf STDERR ("ERROR, system\(\"rm -rf $out_dir/*\"\) unexpectedly returned non-zero exit status %d\n", ($? >> 8)); exit($? >> 8); } 
	    system("rmdir $out_dir");
	    if(($? >> 8) != 0) { printf STDERR ("ERROR, system\(\"rmdir $out_dir\"\) unexpectedly returned non-zero exit status %d\n", ($? >> 8)); exit($? >> 8); } 
	    if(-d $out_dir) { printf STDERR ("ERROR, output directory $out_dir still exists after a system\(\"rmdir $out_dir\"\) call.\n"); exit(1); }
	}
    }
    # if we get here, either $out_dir does not yet exist, or it does but -F was set on command line
    system("mkdir $out_dir");
    if(($? >> 8) != 0) { printf STDERR ("ERROR, system\(\"mkdir $out_dir\"\) unexpectedly returned non-zero exit status %d\n", ($? >> 8)); exit($? >> 8); } 
    system("cp $cm_file $out_dir\/");
    if(($? >> 8) != 0) { printf STDERR ("ERROR, unable to copy $cm_file to $out_dir.\n"); }
    return;
}

#####################################################################
# subroutine: prepare_and_exit()
# incept:     EPN, Mon Nov  3 15:25:23 2008
# 
# purpose:    Carry out a special mode of ssu-align.pl for creating
#             scripts to split up large alignment jobs into many
#             smaller jobs. This subroutine is called only if -n or 
#             -p is enabled on the command line. 
# 
#             The target sequence file <$target_file> is partitioned
#             into > 1 new, smaller FASTA files. A shell script 
#             named <$out_dir_root.sh> is created that calls 'perl 
#             ssu-align.pl' once each for each of the new FASTA 
#             files. A separate perl script named 
#             <$out_dir_root.merge.pl> is created that is to be run
#             after the alignments in <$out_dir_root.sh> are complete.
#             This script merges all the small alignments into
#             one big alignment.
# 
# returns:    Nothing.
#
# exits:      Upon successful completion with a zero status code 
#             (normal). Exits early upon failure with informative
#             message and non-zero status code. 
# 
####################################################################
sub prepare_and_exit { 
    my $narg_expected = 17;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, prepare_and_exit() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($do_align, $cm_file, $params_file, $do_prep_nproc_set, $do_prep_nseq_set, $prep_nproc, $prep_nseq, $target_file, $out_dir, $out_root, $cluster_prefix, $cluster_suffix, $nseq_target_file, $ncm, $esl_weight, $do_filteraln, $filter_id ) = @_;

    # Steps
    # 1. partition the target seq file
    # 2. print ssu-align.pl calls for each target seq file to screen
    # 3. print cmalign --merge calls to eventually merge resulting 
    #    alignments from ssu-align.pl calls in 2 together.
    # 4. exit

    my ($shell_script, $remainder, $n, $target_subfile_root, $target_subfile, $sub_output, $nseq_this_file, $line);

    # cp the parameters file to the new dir
    system("cp $params_file $out_dir\/");
    if(($? >> 8) != 0) { printf STDERR ("ERROR, system\(\"cp \$params_file \$out_dir\/\"\) unexpectedly returned non-zero exit status %d\n", ($? >> 8)); exit(($? >> 8)); } 
    
    $shell_script = $out_dir_root . ".sh";
    if(open(SH, ">" . $shell_script) == 0) { printf STDERR ("ERROR, could not open $shell_script for writing.\n"); exit(1); }
    #determine number of seqs per file (if $do_prep_nseq_set, we already know) 
    if($do_prep_nproc_set) { 
	$prep_nseq  = int($nseq_target_file / ($prep_nproc)); 
	$remainder  = $nseq_target_file - ($prep_nseq * $prep_nproc);
	if($remainder > 0) { $prep_nseq++; }
    }
    else { #do_prep_nseq_set
	$prep_nproc = int($nseq_target_file / ($prep_nseq)); 
	$remainder  = $nseq_target_file - ($prep_nseq * $prep_nproc);
	if($remainder > 0) { $prep_nproc++; }
    }
    if(($do_prep_nproc_set) && ($prep_nproc > $nseq_target_file)) { 
	printf STDERR ("ERROR, -p %d enabled, but there's only %d sequences in the target file.\n", $prep_nproc, $nseq_target_file); exit(1); 
    }
    if(($do_prep_nseq_set) && ($prep_nproc == 1)) {
	printf STDERR ("ERROR, -n %d enabled, but there's only %d sequences in the target file.\nNo need to use -n, you're requesting the target file be split into only 1 partition.\n", $prep_nseq, $nseq_target_file); exit(1); 
    }

    # 1. partition the target seq file AND
    # 2. print ssu-align.pl calls for each target seq file to screen
    $n = 1;
    $target_subfile_root = $target_file . "." . $n;
    $target_subfile      = $out_dir . "/" . $target_subfile_root;
    $sub_output          = $out_root . "." . $n  . ".ssu-align";
    if(open(SUB, ">" . $target_subfile) == 0) { printf STDERR ("ERROR, could not open $target_subfile for writing.\n"); exit(1); }
    $nseq_this_file = -1;
    if(open(FULL, $target_file) == 0) { printf STDERR ("ERROR, could not open $target_file for reading.\n"); exit(1); }
    while($line = <FULL>) { 
	if($line =~ m/^>/) { 
	    if(++$nseq_this_file == $prep_nseq) { 
		close(SUB); 
		printf SH ("%s%s%s\n", $cluster_prefix, "perl $ssualign $enabled_options $cm_file $target_subfile_root $out_root." . $n . " $params_file > $sub_output", $cluster_suffix);
		$target_subfile_root = $target_file . "." . (++$n);
		$target_subfile      = $out_dir . "/" . $target_subfile_root;
		$sub_output          = $out_root . "." . $n  . ".ssu-align";
		if(open(SUB, ">" . $target_subfile) == 0) { printf STDERR ("ERROR, could not open $target_subfile for writing.\n"); exit(1); }
		$nseq_this_file = 0;
	    }
	}
	print SUB ($line);
    }
    close(FULL);
    close(SUB);
    printf SH ("%s%s%s\n", $cluster_prefix, "perl $ssualign $enabled_options $cm_file $target_subfile_root $out_root." . $n . " $params_file > $sub_output", $cluster_suffix);
    close(SH);
    if($n != $prep_nproc) { printf STDERR ("ERROR, problem partitioning target FASTA file $target_file into $prep_nproc files, only $n files were successfully created.\n"); exit(1); }

    my @to_mergeA = ();
    my @new_to_mergeA = ();
    my($merge_script, $i, $nmerge, $iter, $nstop, $lower, $upper, $merged_root, $merged_name, $fil_merged_name, $merged_lower_name, $merged_upper_name, $namelen);

    # 3. print cmalign --merge calls to eventually merge resulting 
    #    alignments from ssu-align.pl calls in 2 together.
    if($do_align) { 
	$merge_script = $out_dir_root . ".merge.pl";
	if(open(MG, ">" . $merge_script) == 0) { printf STDERR ("ERROR, could not open $merge_script for writing.\n"); exit(1); }

	for($m = 1; $m <= $ncm; $m++) { 
	    printf MG ("\# Merging alignments to CM %d of %d\n", $m, $ncm);
	    for($i = 1; $i <= $prep_nproc; $i++) { push(@to_mergeA, $i); }
	    $nmerge = scalar(@to_mergeA);
	    $iter = 0;
	    while($nmerge > 1) { 
		$iter++;
		@new_to_mergeA = ();
		if (($nmerge % 2) == 0) { $nstop = $nmerge; } else { $nstop = $nmerge-1; }
		for($i = 0; $i < $nstop; $i+=2) { 
		    $lower = $to_mergeA[$i];
		    $upper = $to_mergeA[($i+1)];
		    $lower =~ s/\-.+//;
		    $upper =~ s/.+\-//;
		    $merged_root = $lower . "-" . $upper;
		    if($do_filteraln) { 
			$merged_name     = $out_root . "." . $merged_root . ".m" . $m . ".merged.cmalign.nf.stk";
			$fil_merged_name = $out_root . "." . $merged_root . ".m" . $m . ".merged.cmalign.stk";
		    }
		    else { 
			$merged_name = $out_root . "." . $merged_root . ".m" . $m . ".merged.cmalign.stk";
		    }
		    if($iter > 1) { 
			$merged_lower_name = $out_root . "." . $to_mergeA[$i]     . ".m" . $m . ".merged.cmalign.stk";
			$merged_upper_name = $out_root . "." . $to_mergeA[($i+1)] . ".m" . $m . ".merged.cmalign.stk";
		    }
		    else { #iter == 1
			$merged_lower_name = $out_root . "." . $to_mergeA[$i]     . "/" . $out_root . "." . $to_mergeA[$i]     . ".m" . $m . ".cmalign.stk";
			$merged_upper_name = $out_root . "." . $to_mergeA[($i+1)] . "/" . $out_root . "." . $to_mergeA[($i+1)] . ".m" . $m . ".cmalign.stk";
		    }
		    push(@new_to_mergeA, $merged_root);
		    printf MG ("if(-e \"$merged_lower_name\") { \n"); 
		    printf MG ("\tif(-e \"$merged_upper_name\") { \n"); 
		    printf MG ("\t\tsystem(\"$cmalign -o $merged_name --merge $cm_file $merged_lower_name $merged_upper_name\");\n");
		    printf MG ("\t\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"$cmalign -o $merged_name --merge $cm_file $merged_lower_name $merged_upper_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
		    if($do_filteraln) { 
			printf MG ("\t\tsystem(\"$esl_weight -f --idf $filter_id $merged_name > $fil_merged_name\");\n");
			printf MG ("\t\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"$esl_weight -f --idf $filter_id $merged_name > $fil_merged_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
			#erase non-filtered alignment
			printf MG ("if(-e \"$merged_name\") { \n"); 
			printf MG ("\tsystem(\"rm $merged_name\");\n");
			printf MG ("\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"rm $merged_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
			printf MG ("} \n");
		    }
		    printf MG ("\t\t}\n");
		    # else $merged_lower_name exists, but $merged_upper_name does not exist
		    printf MG ("\telse { \n");
		    printf MG ("\t\tsystem(\"cp $merged_lower_name $merged_name\");\n");
		    printf MG ("\t\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"cp $merged_lower_name $merge_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
		    printf MG ("\t}\n");
		    printf MG ("}\n");
		    printf MG ("elsif((-e \"$merged_upper_name\")) { \n"); 
		    # else $merged_upper_name exists, but $merged_lower_name does not exist
		    printf MG ("\tsystem(\"cp $merged_upper_name $merged_name\");\n");
		    printf MG ("\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"cp $merged_upper_name $merge_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
		    printf MG ("}\n");
		    printf MG ("\n");
		    # else: neither $merged_upper_name exists, nor $merged_lower_name exists, do nothing next iteration will handle this
		    
		    # erase the intermediate alignments if they exists 
		    if($iter > 1) { 
			printf MG ("if(-e \"$merged_lower_name\") { \n"); 
			printf MG ("\tsystem(\"rm $merged_lower_name\");\n");
			printf MG ("\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"rm $merged_lower_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
			printf MG ("} \n");
			printf MG ("if(-e \"$merged_upper_name\") { \n"); 
			printf MG ("\tsystem(\"rm $merged_upper_name\");\n");
			printf MG ("\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"rm $merged_upper_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
			printf MG ("} \n");
			printf MG ("\n");
		    }
		}
		if (($nmerge % 2) != 0) { push(@new_to_mergeA, $to_mergeA[($nmerge-1)]); }
		@to_mergeA = @new_to_mergeA;
		$nmerge = scalar(@to_mergeA);
	    }
	}
	close(MG);
    }

    printf("Success!\n");
    $namelen = length($shell_script);
    if(length($merge_script) > $namelen) { $namelen = length($merge_script); }
    printf("%-*s : directory with %d new FASTA files.\n", $namelen, $out_dir . "\/", $prep_nproc);
    printf("%-*s : shell script that will run ssu-align.pl %d times, once for each new FASTA file.\n", $namelen, $shell_script, $prep_nproc);
    if($do_align) { 
	printf("%-*s : perl script to run after %s that will merge the %d alignments together into 1.\n", $namelen, $merge_script, $shell_script, $prep_nproc);
    }
    $shell_script =~ s/$out_dir\///;
    $merge_script =~ s/$out_dir\///;
    printf("To execute (doesn't work if you're going to use a cluster):\ncd $out_dir; sh $shell_script; perl $merge_script;\n");
    exit(0);
}

#####################################################################
# subroutine: process_cm_file()
# incept:     EPN, Tue Nov  4 08:20:47 2008
# 
# purpose:    Validate and process the CM file. A CM file 
#             <$my_cm_file_copy> is valid if each of the <x> CM 
#             within it is has a unique name. Process the CM file 
#             by splitting it into <x> new files. 
#
# returns:    <@{$indi_cm_name_Aref}> filled with names of CMs
#             <@{$indi_cm_file_name_Aref}> filled with names of 
#                         newly created individual CM file names.
#             <@{$indi_cm_clen_Aref}> filled with clens of CMs
#             <@{$indi_cm_nbif_Aref}> filled with # bifs of CMs
#
# exits:      If two CMs in <$cm_file> have the same name we exit,
#             or we can't open <$my_cm_file_copy>.
# 
####################################################################
sub process_cm_file { 
    my $narg_expected = 7;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, process_cm_file() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($do_prep, $my_cm_file_copy, $out_root, $indi_cm_name_Aref, $indi_cm_file_name_Aref, $indi_cm_clen_Aref, $indi_cm_nbif_Aref) = @_;
    
    my($cmi, $line, $inf_line, $cm_name, $indi_file_name, $my_cm_file_root);
    my %cm_name_exists_H = ();

    if($my_cm_file_copy !~ m/\.cm$/) { printf STDERR ("ERROR, CM file name must end with \".cm\", $my_cm_file_copy does not.\n"); exit(1); }
    $my_cm_file_root = $my_cm_file_copy;
    $my_cm_file_root =~ s/\.cm$//;

    if(open(CM, $my_cm_file_copy) == 0) { printf STDERR ("ERROR, could not open $my_cm_file_copy for reading.\n"); exit(1); }
    $cmi = 0;
    while($line = <CM>) {
	if($line =~ /^INFERNAL/) { 
	    $inf_line = $line;
	    $cmi++;
	}
	elsif($line =~ /^NAME\s+(\S+)/) { 
	    $cm_name = $1;
	    $indi_file = $my_cm_file_root . "." . $cm_name . ".m" . $cmi . ".cm";
	    if(!$do_prep) { 
		if(open(OUT, ">" . $indi_file) == 0) { printf STDERR ("ERROR, could not open $indi_file for writing.\n"); exit(1); }
		print OUT $inf_line;
		print OUT $line;
	    }
	    push(@{$indi_cm_name_Aref},      $cm_name);
	    push(@{$indi_cm_file_name_Aref}, $indi_file);
	    if(exists($cm_name_exists_H{$cm_name})) { printf STDERR ("ERROR, two CMs in CM file $my_cm_file_copy have the name $cm_name. Each CM must have a unique name.\n"); exit(1); }
	    $cm_name_exists_H{$cm_name} = 1;
	}
	elsif($line =~ /^CLEN\s+(\S+)/) { 
	    push(@{$indi_cm_clen_Aref}, $1);
	    if(!$do_prep) { print OUT $line; }
	}
	elsif($line =~ /\[\s+BIF\s+\d+\s+\]/) { 
	    $indi_cm_nbif_Aref->[($cmi-1)]++;
	    if(!$do_prep) { print OUT $line; }
	}
	elsif($line =~ m/^\/\//) { 
	    if(!$do_prep) { 
		print OUT $line; 
		close(OUT);
	    }
	}
	else { if(!$do_prep) { print OUT $line; } }
    }
    close(CM);
    if(scalar(@{$indi_cm_name_Aref}) != scalar(@{$indi_cm_file_name_Aref})) { printf STDERR ("ERROR, CM file processed incorrectly, %d CM names read, but %d new CM files created.\n", scalar(@{$indi_cm_name_Aref}), scalar(@{$indi_cm_file_name_Aref})); }
    if(scalar(@{$indi_cm_name_Aref}) != scalar(@{$indi_cm_clen_Aref}))      { printf STDERR ("ERROR, CM file processed incorrectly, %d CM names read, but %d CLEN lines read.\n", scalar(@{$indi_cm_name_Aref}), scalar(@{$indi_cm_file_clen_Aref})); } 
    if(scalar(@{$indi_cm_name_Aref}) != scalar(@{$indi_cm_nbif_Aref}))      { printf STDERR ("ERROR, CM file processed incorrectly, %d CM names read, but %d counts of bifurcs collected.\n", scalar(@{$indi_cm_name_Aref}), scalar(@{$indi_cm_file_nbif_Aref})); } 
    return;
}									 

#####################################################################
# subroutine: search_sequences_with_each_cm()
# incept:     EPN, Mon Nov  3 15:42:17 2008
# 
# purpose:    Run cmsearch on the target sequence file <$target_file>
#             in HMM mode to define start/stops of each sequence,
#             and to verify they're likely SSU at all.
#             
# returns:    Nothing.
#
# exits:      If the cmsearch call doesn't finish with a zero status
#             code we exit. cmsearch should print an error message 
#             to standard error if this occurs.
# 
####################################################################
sub search_sequences_with_each_cm() { 
    my $narg_expected = 11;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, search_sequences_with_each_cm() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($cmsearch, $my_cm_file_copy, $target_file, $out_dir_root, $nseq_target_file, $do_viterbi, $indi_cm_file_name_Aref, $indi_cm_clen_Aref, $indi_cm_nbif_Aref, $ret_tab_file, $ret_max_file_name_width) = @_;

    my ($tab_file, $file_name_width, $file_name_dashes, $search_psecs, $alg_flag, $max_file_name_width, $dashes);

    #crudely predict the number of seconds the cmsearch will take
    $search_psecs = 0;
    for($i = 0; $i < scalar(@{$indi_cm_clen_Aref}); $i++) { $search_psecs += ($indi_cm_clen_Aref->[$i] * $indi_cm_clen_Aref->[$i]); }
    #$search_psecs is now predicted number of DP cells per sequence
    $search_psecs *= ($target_nseq) / 1000000.; # $search_psecs is now predicted num of million cells for all seqs
    if($opt_F) { $search_psecs /= 100. } # cmsearch --forward does about 100 million dp cells per second;
    else       { $search_psecs /= 300. } # cmsearch --viterbi does about 100 million dp cells per second;

    $Wcalc_psecs = 0;
    # OLD CODE (EPN, Wed Nov 12 06:06:50 2008) for predicting W calc time, prior to --hmm-cW option */
    #for($i = 0; $i < scalar(@{$indi_cm_clen_Aref}); $i++) { 
    #$Wcalc_psecs += ($indi_cm_clen_Aref->[$i] * $indi_cm_clen_Aref->[$i] * $indi_cm_clen_Aref->[$i] * $indi_cm_nbif_Aref->[$i]);
    #} #$Wcalc_psecs is now roughly the number of DP cells required to fill to calculate W ($clen^3 * $nbif)
    #$Wcalc_psecs /= (1500 * 1500 * 1500 * 30); #$Wcalc_psecs is now fraction of DP cells to calc W for all CMs relative to an avg size SSU CM
    ## we know SSU models in cmsearch take about 60 seconds to calculate W
    #$Wcalc_psecs *= 60.;
    #$search_psecs += $Wcalc_psecs;

    $tab_file = $out_dir_root . ".tab";
    if   ($do_viterbi) { $alg_flag = "--viterbi"; } 
    else               { $alg_flag = "--forward"; } 

    printf("#\n# Stage 1: Defining SSU start/ends with cmsearch (crude time estimate: %.1f minutes) ... ", ($search_psecs / 60.));
    #printf("$cmsearch -T -1 --no-null3 --toponly --noalign --tab $tab_file $alg_flag $my_cm_file_copy $target_file > /dev/null\n");
    system("$cmsearch --hmm-cW 1.5 -T -1 --no-null3 --toponly --noalign --tab $tab_file $alg_flag $my_cm_file_copy $target_file > /dev/null");
    if(($? >> 8) != 0) { printf STDERR ("ERROR, system\(\"$cmsearch --hmm-cW -T -1 --no-null3 --toponly --noalign --tab $tab_file $alg_flag $my_cm_file_copy $target_file > /dev/null\" unexpectedly returned non-zero exit status %d\n", ($? >> 8)); exit(($? >> 8)); } 
    printf(" done.\n");
    printf("#\n");

    # print info on what we just created
    $max_file_name_width = max_length_scalar_in_array($indi_cm_file_name_Aref); 
    $max_file_name_width += length($out_dir_root . "/.sseq.fa");

    $dashes = ""; for($i = 0; $i < $max_file_name_width; $i++) { $dashes .= "-"; } 
    printf("# %-*s  %11s\n", $max_file_name_width, "output file name", "description");
    printf("# %-*s  %11s\n", $max_file_name_width, $dashes, "-----------");
    #printf("\t%-*s cmsearch output file with locations/scores of hits using HMM.\n", $max_file_name_width, $out_dir_root . ".cmsearch :");
    printf("  %-*s  cmsearch tabular output file with locations/scores of hits using HMM.\n", $max_file_name_width, $tab_file);

    $$ret_tab_file = $tab_file;
    $$ret_max_file_name_width = $max_file_name_width;
    return;
}

#####################################################################
# subroutine: classify_and_extract_subseqs()
# incept:     EPN, Mon Nov  3 17:14:33 2008
# 
# purpose:    Extract subsequences given the cmsearch tab file 
#             output. Also determine the CM c that has the highest
#             scoring hit to each sequence s and classify s as 
#             belonging to c. Then when we do alignment, for each 
#             CM we align all of that CM's seqs to it. Each sequence
#             is classified as belonging to only 1 CM. If only
#             1 CM exists in the CM file, then all sequences
#             will automatically be classified to it.
#             All the work in this function is done by the 
#             ssu-tab2sseq.pl script.
#             
# returns:    Nothing.
#
# exits:      If the ssu-tab2sseq.pl call doesn't finish with a 
#             zero status code we exit. 
# 
####################################################################
sub classify_and_extract_subseqs { 
    my $narg_expected = 10;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, classify_and_extract_subseqs() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($do_truncate, $min_bit, $min_len, $tab_file, $target_file, $out_dir_root, $esl_sfetch, $max_file_name_width, $indi_cm_name_Aref, $new_target_file_per_cm_name_Href) = @_;

    my @seq_order_A = ();
    my %seq_exists_in_order_array_H = ();
    my @cm_name_from_tab_file_A = ();
    my($cm_name, $line);
    my($seq_name, $tstart, $tend, $qstart, $qend, $bit, $E, $gc, $tlen, $m, $i);
    my %bit_cm_seq_HH = ();
    my %bit_seq_cm_HH = ();
    my %start_cm_seq_HH = ();
    my %end_cm_seq_HH = ();
    
    # Parse tab file, keep track of best scoring hit above our min length and min bit score for each CM for each seq
    if(open(TAB, $tab_file) == 0) { printf STDERR ("ERROR, could not open $tab_file for reading.\n"); exit(1); }
    $cm_name = "";
    while($line = <TAB>) { 
	chomp $line;
	if($line =~ m/^\#\s+CM\:\s+(.+)$/) { 
	    $cm_name = $1;
	    push(@cm_name_from_tab_file_A, $cm_name);
	}
	elsif($line !~ m/^\#/) { 
	    $line =~ s/^\s+//;
	    ($seq_name, $tstart, $tend, $qstart, $qend, $bit, $E, $gc) = split(/\s+/, $line);
	    $tlen = $tend - $tstart + 1;
	    if((!(exists($bit_cm_seq_HH{$cm_name}{$seq_name}))) || ($bit > $bit_cm_seq_HH{$cm_name}{$seq_name})) { 
		if(($tlen >= $min_len) && ($bit >= $min_bit)) { 
		    $bit_cm_seq_HH{$cm_name}{$seq_name}   = $bit;
		    $bit_seq_cm_HH{$seq_name}{$cm_name}   = $bit;
		    $start_cm_seq_HH{$cm_name}{$seq_name} = $tstart;
		    $end_cm_seq_HH{$cm_name}{$seq_name}   = $tend;
		    if(!(exists($seq_exists_in_order_array_H{$seq_name}))) { push(@seq_order_A, $seq_name); $seq_exists_in_order_array_H{$seq_name} = 1; }
		}
	    }
	}
    }
    # Make sure our tab file contains the same CMs in the same order as our CM file did.
    $ncm_in_tab_file = scalar(@cm_name_from_tab_file_A);
    if(scalar(@cm_name_from_tab_file_A) != scalar(@{$indi_cm_name_Aref})) { 
	printf STDERR ("ERROR, %d CMs read in tab file != %d CMs read from CM file.\n", scalar(@cm_name_from_tab_file_A), scalar(@{$indi_cm_name_Aref}));
	exit(1);
    }
    for($m = 0; $m < scalar(@cm_name_from_tab_file_A); $m++) { 
	if($cm_name_from_tab_file_A[$m] ne $indi_cm_name_Aref->[$m]) { 
	    printf STDERR ("ERROR, CM number %d (%s) from the tab file output is not the same as CM %d from the CM file (%s).\n", $cm_name_from_tab_file_A[$m], $indi_cm_name_Aref->[$m]);
	    exit(1);
	}
    }

    # classify each seq: determine highest scoring CM for each seq
    my @tmp_bit_A = ();
    my @tmp_cm_A = ();
    my @by_cm_name_HA = ();
    my @by_cm_bit_HA = ();
    my ($winner_cm, $winner_bit);
    foreach $seq_name (@seq_order_A) { 
	@tmp_bit_A = ();
	@tmp_cm_A  = ();
	foreach $cm_name (sort keys (%{$bit_seq_cm_HH{$seq_name}})) { 
	    push(@tmp_bit_A,$bit_seq_cm_HH{$seq_name}{$cm_name});
	    push(@tmp_cm_A, $cm_name);
	}
	$winner_idx = argmax_array(\@tmp_bit_A);
	$winner_cm  = $tmp_cm_A[$winner_idx];
	$winner_bit = $tmp_bit_A[$winner_idx];

	push(@{$by_cm_name_HA{$winner_cm}},  $seq_name);
	push(@{$by_cm_bit_HA{$winner_cm}},   $winner_bit);
	push(@{$by_cm_start_HA{$winner_cm}}, $start_cm_seq_HH{$winner_cm}{$seq_name});
	push(@{$by_cm_end_HA{$winner_cm}},   $end_cm_seq_HH{$winner_cm}{$seq_name});
    }

    # For each CM c, list the target sequences that score highest to c in tabular format
    # and then fetch them with esl-sfetch
    my ($index_file, $ncm_with_at_least_one_seq, $list_file, $esl_sfetch_in_file, $nwinners, $max_seq_name_width, $sseq_file, $esl_sfetch_options);
    $ncm_with_at_least_one_seq = 0;
    $index_file = $target_file . ".ssi";
    
    #if index file exists, remove it and remake it (this is the only way to know for sure that the index was created for this specific file)
    if(-e $index_file)    { system("rm $index_file"); } 
    if(($? >> 8) != 0)    { printf STDERR ("ERROR, system(\"rm $index_file\" unexpectedly returned non-zero exit status %d.\n", ($? >> 8)); exit($? >> 8); }
    system("$esl_sfetch \-\-index $target_file > /dev/null"); 
    if(($? >> 8) != 0)    { printf STDERR ("ERROR, system(\"$esl_sfetch \-\-index $target_file > /dev/null\" unexpectedly returned non-zero exit status %d.\n", ($? >> 8)); exit($? >> 8); }

    for($m = 0; $m < scalar(@{$indi_cm_name_Aref}); $m++) { 
	$cm_name = $indi_cm_name_Aref->[$m];
	$list_file = $out_dir_root . "." . $cm_name . ".sseq.list"; 
	$esl_sfetch_in_file = $out_dir_root . "." . $cm_name . ".sseq.in";
	$nwinners = scalar(@{$by_cm_name_HA{$cm_name}});

	if($nwinners > 0) { 
	    $ncm_with_at_least_one_seq++;
	    if(open(OUTLIST,  ">" . $list_file) == 0)      { printf STDERR ("ERROR, could not open $list_file for writing.\n"); exit(1); }
	    if(open(SFETCHIN, ">" . $esl_sfetch_in_file) == 0) { printf STDERR ("ERROR, could not open $esl_sfetch_in_file for writing.\n"); exit(1); }

	    # determine max seq name width 
	    $max_seq_name_width = 0;
	    for($i = 0; $i < $nwinners; $i++) { if(length($by_cm_name_HA{$cm_name}[$i]) > $max_seq_name_width) { $max_seq_name_width = length($by_cm_name_HA{$cm_name}[$i]); } }
	    $dashes = "";
	    for($i = 0; $i < $max_seq_name_width; $i++) { $seq_name_dashes .= "-"; }
	    printf OUTLIST  ("# List of %d subsequences to align to CM: $cm_name\n", $nwinners);
	    printf OUTLIST  ("# Created by ssu-align.pl.\n#\n");
	    printf OUTLIST  ("# %-*s  %6s  %6s  %8s\n", $max_seq_name_width, "seqname", "start", "stop", "score");
	    printf OUTLIST  ("# %*s  %6s  %6s  %8s\n", $max_seq_name_width, $dashes, "------", "------", "--------");

	    for($i = 0; $i < $nwinners; $i++) { 
		#printf("%4d  $cm_name  %25s  %7.2f  %8d  %8d\n", ($i+1), $by_cm_name_HA{$cm_name}[$i], $by_cm_bitHA{$cm_name}[$i], $by_cm_startHA{$cm_name}[$i], $by_cm_endHA{$cm_name}[$i]);
		printf OUTLIST ("  %*s  %6d  %6d  %8.2f\n", $max_seq_name_width, $by_cm_name_HA{$cm_name}[$i], $by_cm_start_HA{$cm_name}[$i], $by_cm_end_HA{$cm_name}[$i], $by_cm_bit_HA{$cm_name}[$i]);
		if($do_truncate) { printf SFETCHIN ("$by_cm_name_HA{$cm_name}[$i]\t$by_cm_start_HA{$cm_name}[$i]\t$by_cm_end_HA{$cm_name}[$i]\t$by_cm_name_HA{$cm_name}[$i]\n"); }
		else             { printf SFETCHIN ("$by_cm_name_HA{$cm_name}[$i]\n"); }
	    }
	    #printf("\n");
	    close(OUTLIST);
	    close(SFETCHIN);
	    #printf("Subsequences of %d seqs (<name> <start> <end> <bit score>) for CM $cm_name printed to file $listfile.\n", scalar(@{$by_cm_name_HA{$cm_name}}));
	    printf("  %-*s  list of high scoring subseqs to align with $cm_name CM.\n", $max_file_name_width, $list_file);

	    $sseq_file = $out_dir_root . "." . $cm_name . ".sseq.fa";
	    if(-e ($sseq_file)) { system("rm $sseq_file"); }
	    if($do_truncate) { $esl_sfetch_options = "-Cf"; }
	    else             { $esl_sfetch_options = "-f";  }
	    if($do_truncate) { system("$esl_sfetch -o $sseq_file $esl_sfetch_options $target_file $esl_sfetch_in_file > /dev/null"); }
	    else             { system("$esl_sfetch -o $sseq_file $esl_sfetch_options $target_file $esl_sfetch_in_file > /dev/null"); }
	    if(($? >> 8) != 0) { printf STDERR ("ERROR, system(\"$esl_sfetch $esl_sfetch_options $target_file $esl_sfetch_in_file\" unexpectedly returned non-zero exit status %d.\n", ($? >> 8)); exit($? >> 8); }

	    #printf("esl-sfetch -Cf $target_file $listfile > $sseq_file\n");
	    $output = `head -1 $sseq_file`;
	    if($output =~ m/\W/) { printf("  %-*s  FASTA file of high scoring subseqs to align with $cm_name CM (%d sequences).\n", $max_file_name_width, $sseq_file, scalar(@{$by_cm_name_HA{$cm_name}})); }
	    else                 { printf("ERROR, esl-sfetch command $esl_sfetch -o $sseq_file -Cf $target_file $esl_sfetch_in_file didn't work.\n");  exit(1); }
	    system("rm $esl_sfetch_in_file");
	    $new_target_file_per_cm_name_Href->{$cm_name} = $sseq_file;
	}
    }
    if($ncm_with_at_least_one_seq == 0) { 
	printf("ERROR, 0 seqs had cmsearch hits with bit score > $min_bit and length > $min_len to any of the %d CMs in the tab file $tab_file.\nYou can change the minimum bit score to <x> with -B <x>, and minimum length to <n> with -L <n>.\n", scalar(@{$indi_cm_name_Aref}));
	exit(1);
    }
    return;
}

#####################################################################
# subroutine: align_subseqs()
# incept:     EPN, Mon Nov  3 17:20:42 2008
# 
# purpose:    For each CM c, align all of c's classified sequences to
#             c using cmalign. If 0 seqs are classified as belonging
#             to c, skip the alignment step for c.
#
# returns:    Nothing.
#
# exits:      If a cmalign call doesn't finish with a zero status
#             code. cmsearch should print an error message to
#             standard error if this occurs.
#  
####################################################################
sub align_subseqs { 
    my $narg_expected = 10;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, align_subseqs() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($out_dir_root, $cmalign, $max_file_name_width, $esl_weight, $do_filteraln, $filter_id, $indi_cm_name_Aref, $indi_cm_file_name_Aref, $indi_cm_clen_Aref, $new_target_file_per_cm_name_Href) = @_;

    my($max_cm_name_width, $cm_dashes, $seq_dashes, $ncm, $m, $cm_file_name, $cm_name, $cm_clen, $sseq_file, $nseq_this_file, $align_psecs, $cmalign_out, $cmalign_stk);

    $max_cm_name_width = max_length_scalar_in_array($indi_cm_name_Aref); 
    $cm_dashes = "";  for($i = 0; $i < $max_cm_name_width; $i++)     { $cm_dashes .= "-"; } 
    $seq_dashes = ""; for($i = 0; $i < $max_file_name_width-2; $i++) { $seq_dashes .= "-"; } 
    printf("#\n");
    printf("# Stage 2. Aligning sequences.\n");
    printf("#\n");
    printf("# %5s  %-*s  %-*s  %7s  %7s\n", "stage", $max_cm_name_width, "cm",       $max_file_name_width, "seq file", "nseq", "est min");
    printf("# %5s  %-*s  %-*s  %7s  %7s\n", "-----", $max_cm_name_width, $cm_dashes, $max_file_name_width, $seq_dashes, "-------", "-------");

    $ncm = scalar(@{$indi_cm_file_name_Aref});
    for($m = 0; $m < $ncm; $m++) { 
	$cm_file_name = $indi_cm_file_name_Aref->[$m];
	$cm_name = $indi_cm_name_Aref->[$m];
	$cm_clen = $indi_cm_clen_Aref->[$m];
	if(!(exists($new_target_file_per_cm_name_Href->{$cm_name}))) { # no sequences in this set were classified as the current CM
	    $nseq_this_file = 0;
	    $sseq_file = "NONE (no matching seqs)";
	}
	else { 
	    $sseq_file      = $new_target_file_per_cm_name_Href->{$cm_name};
	    $nseq_this_file = determine_num_seqs($sseq_file);
	}
	$align_psecs = ($cm_clen * $cm_clen) / (1500 * 1500); #$align_psecs is fraction of SSU alignment time this seq aln will take
	$align_psecs *= $nseq_this_file;
	$cmalign_out = $out_dir_root . ".m" . ($m+1) . ".cmalign";
	if($do_filteraln) { 
	    $cmalign_stk     = $out_dir_root . ".m" . ($m+1) . ".cmalign.nf.stk"; 
	    $fil_cmalign_stk = $out_dir_root . ".m" . ($m+1) . ".cmalign.stk"; 
	}
	else { 
	    $cmalign_stk     = $out_dir_root . ".m" . ($m+1) . ".cmalign.stk"; 
	}
	printf("  %2d/%2d  %-*s  %-*s  %7d  %7.2f\n", $m+1, $ncm, $max_cm_name_width, $cm_name, $max_file_name_width, $sseq_file, $nseq_this_file, $align_psecs / 60.);
	#printf("$cmalign --sub -o $cmalign_stk $cm_for_cmalign[$c] $sseq_file > $cmalign_out\n");
	if($nseq_this_file > 0) { system("$cmalign --sub -o $cmalign_stk $cm_file_name $sseq_file > $cmalign_out"); }
	if(($? >> 8) != 0) { printf STDERR ("ERROR, system\(\"$cmalign --sub -o $cmalign_stk $cm_for_cmalign[$c] $sseq_file > $cmalign_out\"\) unexpectedly returned non-zero exit status %d\n", ($? >> 8)); exit(($? >> 8)); } 

	if($do_filteraln) { 
	    if($nseq_this_file > 0) { system("$esl_weight -f --idf $filter_id $cmalign_stk > $fil_cmalign_stk"); }
	    if(($? >> 8) != 0) { printf STDERR ("ERROR, system\(\"$esl_weight -f --idf $filter_id $cmalign_stk > $fil_cmalign_stk\"\) unexpectedly returned non-zero exit status %d\n", ($? >> 8)); exit(($? >> 8)); } 
	}
    }
    return;
}

#################################################################
# subroutine : argmax_arr()
# incept:      EPN, Tue Nov  4 14:33:23 2008
# 
# purpose : Return the index of the max value in an array
################################################################# 
sub argmax_array
{
    my $narg_expected = 1;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, argmax_arr() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($arr_ref) = $_[0];

    my ($max, $i, $argmax);
    $max = $arr_ref->[0];
    $argmax = 0;
    for($i = 1; $i < scalar(@{$arr_ref}); $i++) { 
	if($arr_ref->[$i] > $max) { $max = $arr_ref->[$i]; $argmax = $i; }
    }
    return $argmax;
}

#################################################################
# subroutine : max_length_scalar_in_arr()
# incept:      EPN, Tue Nov  4 15:19:44 2008
# 
# purpose:     Return the maximum length of a scalar in an array
# 
################################################################# 
sub max_length_scalar_in_array {
    my $narg_expected = 1;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, max_length_scalar_in_arr() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($arr_ref) = $_[0];

    my ($max, $i);
    $max = length($arr_ref->[0]);
    for($i = 1; $i < scalar(@{$arr_ref}); $i++) { 
	if(length($arr_ref->[$i]) > $max) { $max = length($arr_ref->[$i]); }
    }
    return $max;
}

