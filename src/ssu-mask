#!/usr/bin/perl
#
# ssu-mask
# Eric Nawrocki
# EPN, Wed Sep 23 06:18:47 2009
#
# Usage: ssu-mask [options] <directory created by ssu-align (includes alignment file(s))>
# Usage: ssu-mask [options] -a <Stockholm alignment file (must have .stk suffix)>
#             
# Synopsis:
# Masks alignments by removing columns with a significant fraction of 
# ambiguously aligned residues based on alignment posterior probabilities.
# Alternatively, sequences from alignments can be listed 
#
# See definition of $options_usage for options, below.
#
use Getopt::Long;
use Cwd 'abs_path';
use strict;
use warnings;

my $total_time = -1 * time();
my $usage =  "Usage: ssu-mask [options] <directory created by ssu-align (includes >= 1 alignment file(s))>\n";
   $usage .= "Usage: ssu-mask [options] -a <Stockholm alignment file (must have .stk suffix)>\n";
my $options_usage  = "where general options are:\n";
#                           1         2         3         4         5         6         7         8
#                  12345678901234567890123456789012345678901234567890123456789012345678901234567890
#$options_usage .= "  -a            : the command-line argument is a stockholm alignment, not a directory\n";
$options_usage .= "  -h            : show brief help on version and usage\n";
$options_usage .= "  -1            : output alignment(s) in non-interleaved, 1 line/seq format\n";
$options_usage .= "  -m <f>        : CM file <f> created the alignment(s) (with ssu-align -m <f>)\n";
$options_usage .= "  -t <f>        : for structure diagrams, use template file <f>, not the default\n";
$options_usage .= "  --afa         : output aligned FASTA (.afa) alignments as well as Stockholm ones\n";
$options_usage .= "  --only-afa    : only output aligned FASTA (.afa) alignments, no Stockholm ones\n";
$options_usage .= "  --key-in <s>  : assume <s> is part of input file names, before the suffix\n";
$options_usage .= "  --key-out <s> : add <s> to all output file names, before the suffix\n";
$options_usage .= "\noptions related to masking alignments\n";
$options_usage .= "  --pf <x>        : include columns w/<x> fraction of seqs w/prob >= --pt <y> [df: 0.95]\n";
$options_usage .= "  --pt <y>        : set probability threshold for --pf as <x> [default=0.95]\n";
$options_usage .= "  --no-prob       : exclude insert columns only, do not mask based on probabilities\n";
$options_usage .= "  --gapthresh <x> : only consider columns with <= <x> fraction gaps\n";
$options_usage .= "  --in-mask <f>   : mask alignment given 1/0s in 1-line mask file <f>, requires -a\n";
$options_usage .= "  --keep          : keep all intermediate files which are normally removed\n";
$options_usage .= "  --pdf <s>       : <s> (!= \"ps2pdf\") is the command for converting ps to pdf\n";
$options_usage .= "  --rm-ps         : if --pdf or ps2pdf is installed, do not save postscript files\n";
$options_usage .= "\noption for filtering alignments based on sequence identity (no masking)\n";
$options_usage .= "  --filter <x> : remove seqs such that no 2 seqs > <x> identical (1st seq is always kept)\n";
$options_usage .= "\noption for listing sequences in alignment(s) (no masking)\n";
$options_usage .= "  --list : output list of sequence names in alignment(s)\n";    
$options_usage .= "\noptions for converting a Stockholm alignment to aligned fasta (no masking):\n";
$options_usage .= "  --stk2afa : convert Stockholm alignment(s) to aligned FASTA and exit\n"; 
$options_usage .= "\noptions for only removing sequences from an alignment, require -a (no masking):\n";
$options_usage .= "  --seq-r <f> : with -a, remove sequences with names listed in file <f>\n"; 
$options_usage .= "  --seq-k <f> : with -a, remove all sequences *except* those listed in file <f>\n"; 

###################
# Process options #
###################
my %opt_H = ();              # key: option (example "-h"); value: option argument (example ("0" or "1") if option takes no arg, actual argument if option takes arg)
my %opt_takes_arg_H  = ();   # key: option; value: "1" if option takes argument, "0" if not
my @opt_order_A  = ();       # order of options for printing in banner
my $opt;

$opt_takes_arg_H{"-a"}          = 0;  push(@opt_order_A, "-a");           
$opt_takes_arg_H{"-h"}          = 0;  push(@opt_order_A, "-h");           
$opt_takes_arg_H{"-1"}          = 0;  push(@opt_order_A, "-1");           
$opt_takes_arg_H{"-m"}          = 1;  push(@opt_order_A, "-m");           
$opt_takes_arg_H{"-t"}          = 1;  push(@opt_order_A, "-t");           
$opt_takes_arg_H{"--afa"}       = 0;  push(@opt_order_A, "--afa");      
$opt_takes_arg_H{"--only-afa"}  = 0;  push(@opt_order_A, "--only-afa");      
$opt_takes_arg_H{"--key-in"}    = 1;  push(@opt_order_A, "--key-in");     
$opt_takes_arg_H{"--key-out"}   = 1;  push(@opt_order_A, "--key-out");    
$opt_takes_arg_H{"--pf"}        = 1;  push(@opt_order_A, "--pf");      
$opt_takes_arg_H{"--pt"}        = 1;  push(@opt_order_A, "--pt");      
$opt_takes_arg_H{"--no-prob"}   = 0;  push(@opt_order_A, "--no-prob");      
$opt_takes_arg_H{"--gapthresh"} = 1;  push(@opt_order_A, "--gapthresh");      
$opt_takes_arg_H{"--in-mask"}   = 1;  push(@opt_order_A, "--in-mask");    
$opt_takes_arg_H{"--keep"}      = 0;  push(@opt_order_A, "--keep");
$opt_takes_arg_H{"--pdf"}       = 1;  push(@opt_order_A, "--pdf");
$opt_takes_arg_H{"--rm-ps"}     = 0;  push(@opt_order_A, "--rm-ps");      
$opt_takes_arg_H{"--filter"}    = 1;  push(@opt_order_A, "--filter");      
$opt_takes_arg_H{"--list"}      = 0;  push(@opt_order_A, "--list");
$opt_takes_arg_H{"--stk2afa"}   = 0;  push(@opt_order_A, "--stk2afa");      
$opt_takes_arg_H{"--seq-r"}     = 1;  push(@opt_order_A, "--seq-r");      
$opt_takes_arg_H{"--seq-k"}     = 1;  push(@opt_order_A, "--seq-k");      

#set default options
foreach $opt (keys %opt_takes_arg_H) { 
    if($opt_takes_arg_H{$opt}) { $opt_H{$opt} = ""; }
    else                       { $opt_H{$opt} = 0; }
}

# the only global variables: default values
our $df_pf = 0.95;
our $df_pt = 0.95;

Getopt::Long::Configure ("bundling");
my $opt_return = GetOptions
    ('a'           => \$opt_H{"-a"},
     'h'           => \$opt_H{"-h"}, 
     '1'           => \$opt_H{"-1"},
     'm=s'         => \$opt_H{"-m"},
     't=s'         => \$opt_H{"-t"},
     'afa'         => \$opt_H{"--afa"},
     'only-afa'    => \$opt_H{"--only-afa"},
     'key-in=s'    => \$opt_H{"--key-in"},
     'key-out=s'   => \$opt_H{"--key-out"},
     'pf'          => \$opt_H{"--pf"},
     'pt'          => \$opt_H{"--pt"},
     'no-prob'     => \$opt_H{"--no-prob"},
     'gapthresh=s' => \$opt_H{"--gapthresh"},
     'in-mask'     => \$opt_H{"--in-mask"},
     'keep'        => \$opt_H{"--keep"},
     'pdf'         => \$opt_H{"--pdf"},
     'rm-ps'       => \$opt_H{"--rm-ps"},
     'filter=s'    => \$opt_H{"--filter"},
     'list'        => \$opt_H{"--list"},
     'seq-r=s'     => \$opt_H{"--seq-r"},
     'seq-k=s'     => \$opt_H{"--seq-k"},
     'stk2afa'     => \$opt_H{"--stk2afa"});

if($opt_return != 1) { exit(1); }

if ($opt_H{"-h"}) { 
    print_banner($0, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, 1, "");
    print $usage . "\n"; 
    print $options_usage; 
    exit(1); 
} 

my $key_in = "";
if($opt_H{"--key-in"}  ne "") { $key_in   = "." . $opt_H{"--key-in"};  }
my $key_out = "";
if($opt_H{"--key-out"}  ne "") { $key_out   = "." . $opt_H{"--key-out"};  }


##############################################################################
# Determine the "mode" to run and check for incompatible option combinations.#
##############################################################################

# There are 5 possible modes, each is exclusive.
my $do_mask_mode        = 0; # default mode, mask the alignment
my $do_remove_seqs_mode = 0; # remove some sequences from the alignment given a list file, no masking
my $do_filter_mode      = 0; # filter alignment(s), no masking
my $do_list_mode        = 0; # list sequences in the alignment, no masking
my $do_stk2afa_mode     = 0; # convert a single alignment file to aligned fasta and exit

# Mask mode options.
if($opt_H{"--pf"} ne "")        { $do_mask_mode = 1; }
if($opt_H{"--pt"} ne "")        { $do_mask_mode = 1; }

if($opt_H{"--no-prob"}) 
{ 
    if($do_mask_mode) { printf STDERR ("\nERROR, --no-prob is incompatible with --pf and --pt.\n"); exit(1); }
    $do_mask_mode = 1; 
}
if($opt_H{"--gapthresh"} ne "")    { $do_mask_mode = 1; }
if($opt_H{"--in-mask"} ne "") { 
    if(!($opt_H{"-a"})) { printf STDERR ("\nERROR, --in-mask requires the -a option.\n"); exit(1); }
    if($do_mask_mode)   { printf STDERR ("\nERROR, --in-mask is incompatible with --pf, --pt, --no-prob, and --gapthresh.\n"); exit(1); }
    $do_mask_mode = 1; 
}

# Remove sequences options.
if(($opt_H{"--seq-r"} ne "") && ($opt_H{"--seq-k"} ne "")) { printf STDERR ("\nERROR, --seq-r and --seq-k are incompatible, choose one.\n"); exit(1); }
if($opt_H{"--seq-r"} ne "")  { $do_remove_seqs_mode = 1; }
if($opt_H{"--seq-k"} ne "")  { $do_remove_seqs_mode = 1; }

if($do_remove_seqs_mode && $do_mask_mode) { 
    printf STDERR ("\nERROR, --pf, --pt, --gapthresh, --filter, --no-prob and --in-mask are incompatible with --seq-k and --seq-r.\n"); exit(1); 
}
if($do_remove_seqs_mode && (! $opt_H{"-a"})) { 
    printf STDERR ("\nERROR,--seq-k and --seq-r require -a. They can only be used on a single alignment.\n"); exit(1); 
}

# Filter options.
if($opt_H{"--filter"} ne "") { $do_filter_mode = 1; }
if($do_filter_mode && $do_mask_mode) { 
    printf STDERR ("\nERROR, --pf, --pt, --gapthresh, --filter, --no-prob and --in-mask are incompatible with --filter.\nFilter first, then mask filtered alignments with a subsequent ssu-mask call\n"); exit(1); 
}
if($do_filter_mode && $do_remove_seqs_mode) { 
    printf STDERR ("\nERROR, --seq-k and --seq-r are incompatible with --filter.\n"); exit(1); 
}

# List sequences options.
if($opt_H{"--list"})      { $do_list_mode = 1;}
if($do_list_mode && $do_mask_mode) { 
    printf STDERR ("\nERROR, --pf, --pt, --gapthresh, --filter, --no-prob and --in-mask are incompatible with --list.\n"); exit(1); 
}
if($do_list_mode && $do_remove_seqs_mode) { 
    printf STDERR ("\nERROR, --seq-k and --seq-r are incompatible with --list.\n"); exit(1); 
}
if($do_list_mode && $do_filter_mode) { 
    printf STDERR ("\nERROR, --list is incompatible with --filter.\n"); exit(1); 
}

# stk2afa options
if($opt_H{"--stk2afa"})  { $do_stk2afa_mode = 1; }

if($do_stk2afa_mode && $do_mask_mode) { 
    printf STDERR ("\nERROR, --pf, --pt, --gapthresh, --filter, --no-prob and --in-mask are incompatible with --stk2afa.\n"); exit(1); 
}
if($do_stk2afa_mode && $do_remove_seqs_mode) { 
    printf STDERR ("\nERROR, --stk2afa is incompatible with --seq-k and --seq-r.\n"); exit(1); 
}
if($do_stk2afa_mode && $do_filter_mode) { 
    printf STDERR ("\nERROR, --stk2afa is incompatible with --filter.\n"); exit(1); 
}
if($do_stk2afa_mode && $do_list_mode) { 
    printf STDERR ("\nERROR, --stk2afa is incompatible with --list.\n"); exit(1); 
}

if(($do_remove_seqs_mode + $do_list_mode + $do_filter_mode + $do_stk2afa_mode) == 0) { $do_mask_mode = 1; }

if($opt_H{"--pdf"}   && (! $do_mask_mode)) { printf STDERR ("\nERROR, --pdf is incompatible with --filter, --list, --stk2afa, --seq-r and --seq-k\n"); exit(1); }
if($opt_H{"--rm-ps"} && (! $do_mask_mode)) { printf STDERR ("\nERROR, --rm-ps is incompatible with --filter, --list, --stk2afa, --seq-r and --seq-k\n"); exit(1); }
if($opt_H{"--keep"}  && (! $do_mask_mode)) { printf STDERR ("\nERROR, --keep is incompatible with --filter, --list, --stk2afa, --seq-r and --seq-k\n"); exit(1); }

if(($opt_H{"--afa"})  && ((! $do_mask_mode) && (! $do_filter_mode)))      { printf STDERR ("\nERROR, --afa is incompatible with --list, --stk2afa, --seq-r, and --seq-k\n"); exit(1); }
if(($opt_H{"--only-afa"})  && ((! $do_mask_mode) && (! $do_filter_mode))) { printf STDERR ("\nERROR, --only-afa is incompatible with --list, --stk2afa, --seq-r, and --seq-k\n"); exit(1); }

if($opt_H{"--afa"}  && ($opt_H{"--only-afa"})) { printf STDERR ("\nERROR, --afa is incompatible with only-afa\n"); exit(1); }

###################################################
# Process command-line arguments and print banner #
###################################################
if(scalar(@ARGV) != 1) {   
    print "Incorrect number of command line arguments.\n";
    print $usage;
    print "\nTo see more help on available options, do ssu-mask -h\n\n";
    exit(1);
}
my ($dir) = $ARGV[0];
$dir =~ s/\/$//;

my ($sum_file, $sum_file2print, $log_file, $log_file2print);
my @files_to_unlink_A = ();
if(!($opt_H{"-a"})) { 
    #validate that $dir exists
    if(!(-d $dir)) { printf STDERR ("\nERROR, directory $dir does not exist.\n"); exit(1); }
    $sum_file       = $dir . "/" . $dir . $key_out . ".ssu-mask.sum";
    $sum_file2print = $dir . $key_out . ".ssu-mask.sum";
    $log_file       = $dir . "/" . $dir . $key_out . ".ssu-mask.log";
    $log_file2print = $dir . $key_out . ".ssu-mask.log";
}
else { 
    $sum_file       = $dir . $key_out . ".ssu-mask.sum";
    $sum_file2print = $sum_file;
    $log_file       = $dir . $key_out . ".ssu-mask.log";
    $log_file2print = $log_file;
}
# open the summary and log files
open(OUT, ">" . $sum_file) || die "ERROR, couldn't open file $sum_file for writing";
close(OUT);
open(OUT, ">" . $log_file) || die "ERROR, couldn't open file $log_file for writing";
close(OUT);

print_banner($0, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, 1, $sum_file);
print_banner($0, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, 0, $log_file);

##################################
# Validate that everything is go #
##################################

my @stk_list_A = ();
my ($cm_file, $template_file, $alimanip, $ssdraw, $weight, $seqstat, $reformat);
validate_and_setup($dir, $key_in, \%opt_H, \$cm_file, \$template_file, \$alimanip, \$ssdraw, \$weight, \$seqstat, \$reformat, \@stk_list_A, $log_file);
my $naln = scalar(@stk_list_A);
my $aln_file;

my $alimanip_options = "";


##########################
# Mask mode: Do the work #
##########################

my $max_width;
my ($i, $tmp, $command, $aln_root, $aln_root2print, $final_key, $nec_width, $dashes, $print_input_aln);
my $ssdraw_failed_at_least_once = 0;
my $ssdraw_worked_at_least_once = 0;

if($do_mask_mode) 
{ 
    my ($do_pmask, $do_gmask, $extra_chars);
    if($opt_H{"--no-prob"})         { $do_pmask = 0; }
    else                            { $do_pmask = 1; }
    if($opt_H{"--gapthresh"} ne "") { $do_gmask = 1; }
    else                            { $do_gmask = 0; }
    if($do_pmask && $do_gmask)      { $extra_chars = 13; } #13 is for ".maskdiff" + (".pdf" or ".stk")
    elsif($opt_H{"--keep"})         { $extra_chars = 10; } #10 is for ".cmask" + (".pdf" or ".stk")
    else                            { $extra_chars = 9; }   #9 is for ".mask" + (".pdf" or ".stk")

    # determine max file name width
    $max_width = length("file name");
    for($i = 0; $i < $naln; $i++) { 
	$aln_file         = $stk_list_A[$i];
	($aln_root)       = ($aln_file =~ /(.+)\.stk/);
	if($opt_H{"-a"}) { #print directory as well as aln name
	    ($aln_root2print) = ($aln_file =~ /(.+)\.stk/);
	}
	else {
	    ($aln_root2print) = ($aln_file =~ /.+\/(.+)\.stk/);
	}
	$nec_width = length($aln_root2print) + length($key_out) + $extra_chars; 
	if($max_width < $nec_width) { $max_width = $nec_width; }
    }					     
    $dashes = ""; for($i = 0; $i < $max_width; $i++) { $dashes .= "-"; }

    print_string_to_file($sum_file, 1, sprintf("#\n# Masking alignments...\n"));
    print_string_to_file($sum_file, 1, sprintf("#\n"));
    print_string_to_file($sum_file, 1, sprintf("# %-*s  %6s  %4s  %5s  %-12s\n", $max_width, "", "", "", "", "    mask"));
    print_string_to_file($sum_file, 1, sprintf("# %-*s  %6s  %4s  %5s  %12s\n", $max_width, "", "", "", "", "------------"));
    print_string_to_file($sum_file, 1, sprintf("# %-*s  %6s  %4s  %5s  %5s  %5s\n", $max_width, "file name", "in/out", "type", "\#cols", "incl.", "excl."));
    print_string_to_file($sum_file, 1, sprintf("# %-*s  %6s  %4s  %5s  %5s  %5s\n", $max_width, $dashes, "------", "----", "-----", "-----", "-----"));
    
    # Mask each alignment
    my $rfmask2use = "";
    my $allmask2use = "";
    my $mask_opts = "";
    my $mask_root = "";
    my $keep_mask = 0;
    my $print_input_aln = 0;
    my $mask_ok_if_fails = 0;
    my $do_draw = 0;
    my $ssdraw_worked = 0;
    my ($pt_opt, $pf_opt);

    $pt_opt = $opt_H{"--pt"};
    $pf_opt = $opt_H{"--pf"};
    if($pt_opt eq "") { $pt_opt = $df_pt; }
    if($pf_opt eq "") { $pf_opt = $df_pf; }

    for($i = 0; $i < $naln; $i++) { 
	$aln_file         = $stk_list_A[$i];
	($aln_root)       = ($aln_file =~ /(.+)\.stk/);
	if($opt_H{"-a"}) { #print directory as well as aln name
	    ($aln_root2print) = ($aln_file =~ /(.+)\.stk/);
	}
	else {
	    ($aln_root2print) = ($aln_file =~ /.+\/(.+)\.stk/);
	}
	
	if($opt_H{"--in-mask"} ne "") { # mask the alignment using the --in-mask mask 
	    my ($mask_worked, $n0, $n1, $inmask_masked_aln_file, $mask_file, $keep_mask, $do_draw, $mask_ok_if_fails);

	    if(!($opt_H{"-a"})) { 
		printf STDERR ("\nERROR, --in-mask requires the -a option.\n"); exit(1); 
	    }
	    if(!(-e $opt_H{"--in-mask"})) { 
		printf STDERR ("\nERROR, the --in-mask file " . $opt_H{"--in-mask"} . " does not exist.\n"); exit(1); 
	    }

	    # first try --mask-rf (to see if the mask is non-gap RF length (instead of full alignment length))
	    $rfmask2use       = $opt_H{"--in-mask"};
	    $allmask2use      = "";
	    $keep_mask        = 0; 
	    $print_input_aln  = 1;
	    $mask_ok_if_fails = 1; #it's okay if --mask-rf does not work, we'll try --mask-all 
	    $mask_opts        = "";
	    $mask_root        = "mask";
	    if(($ssdraw ne "") && ($template_file ne "")) { $do_draw          = 1; }
	    else                                          { $do_draw          = 0; }
	    $mask_worked = mask_alignment($alimanip, \%opt_H, $ssdraw, $aln_root, $aln_root2print, $mask_root, $aln_file, $keep_mask, $print_input_aln, 
					  $mask_opts, $rfmask2use, "", $do_draw, $max_width, $mask_ok_if_fails, $template_file, 
					  \$n0, \$n1, \$inmask_masked_aln_file, \$mask_file, \$ssdraw_worked, \@files_to_unlink_A, $sum_file, $log_file);
	    if(!($mask_worked)) { 
		#try --mask-all (to see if the mask is full alignment length)
		$mask_ok_if_fails = 0;
		$rfmask2use       = "";
		$allmask2use      = $opt_H{"--in-mask"};
		mask_alignment($alimanip, \%opt_H, $ssdraw, $aln_root, $aln_root2print, $mask_root, $aln_file, $keep_mask, $print_input_aln, 
			       $mask_opts, "", $allmask2use, $do_draw, $max_width, $mask_ok_if_fails, $template_file, 
			       \$n0, \$n1, \$inmask_masked_aln_file, \$mask_file, \$ssdraw_worked, \@files_to_unlink_A, $sum_file, $log_file);
		# mask_alignment will exit in error if masking does not work this time
	    }
	    if   ($do_draw && $ssdraw_worked)    { $ssdraw_worked_at_least_once = 1; }
	    elsif($do_draw && (!$ssdraw_worked)) { $ssdraw_failed_at_least_once = 1; }
	}
	else {  #--in-mask not enabled
	    my ($cmasked_aln_file, $cmask_file, $pmasked_aln_file, $pmask_file, $gmasked_aln_file, $gmask_file, $pgmasked_aln_file, $pgmask_file);
	    my ($pgmaskdiff_ps, $pgmaskdiff_ps2print, $pgmaskdiff_pdf, $pgmaskdiff_pdf2print);
	    my ($cn0, $cn1, $pn0, $pn1, $gn0, $gn1, $pgn0, $pgn1);
	    $mask_ok_if_fails = 0;
	    $rfmask2use       = "";
	    $allmask2use      = "";

	    # First masking: remove all insert columns and number the RF columns 
	    if($do_pmask || $do_gmask) { 
		$mask_root = "cmask"; 
		$cmasked_aln_file = $aln_root . $key_out . "." . $mask_root . ".stk";
		$cmask_file       = $aln_root . $key_out . "." . $mask_root . ".mask";
	    }
	    else { #the final mask
		$mask_root = "mask";  
		$cmasked_aln_file = $aln_root . $key_out . "." . $mask_root . ".stk";
		$cmask_file       = $aln_root . $key_out . ".mask";
	    }
	    $keep_mask        = 0;
	    $print_input_aln  = 1;
	    $do_draw          = 0; #don't draw this time
	    $mask_opts = "-k --num-rf";
	    mask_alignment($alimanip, \%opt_H, $ssdraw, $aln_root, $aln_root2print, $mask_root, $aln_file, $keep_mask, $print_input_aln, 
			   $mask_opts, "", "", $do_draw, $max_width, $mask_ok_if_fails, $template_file, 
			   \$cn0, \$cn1, \$cmasked_aln_file, \$cmask_file, \$ssdraw_worked, \@files_to_unlink_A, $sum_file, $log_file);
	    if   ($do_draw && $ssdraw_worked)    { $ssdraw_worked_at_least_once = 1; }
	    elsif($do_draw && (!$ssdraw_worked)) { $ssdraw_failed_at_least_once = 1; }
	    
	    # Probabilistic masking, if necessary
	    if($do_pmask) { 
		if($do_gmask) { 
		    $mask_root = "pmask"; 
		    $pmasked_aln_file = $aln_root . $key_out . "." . $mask_root . ".stk";
		    $pmask_file       = $aln_root . $key_out . "." . $mask_root . ".mask";
		}
		else { #the final mask
		    $mask_root = "mask";  
		    $pmasked_aln_file = $aln_root . $key_out . "." . $mask_root . ".stk";
		    $pmask_file       = $aln_root . $key_out . ".mask";
		}

		$keep_mask = $opt_H{"--keep"};
		$print_input_aln = 0;
		if(($ssdraw ne "") && ($template_file ne "")) { $do_draw          = 1; }
		else                                          { $do_draw          = 0; }
		$mask_opts = "-k --p-rf --pfract $pf_opt --pthresh $pt_opt";
		mask_alignment($alimanip, \%opt_H, $ssdraw, $aln_root, $aln_root2print, $mask_root, $cmasked_aln_file, $keep_mask, $print_input_aln, 
			       $mask_opts, "", "", $do_draw, $max_width, $mask_ok_if_fails, $template_file, 
			       \$pn0, \$pn1, \$pmasked_aln_file, \$pmask_file, \$ssdraw_worked, \@files_to_unlink_A, $sum_file, $log_file);
		if   ($do_draw && $ssdraw_worked)    { $ssdraw_worked_at_least_once = 1; }
		elsif($do_draw && (!$ssdraw_worked)) { $ssdraw_failed_at_least_once = 1; }
	    }
	    
	    # Gap-based masking, if necessary
	    if($do_gmask) { 
		if($do_pmask) { 
		    $mask_root = "gmask"; 
		    $gmasked_aln_file = $aln_root . $key_out . "." . $mask_root . ".stk";
		    $gmask_file       = $aln_root . $key_out . "." . $mask_root . ".mask";
		    $keep_mask = $opt_H{"--keep"};
		}
		else { #the final mask
		    $mask_root = "mask";  
		    $gmasked_aln_file = $aln_root . $key_out . "." . $mask_root . ".stk";
		    $gmask_file       = $aln_root . $key_out . ".mask";
		    $keep_mask = 1;
		}
		$print_input_aln = 0;
		if(($ssdraw ne "") && ($template_file ne "")) { $do_draw          = 1; }
		else                                          { $do_draw          = 0; }
		$mask_opts = "-k -g --gapthresh " . $opt_H{"--gapthresh"};
		mask_alignment($alimanip, \%opt_H, $ssdraw, $aln_root, $aln_root2print, $mask_root, $cmasked_aln_file, $keep_mask, $print_input_aln, 
			       $mask_opts, "", "", $do_draw, $max_width, $mask_ok_if_fails, $template_file, 
			       \$gn0, \$gn1, \$gmasked_aln_file, \$gmask_file, \$ssdraw_worked, \@files_to_unlink_A, $sum_file, $log_file);
		if   ($do_draw && $ssdraw_worked)    { $ssdraw_worked_at_least_once = 1; }
		elsif($do_draw && (!$ssdraw_worked)) { $ssdraw_failed_at_least_once = 1; }
	    }
	    
	    # If we did both probabilistic and gap-based masking, take the union of the masks
	    if($do_pmask && $do_gmask) { # this is always the final mask
		$mask_root = "mask";
		$pgmasked_aln_file = $aln_root . $key_out . ".mask.stk";
		$pgmask_file       = $aln_root . $key_out . ".mask";
		#create the union of the masks, any column that is excluded (a '0') in either mask is a '0' in the union
		write_union_of_masks($pmask_file, $gmask_file, $pgmask_file);
		$pgmaskdiff_ps     = $aln_root . $key_out . ".maskdiff.ps";
		$pgmaskdiff_pdf    = $aln_root . $key_out . ".maskdiff.pdf";
		$pgmaskdiff_ps2print     = $aln_root2print . $key_out . ".maskdiff.ps";
		$pgmaskdiff_pdf2print    = $aln_root2print . $key_out . ".maskdiff.pdf";
		
		$keep_mask = 1;
		$print_input_aln = 0;
		if(($ssdraw ne "") && ($template_file ne "")) { $do_draw          = 1; }
		else                                          { $do_draw          = 0; }
		$mask_opts = "-k";
		$rfmask2use = $pgmask_file;
		mask_alignment($alimanip, \%opt_H, $ssdraw, $aln_root, $aln_root2print, $mask_root, $cmasked_aln_file, $keep_mask, $print_input_aln, 
			       $mask_opts, $pgmask_file, "", $do_draw, $max_width, $mask_ok_if_fails, $template_file, 
			       \$pgn0, \$pgn1, \$pgmasked_aln_file, \$pgmask_file, \$ssdraw_worked, \@files_to_unlink_A, $sum_file, $log_file);
		if   ($do_draw && $ssdraw_worked)    { $ssdraw_worked_at_least_once = 1; }
		elsif($do_draw && (!$ssdraw_worked)) { $ssdraw_failed_at_least_once = 1; }

		if(($ssdraw ne "") && ($template_file ne "")) 
		{ 
		    # draw the difference between the pmask and the gmask
		    my $do_column_breakdown = 0;
		    $ssdraw_worked = run_ssdraw($ssdraw, $template_file, "--mask-diff $pmask_file --mask $gmask_file", $cmasked_aln_file, $aln_root, $aln_root2print, 
						$key_out, ".maskdiff", $max_width, \%opt_H, $pgn0, $pgn1, $do_column_breakdown, \@files_to_unlink_A, $sum_file, $log_file);
		    if   ($ssdraw_worked)  { $ssdraw_worked_at_least_once = 1; }
		    elsif(!$ssdraw_worked) { $ssdraw_failed_at_least_once = 1; }
		}
	    }
	}
	if($i < ($naln-1)) { 
	    print_string_to_file($sum_file, 1, sprintf("\n"));
	}
    }
}    


############################
# Filter mode: Do the work #
############################

my $filtered_aln_file;
if($do_filter_mode) { 
    my $max_width_fil = length("file name");
    my ($filter_root);
    $filter_root = "fil";
    for($i = 0; $i < $naln; $i++) { 
	$aln_file         = $stk_list_A[$i];
	($aln_root)       = ($aln_file =~ /.+\/(.+)\.stk/);
	$nec_width = length($aln_root) + length($key_out) + length(".") + length($filter_root) + length(".stk");
	if($max_width_fil < $nec_width) { $max_width_fil = $nec_width; }
    }
    my $dashes_fil = ""; for($i = 0; $i < $max_width_fil; $i++) { $dashes_fil .= "-"; }
    my $wide_dashes_fil = $dashes_fil . "----------";
    my $max_width_in = $max_width_fil - length($key_out) - 4; #max_width_in is max length of a filtered file, minus 4 for diff between .fil.stk and .stk
    if($max_width_in < length("file name")) { $max_width_in = length("file name"); }
    my $dashes_in = ""; for($i = 0; $i < $max_width_in; $i++) { $dashes_in .= "-"; }
    my $wide_dashes_in = $dashes_in . "----------";

    print_string_to_file($sum_file, 1, sprintf("#\n# Filtering alignments so that no 2 seqs are more than " . $opt_H{"--filter"} . " identical.\n"));
    print_string_to_file($sum_file, 1, sprintf("#\n"));
    print_string_to_file($sum_file, 1, sprintf("# %-*s  %-*s\n", $max_width_in+10, "input alignment", $max_width_fil+10, "filtered alignment"));
    print_string_to_file($sum_file, 1, sprintf("# %-*s  %-*s\n", $max_width_in+10, $wide_dashes_in, $max_width_fil+10, $wide_dashes_fil));
    print_string_to_file($sum_file, 1, sprintf("# %-*s  %8s  %-*s  %8s\n", $max_width_in, "file name", "num seqs", $max_width_fil, "file name", "num seqs"));
    print_string_to_file($sum_file, 1, sprintf("# %-*s  %8s  %-*s  %8s\n", $max_width_in, $dashes_in, "--------", $max_width_fil, $dashes_fil, "--------"));

    for($i = 0; $i < $naln; $i++) { 
	$filter_root = "fil";
	$aln_file         = $stk_list_A[$i];
	($aln_root)       = ($aln_file =~ /(.+)\.stk/);
	if($opt_H{"-a"}) { #print directory as well as aln name
	    ($aln_root2print) = ($aln_file =~ /(.+)\.stk/);
	}
	else {
	    ($aln_root2print) = ($aln_file =~ /.+\/(.+)\.stk/);
	}
	filter_alignment($weight, $seqstat, \%opt_H, $aln_root, $aln_root2print, $filter_root, $aln_file, $aln_root2print . ".stk",
			 $max_width_in, $max_width_fil, \$filtered_aln_file, $sum_file, $log_file);
    }
}    


##########################
# List mode: Do the work #
##########################

if($do_list_mode) 
{ 
    # determine max file name width
    my $max_width_list = length("list file name");
    for($i = 0; $i < $naln; $i++) { 
	$aln_file         = $stk_list_A[$i];
	($aln_root)       = ($aln_file =~ /(.+)\.stk/);
	if($opt_H{"-a"}) { #print directory as well as aln name
	    ($aln_root2print) = ($aln_file =~ /(.+)\.stk/);
	}
	else {
	    ($aln_root2print) = ($aln_file =~ /.+\/(.+)\.stk/);
	}
	$nec_width = length($aln_root2print) + length($key_out) + 5; #5 is for ".list"
	if($max_width_list < $nec_width) { $max_width_list = $nec_width; }
    }					     
    my $dashes_list = ""; for($i = 0; $i < $max_width_list; $i++) { $dashes_list.= "-"; }
    my $max_width_aln = $max_width_list - length($key_out) - 1; #max_width_aln is max length of a list file, minus 1 for diff between .list and .stk
    if($max_width_aln < length("aln file name")) { $max_width_aln = length("aln file name"); } 
    my $dashes_aln = ""; for($i = 0; $i < $max_width_aln; $i++) { $dashes_aln .= "-"; }

    print_string_to_file($sum_file, 1, sprintf("#\n# Listing sequences in alignments.\n"));
    print_string_to_file($sum_file, 1, sprintf("#\n"));
    print_string_to_file($sum_file, 1, sprintf("# %-*s  %-*s  %8s\n", $max_width_aln, "aln file name", $max_width_list, "list file name", "num seqs"));
    print_string_to_file($sum_file, 1, sprintf("# %-*s  %-*s  %8s\n", $max_width_aln, $dashes_aln, $max_width_list, $dashes_list, "--------"));

    my ($list_file, $list_file2print, $aln_file2print, $nseq, $command_worked);
    for($i = 0; $i < $naln; $i++) { 
	$aln_file         = $stk_list_A[$i];
	($aln_file2print) = ($aln_file =~ /.+\/(.+)/);
	($aln_root)       = ($aln_file =~ /(.+)\.stk/);
	if($opt_H{"-a"}) { #print directory as well as aln name
	    ($aln_root2print) = ($aln_file =~ /(.+)\.stk/);
	}
	else {
	    ($aln_root2print) = ($aln_file =~ /.+\/(.+)\.stk/);
	}
	$list_file        = $aln_root . $key_out . ".list";
	$list_file2print  = $aln_root2print . $key_out . ".list";

	if($opt_H{"-a"}) { $list_file2print = $list_file; } #print full path with -a is invoked
	$command = "$alimanip --list $list_file $aln_file"; 
	run_executable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");

	my $nseq = get_num_lines_in_file($list_file);
	
	print_string_to_file($sum_file, 1, sprintf("  %-*s  %-*s  %8d\n", $max_width_aln, $aln_file2print, $max_width_list, $list_file2print, $nseq));
    }
}


######################################
# Sequence removal mode: Do the work #
######################################

if($do_remove_seqs_mode) 
{ 
    # determine max file name width
    my $max_width = length("subset aln file name");
    $aln_file         = $stk_list_A[0];
    ($aln_root)       = ($aln_file =~ /(.+)\.stk/);
    $nec_width = length($aln_root) + length($key_out) + 9; #9 is for ".seq{r,k}.stk"
    if($max_width < $nec_width) { $max_width = $nec_width; }
    my $dashes = ""; for($i = 0; $i < $max_width; $i++) { $dashes.= "-"; }
    my $command_worked;

    print_string_to_file($sum_file, 1, sprintf("#\n# Removing some sequences from an alignment.\n"));
    print_string_to_file($sum_file, 1, sprintf("#\n"));
    print_string_to_file($sum_file, 1, sprintf("# %-*s  %8s\n", $max_width, "subset aln file name", "num seqs"));
    print_string_to_file($sum_file, 1, sprintf("# %-*s  %8s\n", $max_width, $dashes, "--------"));
    
    if($naln != 1) { 
	printf STDERR ("\nERROR, --seq-r and --seq-k require the -a option.\n"); exit(1); 
    }
    if($opt_H{"--seq-r"} ne "") { 
	my $seqr_aln = $aln_root . $key_out . ".seqr.stk";
	if(!(-e $opt_H{"--seq-r"})) { 
	    printf STDERR ("\nERROR, the --seq-r file " . $opt_H{"--seq-r"} . " does not exist.\n"); exit(1); 
	}
	$command = "$alimanip -o $seqr_aln --seq-r " . $opt_H{"--seq-r"} . " $aln_file";
	run_executable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");
	
	#determine number of sequences in the alignment
	my $nseq = 0;
	seqstat_seqfile($seqstat, $seqr_aln, \$nseq, $log_file);
	print_string_to_file($sum_file, 1, sprintf("  %-*s  %8d\n", $max_width, $seqr_aln, $nseq));
    }
    elsif($opt_H{"--seq-k"} ne "") { 
	my $seqk_aln = $aln_root . $key_out . ".seqk.stk";
	if(!(-e $opt_H{"--seq-k"})) { 
	    printf STDERR ("\nERROR, the --seq-k file " . $opt_H{"--seq-k"} . " does not exist.\n"); exit(1); 
	}
	$command = "$alimanip -o $seqk_aln --seq-k " . $opt_H{"--seq-k"} . " $aln_file";
	run_executable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");

	#determine number of sequences in alignment (just number of sequences in the --seq-klist file) 
	my $nseq = get_num_lines_in_file($opt_H{"--seq-k"});
	print_string_to_file($sum_file, 1, sprintf("  %-*s  %8d\n", $max_width, $seqk_aln, $nseq));
    }
}


#############################
# stk2afa mode: Do the work #
#############################

if($do_stk2afa_mode) 
{ 
    # determine max file name width
    my $max_width_afa = length("aligned FASTA file name");
    for($i = 0; $i < $naln; $i++) { 
	$aln_file         = $stk_list_A[$i];
	($aln_root)       = ($aln_file =~ /(.+)\.stk/);
	if($opt_H{"-a"}) { #print directory as well as aln name
	    ($aln_root2print) = ($aln_file =~ /(.+)\.stk/);
	}
	else {
	    ($aln_root2print) = ($aln_file =~ /.+\/(.+)\.stk/);
	}
	$nec_width = length($aln_root2print) + length($key_out) + 4; #4 is for ".afa"
	if($max_width_afa < $nec_width) { $max_width_afa = $nec_width; }
    }					     
    my $dashes_afa = ""; for($i = 0; $i < $max_width_afa; $i++) { $dashes_afa.= "-"; }
    my $max_width_aln = $max_width_afa - length($key_out); #max_width_aln is max length of a afa file ('.afa' is same # chars as '.stk')
    if($max_width_aln < length("Stockholm aln file name")) { $max_width_aln = length("aln file name"); } 
    my $dashes_aln = ""; for($i = 0; $i < $max_width_aln; $i++) { $dashes_aln .= "-"; }

    print_string_to_file($sum_file, 1, sprintf("#\n# Converting alignments to aligned FASTA...\n"));
    print_string_to_file($sum_file, 1, sprintf("#\n"));
    print_string_to_file($sum_file, 1, sprintf("# %-*s  %-*s\n", $max_width_aln, "Stockholm aln file name", $max_width_afa, "aligned FASTA file name"));
    print_string_to_file($sum_file, 1, sprintf("# %-*s  %-*s\n", $max_width_aln, $dashes_aln, $max_width_afa, $dashes_afa));

    my ($afa_file, $afa_file2print, $aln_file2print, $nseq, $command_worked);
    for($i = 0; $i < $naln; $i++) { 
	$aln_file         = $stk_list_A[$i];
	($aln_file2print) = ($aln_file =~ /.+\/(.+)/);
	($aln_root)       = ($aln_file =~ /(.+)\.stk/);
	if($opt_H{"-a"}) { #print directory as well as aln name
	    ($aln_root2print) = ($aln_file =~ /(.+)\.stk/);
	}
	else {
	    ($aln_root2print) = ($aln_file =~ /.+\/(.+)\.stk/);
	}
	$afa_file        = $aln_root . $key_out . ".afa";
	$afa_file2print  = $aln_root2print . $key_out . ".afa";

	if($opt_H{"-a"}) { $afa_file2print = $afa_file; } #print full path with -a is invoked
	$command = "$reformat -o $afa_file --informat stockholm afa $aln_file"; 
	run_executable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");

	print_string_to_file($sum_file, 1, sprintf("  %-*s  %-*s\n", $max_width_aln, $aln_file2print, $max_width_afa, $afa_file2print));
    }
}

##########################
# Print the summary file #
##########################


if(!($opt_H{"-a"})) { 
    if($do_filter_mode) {
	my $fil_key2print = $key_out . "." . "fil";
	$fil_key2print =~ s/\.//;
	print_string_to_file($sum_file, 1, sprintf("#\n# To mask these alignments run ssu-mask with the option \"--key-in $fil_key2print\"\n"));
    }
}
else { 
    $log_file       = $dir . $key_out . ".ssu-mask.log";
    $log_file2print = $log_file;
    if($do_filter_mode) {
	print_string_to_file($sum_file, 1, sprintf("#\n"));
	my $fil_key2print = "fil." . $key_out;
	print_string_to_file($sum_file, 1, sprintf("# To mask this alignment with another ssu-mask run, use the options\n\t\"-a $filtered_aln_file\"\n"));
    }
}
if($do_mask_mode) { 
    print_string_to_file($sum_file, 1, sprintf("#\n"));
    if    ($ssdraw_worked_at_least_once && (! $ssdraw_failed_at_least_once)) { 
	print_string_to_file($sum_file, 1, sprintf("# All attempts to draw structure diagrams of masks were successful.\n"));
    }
    elsif($ssdraw_worked_at_least_once && $ssdraw_failed_at_least_once) { 
	print_string_to_file($sum_file, 1, sprintf("# Some, but not all, attempts to draw structure diagrams of masks were successful.\n"));
    }
    elsif((! $ssdraw_worked_at_least_once) && (! $ssdraw_failed_at_least_once)) { 
	print_string_to_file($sum_file, 1, sprintf("# No structure diagrams were attempted. Unable to locate default template file.\n"));
    }
    elsif((! $ssdraw_worked_at_least_once) && $ssdraw_failed_at_least_once) { 
	if($opt_H{"-m"} eq "") { 
	    print_string_to_file($sum_file, 1, sprintf("# All attempts to draw structure diagrams failed.\n# This shouldn't happen, but masking was unaffected.\n"));
	}
	else {
	    print_string_to_file($sum_file, 1, sprintf("# All attempts to draw structure diagrams failed.\n# " . $opt_H{"-m"} . " must contain non-default, user-created model(s).\n"));
	}
    }
}

# remove temporary files, if any
my $file;
foreach $file (@files_to_unlink_A) { 
    unlink_file($file, $log_file);
}

$total_time += time();
print_string_to_file($sum_file, 1, sprintf("#\n"));
print_string_to_file($sum_file, 1, sprintf("# Commands executed by this script written to log file: $log_file2print.\n"));
print_string_to_file($sum_file, 1, sprintf("# This output saved to summary file: $sum_file2print.\n"));
print_string_to_file($sum_file, 1, sprintf("#\n"));
print_string_to_file($sum_file, 1, sprintf("# All files saved in directory: \.\/$dir\/\n"));

print_string_to_file($sum_file, 1, sprintf("# \n"));
print_timing("# CPU time: ", $total_time, $sum_file); 
print_string_to_file($sum_file, 1, sprintf("# \n"));


# Success!
exit(0);


###############
# Subroutines #
###############


#####################################################################
# Subroutine: print_banner()
# Incept:     EPN, Thu Sep 24 14:40:39 2009
# 
# Purpose:    Print the ssu-mask banner.
#
# Arguments: 
#    $script_call:      call used to invoke this (ssu-draw) script
#    $opt_HR:           REFERENCE to hash of command-line options
#    $opt_takes_arg_HR: REFERENCE to hash telling if each option takes an argument (1) or not (0)
#    $opt_order_AR:     REFERENCE to array specifying order of options
#    $argv_R:           REFERENCE to @ARGV, command-line arguments
#    $print_to_stdout:  '1' to print to stdout, '0' not to
#    $out_file:         file to print to
#
# Returns:    Nothing, if it returns, everything is valid.
# 
####################################################################
sub print_banner { 
    my $narg_expected = 7;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, print_banner() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($script_call, $opt_HR, $opt_takes_arg_HR, $opt_order_AR, $argv_R, $print_to_stdout, $out_file) = @_;

    my ($i, $script_name, $start_log_line);
    $script_call =~ s/^\.+\///;
    $script_name = $script_call;
    $script_name =~ s/.+\///;
    my $enabled_options = "";
    foreach $opt (@{$opt_order_AR}) { 
	if($opt_takes_arg_HR->{$opt}) { if($opt_HR->{$opt} ne "") { $enabled_options .= " " . $opt . " " . $opt_HR->{$opt}; } }
	else                  	      { if($opt_HR->{$opt})       { $enabled_options .= " " . $opt; } }
    }

    $script_call =~ s/^\.+\///;
    $script_name = $script_call;
    $script_name =~ s/.+\///;

    print_string_to_file($out_file, $print_to_stdout, sprintf("\# $script_name :: mask SSU rRNA alignments\n"));
    print_string_to_file($out_file, $print_to_stdout, sprintf("\# SSU-ALIGN 0.1 (October 2009)\n"));
    print_string_to_file($out_file, $print_to_stdout, sprintf("\# Copyright (C) 2009 HHMI Janelia Farm Research Campus\n"));
    print_string_to_file($out_file, $print_to_stdout, sprintf("\# Freely distributed under the GNU General Public License (GPLv3)\n"));
    print_string_to_file($out_file, $print_to_stdout, sprintf("\# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n"));
    print_string_to_file($out_file, $print_to_stdout, sprintf("%-10s %s ", "# command:", $script_call . $enabled_options));
    for($i = 0; $i < (scalar(@{$argv_R}) - 1); $i++) { 
	print_string_to_file($out_file, $print_to_stdout, sprintf("%s ", $argv_R->[$i]));
    }
    if(scalar(@{$argv_R}) > 0) { 
	print_string_to_file($out_file, $print_to_stdout, sprintf("%s\n", $argv_R->[(scalar(@{$argv_R})-1)])); 
    }
    else { 
	print_string_to_file($out_file, $print_to_stdout, sprintf("\n"));
    }
    print_string_to_file($out_file, $print_to_stdout, sprintf("%-10s ", "# date:"));
    print_string_to_file($out_file, $print_to_stdout, sprintf(scalar localtime()));
    print_string_to_file($out_file, $print_to_stdout, sprintf("\n"));

    return;
}

#####################################################################
# Subroutine: validate_and_setup()
# Incept:     EPN, Mon Nov  3 15:05:56 2008
# 
# Purpose:    Validate that: 
#             - the CM file exists. 
#             - the required executable programs exist.
#             - there is at least 1 alignment in $dir directory
#               to operate on
#
# Arguments: 
# $dir:               the directory we will create files in
# $key_in:            "" or a key that is included in input file names, just prior to the suffix
#                     e.g. $key_in = "fookey", $dir = "foodir", aln file is foodir/foodir.archaea.fookey.stk
# $opt_HR:            reference to the hash of command-line options
# $cm_file_ref:       RETURN; the path to the CM file, either default CM file or $opt_HR->{"-m"}
# $template_file_ref: RETURN; the path to the template file, either default template file or $opt_HR->{"-t"}
# $alimanip_ref:      RETURN; the esl-alimanip command
# $ssdraw_ref:        RETURN; the esl-ssdraw command
# $weight_ref:        RETURN; the esl-weight command, only relevant if --filter enabled
# $seqstat_ref:       RETURN; the esl-seqstat command, only relevant if --filter enabled
# $reformat_ref:      RETURN; the esl-reformat command, only relevant if --afa, --only-afa, or --stk2afa enabled
# $stk_list_arr_ref:  RETURN: ref to array of alignment files to operate on
# $log_file:          the log file
#
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If any of the above validations do not occur, we
#             print a message to STDERR explaining why it's
#             exiting early and then exit with non-zero status.
#
####################################################################
sub validate_and_setup { 
    my $narg_expected = 12;
    if(scalar(@_) != $narg_expected) { printf STDERR ("\nERROR, validate_and_setup() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($dir, $key_in, $opt_HR, $cm_file_ref, $template_file_ref, $alimanip_ref, $ssdraw_ref, $weight_ref, $seqstat_ref, $reformat_ref, $stk_list_arr_ref) = @_;

    #Validate that we can read the CM file
    my $ssualigndir;
    my $cm_file = "";
    if($opt_HR->{"-m"} ne "") {
	$cm_file = $opt_HR->{"-m"};
	if(!(-e $cm_file)) { printf STDERR ("\nERROR, CM file $cm_file, specified with -m does not exist.\n"); exit(1); }
    }
    else { # -m not enabled, assume the user used the default CM file:
	$ssualigndir = $ENV{'SSUALIGNDIR'};
	if(! exists($ENV{'SSUALIGNDIR'})) { 
	    printf STDERR ("\nERROR, the SSUALIGNDIR environment variable should be set but it's not.\nFor help, see the User's Guide Installation section.\n"); exit(1);
	    exit(1); 
	}
	$cm_file = $ssualigndir . "/ssu-align-0p1.cm";
	if(!(-e $cm_file)) { printf STDERR ("\nERROR, the default CM file $cm_file does not exist.\nIf you used a different CM file to create the alignments in $dir, use the -m option.\n"); exit(1); }
    }

    #if --in-mask <s> enabled, verify that <s> exists
    if($opt_HR->{"--in-mask"} ne "") { 
	if(!(-e $opt_HR->{"--in-mask"})) { printf STDERR ("\nERROR, mask file " . $opt_HR->{"--in-mask"} . ", specified with --in-mask does not exist.\n"); exit(1); }
    }	

    #Validate that we can read the template postscript diagram file, if we can't that's okay but only if a non-default CM has been specified with -m.
    if($opt_HR->{"-t"} ne "") { 
	$template_file = $opt_HR->{"-t"};
	if(!(-e $template_file)) { printf STDERR ("\nERROR, template postscript file $template_file, specified with -t does not exist.\n"); exit(1); }
    }
    elsif($opt_HR->{"-m"} eq "") { # -t not enabled and -m not enabled, we assume default template file should exist for the default CM file
	$ssualigndir = $ENV{'SSUALIGNDIR'};
	if(! exists($ENV{'SSUALIGNDIR'})) { 
	    printf STDERR ("\nERROR, the SSUALIGNDIR environment variable should be set but it's not.\nFor help, see the User's Guide Installation section.\n"); exit(1);
	    exit(1); 
	}
	$template_file = $ssualigndir . "/ssu-align-0p1.ps";
	if(!(-e $template_file)) { printf STDERR ("\nERROR, the default template file $template_file does not exist and you did not specify a non-default CM file with -m.\nIf you used a non-default CM file, use -m.\nIf you want to use a non-default structure template file use -t.\n"); exit(1); }
    }
    else { #-m enabled, -t not enabled: with this combo if the default template file exists we'll try to do ssu-align with it,
	   # if not, then we can still do masking but we won't try to call ssu-draw
	#check if default template exists:
	$template_file = "";
	$ssualigndir = $ENV{'SSUALIGNDIR'};
	if(exists($ENV{'SSUALIGNDIR'})) { 
	    if(-e ($ssualigndir . "/ssu-align-0p1.ps")) { 
		$template_file = $ssualigndir . "/ssu-align-0p1.ps";
	    }
	}
    }
    #Validate that esl-alimanip and esl-ssdraw (if we need it) exist
    my $alimanip = "ssu-esl-alimanip";
    my $command_worked;
    run_executable("$alimanip -h > /dev/null", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $alimanip is not in your PATH environment\nvariable. See the User's Guide Installation section.");;

    my $ssdraw = "";
    if($template_file ne "") { 
	$ssdraw = "ssu-esl-ssdraw";
	run_executable("$ssdraw -h > /dev/null", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $ssdraw is not in your PATH environment\nvariable. See the User's Guide Installation section.");;
    }

    #Validate that 'esl-weight' and 'esl-seqstat' exist if --filter enabled.
    my $weight = "";
    my $seqstat = "";
    if($opt_HR->{"--filter"} ne "") { 
	$weight = "ssu-esl-weight";
	run_executable("$weight -h > /dev/null", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $weight (required b/c --filter enabled) is not in your PATH environment\nvariable. See the User's Guide Installation section.");;
	$seqstat = "ssu-esl-seqstat";
	run_executable("$seqstat -h > /dev/null", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $seqstat (required b/c --filter enabled) is not in your PATH environment\nvariable. See the User's Guide Installation section.");;
    }

    #Validate that 'esl-seqstat' works if --seq-r or --seq-k
    if(($opt_H{"--seq-r"} ne "") || ($opt_H{"--seq-k"})) { 
	$seqstat = "ssu-esl-seqstat";
	run_executable("$seqstat -h > /dev/null", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $seqstat (required b/c --seq-r or --seq-k enabled) is not in your PATH environment\nvariable. See the User's Guide Installation section.");;
    }	


    #Validate that 'esl-reformat' works if --afa, --only-afa, or --stk2afa
    my $reformat = "";
    if(($opt_H{"--afa"}) || ($opt_H{"--only-afa"}) || ($opt_H{"--stk2afa"})) { 
	$reformat = "ssu-esl-reformat";
	run_executable("$reformat -h > /dev/null", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $reformat (required b/c --afa, --only-afa or --stk2afa enabled) is not in your PATH environment\nvariable. See the User's Guide Installation section.");;
    }	

    my $naln = 0;
    my ($aln_name);
    if($opt_HR->{"-a"}) { # special mode, single command line argument is not a directory, it's an alignment
	$aln_name = $dir;
	if(! (-e $aln_name)) { 
	    printf STDERR ("\nERROR, the alignment file $aln_name does not exist.\n"); exit(1); 
	}
	my $aln_root = $aln_name;
	if($aln_root !~ s/\.stk$//) { 
	    printf STDERR ("\nERROR, the alignment file must end with \".stk\", $aln_name does not.\n"); exit(1); 
	}
	push(@{$stk_list_arr_ref}, $aln_name);
	$naln = 1; 
    }
    else { 
	# Validate there is at least 1 alignment in the input dir
	if(! (-d $dir)) { 
	    if(-e $dir) { 
		printf STDERR ("\nERROR, the command-line argument $dir is a file, not a directory.\nIt should be the directory that includes the input alignment files,\nor if you want to operate on a single alignment, use the -a option.\n"); exit(1); 
	    }
	    else { 
		printf STDERR ("\nERROR, the directory $dir with input alignment files does not exist.\n"); exit(1); 
	    }
	}
	my ($name, $line);
	my @names_A = ();
	open(CM, $cm_file) || die "\nERROR, could not open CM file $cm_file for reading.\n";
	while($line = <CM>) { 
	    if($line =~ s/NAME\s+//) { 
		chomp $line;
		push(@names_A, $line);
	    }
	}
	close(CM);
	foreach $name (@names_A) { 
	    $aln_name = $dir . "/" . $dir . "." . $name . $key_in . ".stk";
	    if(-e $aln_name) { 
		push(@{$stk_list_arr_ref}, $aln_name);
		$naln++; 
	    }
	}
	if($naln == 0) { 
	    printf STDERR ("\nERROR, found 0 alignments created by ssu-align using the CM file $cm_file\nin directory $dir.\n\n");
	    printf STDERR ("The following alignments were searched for, but none were found:\n");
	    foreach $name (@names_A) { 
		$aln_name = $dir . "/" . $dir . "." . $name . $key_in . ".stk";
		printf STDERR ("\t$aln_name\n");
	    }
	    exit(1);
	}
    }

    $$cm_file_ref       = $cm_file;
    $$template_file_ref = $template_file;
    $$alimanip_ref      = $alimanip;
    $$ssdraw_ref        = $ssdraw;
    $$weight_ref        = $weight;
    $$seqstat_ref       = $seqstat;
    $$reformat_ref      = $reformat;
    
    return;
}

#####################################################################
# Subroutine: write_union_of_masks()
# Incept:     EPN, Thu Sep 24 14:11:40 2009
# 
# Purpose:    Given two mask files of equal length, write a new 
#             mask file that is the 'union' of them both, defined
#             as, any column that is excluded from either mask
#             (a '0') is excluded from the union mask.
#
# Arguments: 
#   $mask1_file:      file name with mask 1.
#   $mask1_file:      file name with mask 2.
#   $union_mask_file: file name for outputting union to.
#
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If anything unexpected occurs, print a message to 
#             STDERR explaining why we're exiting early and then 
#             exit with non-zero status.
#
####################################################################
sub write_union_of_masks {
    my $narg_expected = 3;
    if(scalar(@_) != $narg_expected) { printf STDERR ("\nERROR, write_union_of_masks() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($mask1_file, $mask2_file, $union_mask_file) = @_;

    if(!(open(MASK1, $mask1_file))) { printf STDERR ("ERROR, could not open mask file $mask1_file, when trying to create its union with $mask2_file.\n"); exit(1); }
    my $mask1 = <MASK1>;
    chomp $mask1;
    my @mask1_A = split("", $mask1);
    close(MASK1);

    if(!(open(MASK2, $mask2_file))) { printf STDERR ("ERROR, could not open mask file $mask2_file, when trying to create its union with $mask1_file.\n"); exit(1); } 
    my $mask2 = <MASK2>;
    chomp $mask2;
    my @mask2_A = split("", $mask2);
    close(MASK2);

    my $mask1_len = scalar(@mask1_A); 
    my $mask2_len = scalar(@mask2_A); 
    if($mask1_len != $mask2_len) { printf STDERR ("ERROR when trying to create the union of $mask1_file and $mask2_file, their lengths differ: $mask1_len != $mask2_len.\n"); exit(1); }

    my ($i, $combo);
    my $umask = "";
    for($i = 0; $i < $mask1_len; $i++) 
    { 
	$combo = $mask1_A[$i] . $mask2_A[$i];
	if   ($combo eq "11") { $umask .= "1"; }
	elsif($combo eq "10") { $umask .= "0"; }
	elsif($combo eq "01") { $umask .= "0"; }
	elsif($combo eq "00") { $umask .= "0"; }
	else { printf STDERR ("ERROR, a non-1/0 character found in $mask1_file or $mask2_file at position %d\n", ($i+1)); exit(1); }
    }
    
    if(!(open(OUT, ">" . $union_mask_file))) { printf STDERR ("\nERROR, write_union_of_masks() could not open file $union_mask_file for writing.\n"); exit(1); } 
    printf OUT ($umask . "\n");
    close(OUT);

    return;
}

#####################################################################
# Subroutine: summarize_mask()
# Incept:     EPN, Thu Sep 24 15:42:44 2009
# 
# Purpose:    Given a mask file, return the number of 0s and 1s
#             in the file.
#
# Arguments: 
#   $mask_file: file name with mask in it.
#   $n0_ref:    RETURN: number of 0s in mask file
#   $n1_ref:    RETURN: number of 1s in mask file
# 
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If anything unexpected occurs, print a message to 
#             STDERR explaining why we're exiting early and then 
#             exit with non-zero status.
#
####################################################################
sub summarize_mask {
    my $narg_expected = 3;
    if(scalar(@_) != $narg_expected) { printf STDERR ("\nERROR, summarize_mask() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($mask_file, $n0_ref, $n1_ref) = @_;

    if(!(open(MASK, $mask_file))) { printf STDERR ("ERROR, could not open mask file $mask_file when trying to summarize it.\n"); exit(1); }
    my $mask = <MASK>;
    chomp $mask;
    my $n1 = length($mask);
    my $n0 = ($mask =~ tr/0//);
    $n1 -= $n0;
    # make sure there aren't extra characters
    $mask =~ s/0//g;
    $mask =~ s/1//g;
    if($mask ne "") { printf("ERROR, mask in file $mask_file has non-1/0 chars. \n"); exit(1); }

    $$n1_ref = $n1;
    $$n0_ref = $n0;
    return;
}


#####################################################################
# subroutine: mask_alignment()
# incept:     EPN, Fri Sep 25 13:30:51 2009
# 
# Purpose:    Mask an alignment using the easel miniapp esl-alimanip.
#
# Arguments:  
#   $alimanip:          path and name of esl-alimanip/ssu-esl-alimanip executable
#   $opt_HR:            reference to the hash of command-line options
#   $ssdraw:            path and name of esl-ssdraw/ssu-esl-ssdraw executable
#   $aln_root:          root with dir for alignment and output file names, this is normally 
#                       the <output root> supplied with original ssu-align call
#   $aln_root2print:    $aln_root without preceding dir/path
#   $mask_root:         name for mask-related files, e.g. 'cmask'
#   $aln_file2mask:     name of alignment file to mask, with path
#   $keep_mask:         '1' to keep 'mask' file output from esl-alimanip
#   $print_input_aln:   '1' to print info on input alignment to the screen
#   $mask_opts:         string of options to pass to esl-alimanip
#   $rfmask_file2use:   name of file to use as argument with --mask-rf to esl-alimanip
#   $allmask_file2use:  name of file to use as argument with --mask-all to esl-alimanip
#   $do_draw:           '1' to draw masks with esl-ssdraw
#   $max_width:         width of output string for printing output file names
#   $mask_ok_if_fails:  '1' if we keep going upon a esl-alimanip failure, '0' to exit
#                       if esl-alimanip fails with non-0 return code.
#   $template_file:     path to template file needed by esl-ssdraw
#   $n0_R:              RETURN; number of 0s in computed mask
#   $n1_R:              RETURN; number of 1s in computed mask
#   $masked_aln_file_R: RETURN; name of masked alignment file just created
#   $mask_file_R:       RETURN; name of mask file just created
#   $ssdraw_worked_R:   RETURN; '1' if esl-ssdraw successfully run, else '0'
#   $files_to_unlink_AR:REFERENCE to array of files to unlink
#   $sum_file:          file to print output file notices to
#   $log_file:          log file
# 
# Returns:  Nothing, if it returns, everything is valid.
# 
####################################################################
sub mask_alignment { 
    my $narg_expected = 24;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, mask_alignment() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($alimanip, $opt_HR, $ssdraw, $aln_root, $aln_root2print, $mask_root, $aln_file2mask, $keep_mask, $print_input_aln, 
	$mask_opts, $rfmask_file2use, $allmask_file2use, $do_draw, $max_width, $mask_ok_if_fails, $template_file, 
	$n0_R, $n1_R, $masked_aln_file_R, $mask_file_R, $ssdraw_worked_R, $files_to_unlink_AR, $sum_file, $log_file) = @_;

    if(($rfmask_file2use ne "") && ($allmask_file2use ne "")) { 
	printf STDERR ("\nERROR, mask_alignment() entered with both \$rfmask_file2use ($rfmask_file2use) and \$allmask_file2use $allmask_file2use defined.\nThese are incompatible: one must be the empty string.\n"); exit(1); 
    } 	

    my($masked_aln_file, $mask_file);
    my($masked_aln_file2print, $mask_file2print);
    my($masked_afa_file, $masked_afa_file2print);

    my($n0, $n1, $is_final, $extra_opts, $ssdraw_failed, $command_worked);
    if($mask_root eq "mask") { $is_final = 1; }
    else                     { $is_final = 0; }

    $masked_aln_file = $aln_root . $key_out . "." . $mask_root . ".stk";
    if($mask_root ne "mask") { $mask_file = $aln_root . $key_out . "." . $mask_root . ".mask"; }
    else                     { $mask_file = $aln_root . $key_out . ".mask"; }
    $masked_aln_file2print = $aln_root2print . $key_out . "." . $mask_root . ".stk";
    if($mask_root ne "mask") { $mask_file2print = $aln_root2print . $key_out . "." . $mask_root . ".mask"; }
    else                     { $mask_file2print = $aln_root2print . $key_out . ".mask"; }

    # cmask: $command = "$alimanip -k --num-rf --kmask $cmask_file -o $cmasked_aln_file $aln_file2mask 2>&1";
    # pmask: $command = "$alimanip --p-rf --pf $opt_HR->{"--pf"} --pt $opt_HR->{"--pt"} -k --kmask $pmask_file -o $pmasked_aln_file $cmasked_aln_file 2>&1";
    # gmask: $command = "$alimanip --verbose -g --gapthresh $opt_HR->{"--gapthresh"} -k --kmask $gmask_file -o $gmasked_aln_file $cmasked_aln_file 2>&1";
    # pgmask:$command = "$alimanip -k --mask-rf $pgmask_file -o $pgmasked_aln_file $cmasked_aln_file 2>&1";
    if   ($rfmask_file2use ne "")  { $extra_opts = "--mask-rf $rfmask_file2use";  $mask_file = $rfmask_file2use; }
    elsif($allmask_file2use ne "") { $extra_opts = "--mask-all $allmask_file2use"; $mask_file = $allmask_file2use; }
    else                           { $extra_opts = "--kmask $mask_file"; }
    if($opt_HR->{"-1"})                      { $extra_opts .= " -1"; }
    $command = "$alimanip $mask_opts $extra_opts -o $masked_aln_file $aln_file2mask 2>&1";
    my $errmsg = "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.";
    my $die_if_fails = 1;
    if($mask_ok_if_fails) { 
	$errmsg = "";
	$die_if_fails = 0;
    }
    run_executable("$command", $die_if_fails, $die_if_fails, $log_file, \$command_worked, $errmsg);
    if(! $command_worked) { return 0; } #if (! $mask_ok_if_fails), run_executable will cause death if (! $command_worked)

    summarize_mask($mask_file, \$n0, \$n1); 

    if($print_input_aln) { 
	print_string_to_file($sum_file, 1, sprintf("  %-*s  %6s  %4s  %5s  %5s  %5s\n", $max_width, $aln_root2print . ".stk", "input", "aln", ($n0+$n1), "-", "-"));
    }

    my $ssdraw_worked = 0;
    if($do_draw) { 
	# Draw the mask, if we can, if we can't that's okay just alert the caller by setting $ssdraw_worked = 0
	my $do_column_breakdown = 1;
	$ssdraw_worked = run_ssdraw($ssdraw, $template_file, "--mask-col --mask $mask_file", $aln_file2mask, $aln_root, $aln_root2print, 
				    $key_out, "." . $mask_root, $max_width, $opt_HR, $n0, $n1, $do_column_breakdown, $files_to_unlink_AR, $sum_file, $log_file);
    }

    if((($rfmask_file2use ne "") || ($allmask_file2use ne "")) 
       || ($opt_HR->{"--keep"} || $keep_mask || $is_final)) { 
	print_string_to_file($sum_file, 1, sprintf("  %-*s  %6s  %4s  %5s  %5s  %5s\n", $max_width, $mask_file2print, "output", "mask", ($n0+$n1), $n1, $n0));
	if(!($opt_HR->{"--only-afa"})) { 
	    print_string_to_file($sum_file, 1, sprintf("  %-*s  %6s  %4s  %5s  %5s  %5s\n", $max_width, $masked_aln_file2print, "output", "aln", $n1, "-", "-"));
	}
	else { # --only-afa enabled, we'll remove the masked stk file at end of execution
	    push(@{$files_to_unlink_AR}, $masked_aln_file);
	}

	if(($opt_HR->{"--afa"}) || ($opt_HR->{"--only-afa"})){ 
	    $masked_afa_file = $masked_aln_file;
	    $masked_afa_file2print = $masked_aln_file2print;
	    $masked_afa_file =~ s/\.stk$/\.afa/;
	    $masked_afa_file2print =~ s/\.stk$/\.afa/;
	    $command = "$reformat -o $masked_afa_file --informat stockholm afa $masked_aln_file"; 
	    run_executable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");
	    print_string_to_file($sum_file, 1, sprintf("  %-*s  %6s  %4s  %5s  %5s  %5s\n", $max_width, $masked_afa_file2print, "output", "aln", $n1, "-", "-"));
	}
    }
    else { # these files are not permanent, we'll remove them at end of execution
	push(@{$files_to_unlink_AR}, $mask_file);
	push(@{$files_to_unlink_AR}, $masked_aln_file);
    }

    $$n0_R = $n0;
    $$n1_R = $n1;
    $$masked_aln_file_R = $masked_aln_file;
    $$mask_file_R = $mask_file;
    $$ssdraw_worked_R = $ssdraw_worked;
    return 1;
}    


#####################################################################
# subroutine: filter_alignment()
# incept:     EPN, Tue Oct  6 13:17:54 2009
# 
# Purpose:    Filter an alignment based on sequence identity with
#             a call to the esl-weight program.
#
# Arguments:  
#   $weight:                path and name of esl-weight/ssu-esl-weight executable
#   $seqstat:               path and name of esl-weight/ssu-esl-seqstat executable
#   $opt_HR:                reference to the hash of command-line options
#   $aln_root:              root with dir for alignment and output file names, this is normally 
#                           the <output root> supplied with original ssu-align call
#   $aln_root2print:        $aln_root without preceding dir/path
#   $filter_root:           name for mask-related files, usually 'f'
#   $aln_file2filter:       name of alignment file to filter, with path
#   $aln_file2filter2print: $aln_file2filter with no preceding path
#   $max_width_in:          width of output string for input alignment file names
#   $max_width_fil:         width of output string for filtered alignment file names
#   $filtered_aln_file_R:   RETURN; name of masked alignment file just created
#   $files_to_unlink_AR:    REFERENCE to array of files to unlink
#   $sum_file:              file to print output notices to
#   $log_file:              log file for printing commands
# 
# Returns:  Nothing, if it returns, everything is valid.
#
####################################################################
sub filter_alignment { 
    my $narg_expected = 14;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, filter_alignment() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($weight, $seqstat, $opt_HR, $aln_root, $aln_root2print, $filter_root, $aln_file2filter, $aln_file2filter2print,
	$max_width_in, $max_width_fil, $filtered_aln_file_R, $files_to_unlink_AR, $sum_file, $log_file) = @_;

    my($filtered_aln_file, $nseq_input, $nseq_filtered, $filtered_aln_file2print, $command_worked, $filtered_afa_file, $filtered_afa_file2print); 

    $filtered_aln_file       = $aln_root . $key_out . "." . $filter_root . ".stk";
    $filtered_aln_file2print = $aln_root2print . $key_out . "." . $filter_root . ".stk";
    
    seqstat_seqfile($seqstat, $aln_file2filter, \$nseq_input, $log_file);

    # esl-weight -f --idf 0.75 10.stk
    if($opt_HR->{"--filter"} < 0.) { printf STDERR ("\nERROR, with --filter <f>, <f> must be between 0.0 and 1.0, you entered %.4f.\n", $opt_HR->{"--filter"}); exit(1); }
    if($opt_HR->{"--filter"} > 1.) { printf STDERR ("\nERROR, with --filter <f>, <f> must be between 0.0 and 1.0, you entered %.4f.\n", $opt_HR->{"--filter"}); exit(1); }
    $command = "$weight -o $filtered_aln_file -f --idf " . $opt_HR->{"--filter"} . " $aln_file2filter 2>&1";
    run_executable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");
    seqstat_seqfile($seqstat, $filtered_aln_file, \$nseq_filtered, $log_file);

    if(!($opt_HR->{"--only-afa"})) { 
	print_string_to_file($sum_file, 1, sprintf("  %-*s  %8d  %-*s  %8d\n", $max_width_in, $aln_file2filter2print, $nseq_input, $max_width_fil, $filtered_aln_file2print, $nseq_filtered));
    }
    else { # --only-afa enabled, remove the stk filtered file eventually
	push(@{$files_to_unlink_AR}, $filtered_aln_file2print);
    }

    if(($opt_HR->{"--afa"}) || ($opt_HR->{"--only-afa"})){ 
	$filtered_afa_file = $filtered_aln_file;
	$filtered_afa_file2print = $filtered_aln_file2print;
	$filtered_afa_file =~ s/\.stk$/\.afa/;
	$filtered_afa_file2print =~ s/\.stk$/\.afa/;
	$command = "$reformat -o $filtered_afa_file --informat stockholm afa $filtered_aln_file"; 
	run_executable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");
	print_string_to_file($sum_file, 1, sprintf("  %-*s  %8d  %-*s  %8d\n", $max_width_in, $aln_file2filter2print, $nseq_input, $max_width_fil, $filtered_afa_file2print, $nseq_filtered));
    }



    $$filtered_aln_file_R = $filtered_aln_file;
    return 1;
}    


#####################################################################
# Subroutine: seqstat_seqfile()
# Incept:     EPN, Tue Oct  6 18:06:22 2009
# 
# Purpose:    Call esl-seqstat on a sequence file to get the number
#             of sequences in the file.
#
# Arguments: 
#   $seqstat:   path and name of esl-weight/ssu-esl-seqstat executable
#   $seqfile:   sequence file
#   $nseq_ref:  RETURN: number of sequences in the file
#   $log_file:  log file to print commands to
# 
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If anything unexpected occurs, print a message to 
#             STDERR explaining why we're exiting early and then 
#             exit with non-zero status.
#
####################################################################
sub seqstat_seqfile {
    my $narg_expected = 4;
    if(scalar(@_) != $narg_expected) { printf STDERR ("\nERROR, seqstat_seqfile() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($seqstat, $seqfile, $nseq_ref, $log_file) = @_;

    my ($nseq, $tmp, $command, $line, $command_worked, $output);
    $command = "$seqstat $seqfile 2>&1";
    $output = run_executable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");

    my @tmp_A = split("\n", $output);
    foreach $line (@tmp_A) { 
	if($line =~ /Number of sequences\:\s+(\d+)/) { 
	    $nseq = $1;
	}
    }
    $$nseq_ref = $nseq;
    return;
}

#####################################################################
# Subroutine: run_ssdraw
# Incept:     EPN, Tue Oct 13 07:15:09 2009
# 
# Purpose:    Call esl-ssdraw for a given alignment and template file.
#             Convert the postscript to pdf if --ps2pdf is enabled.
#
# Arguments:
#   $ssdraw:              path and name of esl-alimanip/ssu-esl-alimanip executable
#   $template_file:       name of template file to use
#   $ssdraw_opts:         string defining options for esl-ssdraw call
#   $aln_file:            alignment file to draw
#   $root:                root for naming output files (with dir)
#   $root2print:          root for naming output files (without dir unless -a, then with dir)
#   $key_out:             optional extra key for output files
#   $draw_key:            another optional extra key for output files
#   $max_width:           width of output string for printing output file names
#   $opt_HR:              REFERENCE to hash of command-line options
#   $n0:                  number of 0s in the mask (passed in)
#   $n1:                  number of 1s in the mask (passed in)
#   $do_column_breakdown: TRUE to print number of columns included vs excluded in output
#   $files_to_unlink_AR:  REFERENCE to array of files to unlink
#   $sum_file:            file to print output notices to
#   $log_file:            log file
#
# Returns:    '1' if esl-ssdraw worked (exited cleanly (returned 0)), 
#             '0' if it did not work (returned non-0 value)
# 
####################################################################
sub run_ssdraw { 
    my $narg_expected = 16;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, run_ssdraw() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($ssdraw, $template_file, $ssdraw_opts, $aln_file, $root, $root2print, $key_out, 
	$draw_key, $max_width, $opt_HR, $n0, $n1, $do_column_breakdown, $files_to_unlink_AR, $sum_file, $log_file) = @_;

    my($draw_ps, $draw_pdf, $draw_ps2print, $draw_pdf2print, $command_worked);
    $draw_ps         = $root . $key_out . $draw_key . ".ps";
    $draw_pdf        = $root . $key_out . $draw_key . ".pdf";
    $draw_ps2print   = $root2print . $key_out . $draw_key . ".ps";
    $draw_pdf2print  = $root2print . $key_out . $draw_key . ".pdf";

    my $command = "$ssdraw $ssdraw_opts $aln_file $template_file $draw_ps 2>&1";
    my $die_if_fails = 0;
    my $print_output_upon_failure = 0;
    run_executable("$command", $die_if_fails, $print_output_upon_failure, $log_file, \$command_worked, "");

    if(! $command_worked) { # it didn't work, don't exit just alert caller by returning 0
	return 0; 
    } 

    # try ps2pdf, its okay if it doesn't work (unless --pdf or --rm-ps in which case its not ok)
    my $ps2pdf;
    if($opt_HR->{"--pdf"} ne "") { $ps2pdf = $opt_HR->{"--pdf"}; }
    else                         { $ps2pdf = "ps2pdf"; }
    $command = "$ps2pdf $draw_ps $draw_pdf 2>&1";
    $die_if_fails = 0;
    $print_output_upon_failure = 0;
    my $errmsg = "";
    if($opt_HR->{"--pdf"} ne "") { 
	$die_if_fails = 1; 
	$errmsg = "ERROR, --pdf " . $opt_HR->{"--pdf"} . " was enabled, but command $command did not work."; 
    }
    if($opt_HR->{"--rm-ps"}) { 
	$die_if_fails = 1; 
	$errmsg = "ERROR, the ps2pdf command $command did not work, you can't use --rm-ps to remove postscripts in this case.\nIf you have another program that converts ps to pdf supply it as <s> with --pdf <s>.";
    }
    run_executable("$command", $die_if_fails, $print_output_upon_failure, $log_file, \$command_worked, $errmsg);

    if($command_worked) { 
	if($do_column_breakdown) { 
	    print_string_to_file($sum_file, 1, sprintf("  %-*s  %6s  %4s  %5s  %5s  %5s\n", $max_width, $draw_pdf2print, "output", "pdf", ($n0+$n1), $n1, $n0));
	}
	else { 
	    print_string_to_file($sum_file, 1, sprintf("  %-*s  %6s  %4s  %5s  %5s  %5s\n", $max_width, $draw_pdf2print, "output", "pdf", ($n0+$n1), "-", "-"));
	}

	# if we --rm-ps is enabled, remove the ps eventually
	if($opt_HR->{"--rm-ps"}) { 
	    push(@{$files_to_unlink_AR}, $draw_ps);
	}
	else { 
	    if($do_column_breakdown) { 
		print_string_to_file($sum_file, 1, sprintf("  %-*s  %6s  %4s  %5s  %5s  %5s\n", $max_width, $draw_ps2print, "output", "ps", ($n0+$n1), $n1, $n0));
	    }
	    else { 
		print_string_to_file($sum_file, 1, sprintf("  %-*s  %6s  %4s  %5s  %5s  %5s\n", $max_width, $draw_ps2print, "output", "ps", ($n0+$n1), "-", "-"));
	    }
	}
    }
    return 1; #if ssdraw failed we returned 0 above
}


#####################################################################
# Subroutine: print_timing()
# Incept:     EPN, Tue Jun 16 08:52:08 2009
# 
# Purpose:    Print a timing in hhhh:mm:ss format to 1 second precision.
#
# Arguments: 
#   $prefix:      string that will precede timing output
#   $inseconds:   number of seconds the script required
#   $sum_file:    file to print to
#
# Returns:    Nothing, if it returns, everything is valid.
# 
####################################################################
sub print_timing { 
    my $narg_expected = 3;
    if(scalar(@_) != $narg_expected) { printf STDERR ("\nERROR, print_timing() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($prefix, $inseconds, $sum_file) = @_;
    my ($hours, $minutes, $seconds, $thours, $tminutes, $tseconds, $start_log_line);

    $hours = int($inseconds / 3600);
    $inseconds -= ($hours * 3600);
    $minutes = int($inseconds / 60);
    $inseconds -= ($minutes * 60);
    $seconds = $inseconds;
    $thours   = $hours;
    $tminutes = $minutes;
    $tseconds = $seconds;

    if($hours < 10)   { $thours   = "0" . $thours; }
    if($minutes< 10)  { $tminutes = "0" . $tminutes; }
    if($seconds< 10)  { $tseconds = "0" . $tseconds; }

    print_string_to_file($sum_file, 1, sprintf("%s %2s:%2s:%2s\n", $prefix, $thours, $tminutes, $tseconds));
}


###########################################################
# Subroutine: get_num_lines_in_file
# Incept: EPN, Mon Nov  2 10:12:08 2009
#
# Purpose: Determine the number of '\n' delimited lines
#          in a file.
#
# Returns: Number of lines in the file. 
#          If the file can't be opened we die.
#
###########################################################
sub get_num_lines_in_file {
    my $narg_expected = 1;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, get_num_lines_in_file() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($filename) = $_[0];

    my $line;
    my $nlines = 0;
    open(IN, $filename) || die "\nERROR couldn't open file $filename.\n";
    while($line = <IN>) { $nlines++; }
    close(IN);

    return $nlines;
}


###########################################################
# Subroutine: print_string_to_file()
# Incept: EPN, Thu Oct 29 10:47:25 2009
#
# Purpose: Given a string and a file name, append the 
#          string to the file, and potentially to stdout
#          as well. If $filename is the empty string,
#          don't print to a file. 
#
# Returns: Nothing. If the file can't be written to 
#          an error message is printed and the program
#          exits.
#
###########################################################
sub print_string_to_file {
    my $narg_expected = 3;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, print_string_to_file() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($filename, $print_to_stdout, $string) = @_;

    if($filename ne "") { 
	open(OUT, ">>" . $filename) || die "ERROR, couldn't open $filename for appending.\n";
	printf OUT $string;
	close(OUT);
    }

    if($print_to_stdout) { 
	printf($string);
    }
    return;
}


###########################################################
# Subroutine: unlink_file()
# Incept: EPN, Wed Nov  4 18:19:29 2009
#
# Purpose: Unlink (remove) a file. Print info to log file 
#          saying it's been unlinked.
#
# Returns: Nothing. If the file can't be unlinked, we die.
#
###########################################################
sub unlink_file {
    my $narg_expected = 2;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, unlink_file() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($file, $log_file) = @_;

    print_string_to_file($log_file, 0, ("About to remove file ($file) with perl's unlink function ... "));
    if(! unlink($file)) { 
	print_string_to_file($log_file, 0, ("ERROR, couldn't unlink it."));
	die "\nERROR, couldn't remove file $file with unlink function.\n";
    }
    print_string_to_file($log_file, 0, ("done.\n"));
    
    return;
}


###########################################################
# Subroutine: run_executable
# Incept: EPN, Fri Oct 30 06:05:37 2009
#
# Purpose: Run a command with backticks, capturing its standard
#          output and standard error. Print command execution
#          and its output to $log_file. If command returns 
#          non-zero status, print error message $errmsg to 
#          STDERR, and exit if $die_if_fails is TRUE. 
#
# Arguments:
#   $command:                   command to execute
#   $die_if_fails:              '1' to die if command returns non-zero status
#   $print_output_upon_failure: '1' to print command output to STDERR if it fails
#   $log_file:                  file to print command and output to
#   $command_worked_ref:        set to '1' if command works (returns 0), else set to '0'         
#   $errmsg:                    message to print if command returns non-0 exit status
# 
# Returns: Output (stdout and stderr) of the command.
#
###########################################################
sub run_executable {
    my $narg_expected = 6;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, run_executable() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($command, $die_if_fails, $print_output_upon_failure, $log_file, $command_worked_ref, $errmsg) = @_;

    #contract check
    if(($die_if_fails) && ($errmsg eq "")) { die "ERROR, misuse of run_executable: errmsg is the empty string and die_if_fails is TRUE."; }
    my $output = "";
    my $command_worked = 1;

    if ($command !~ m/2\>\&1$/) { $command .= " 2>&1"; }

    print_string_to_file($log_file, 0, ("Executing:  \(" . $command . "\)\n"));
    $output = `$command`;

    print_string_to_file($log_file, 0, ("Returned:   \(" . ($? >> 8) . "\)\n"));

    if(($? >> 8)!= 0) { 
	if($errmsg ne "") { 
	    print_string_to_file($log_file, 0, ("Output:     \(" . $output . "\)\n\n"));
	    printf STDERR ("\n$errmsg\n");
	    print_string_to_file($log_file, 0, ("\n$errmsg\n"));
	}
	if($print_output_upon_failure) { printf STDERR ("Command output: $output\n"); }
	if($die_if_fails) { exit(1); }
	$command_worked = 0;
    }
    else { 
	print_string_to_file($log_file, 0, ("Output:     \(" . $output . "\)\n\n"));
    }

    $$command_worked_ref = $command_worked;
    return $output;
}
