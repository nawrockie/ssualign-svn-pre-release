#!/usr/bin/perl
#
# ssu-mask
# Eric Nawrocki
# EPN, Wed Sep 23 06:18:47 2009
#
# Usage: ssu-mask [options] <directory created by ssu-align (includes alignment file(s))>
# Usage: ssu-mask [options] -a <Stockholm alignment file (must have .stk suffix)>
#             
# Synopsis:
# Masks alignments by removing columns with a significant fraction of 
# ambiguously aligned residues based on alignment posterior probabilities.
# Alternatively, sequences from alignments can be listed 
#
# See definition of $options_usage for options, below.
#
use Getopt::Long;
use strict;
use warnings FATAL => 'all';

#Make sure the SSUALIGNDIR environmental variable is set and the directory exists
my $ssualigndir = $ENV{'SSUALIGNDIR'};
if(! exists($ENV{'SSUALIGNDIR'})) { 
    printf STDERR ("ERROR, the environment variable SSUALIGNDIR is not set, please set it to the directory where you installed SSU-ALIGN.\n"); 
    exit(1); 
}
if(! (-d $ssualigndir)) { 
    printf STDERR ("ERROR, the ssu-align directory specified by your environment variable SSUALIGNDIR does not exist, see the User's Guide Installation section.\n"); 
    exit(1); 
}    
#Make sure the SSUALIGNDIR directory includes ssu-align-0p1.subs.pm
my $subs_file = $ssualigndir . "/ssu-align-0p1.subs.pm";
if(! (-e $subs_file)) { 
    printf STDERR ("ERROR, the required perl module ssu-align-0p1.subs.pm is not in the directory specified by your SSUALIGNDIR environment variable.\n"); 
    exit(1); 
}
require $subs_file;

# Start timing, this is done different depending on if Time::HiRes is installed or not
my $time_hires_installed = UseModuleIfItExists("Time::HiRes qw(gettimeofday)");
my $total_seconds = -1 * SecondsSinceEpoch($time_hires_installed);

my $script_desc    = "mask SSU rRNA alignments";
my $date           = scalar localtime();
my $usage          = "Usage: ssu-mask [options] <directory created by ssu-align (includes >= 1 alignment file(s))>\n";
   $usage         .= "Usage: ssu-mask [options] -a <Stockholm alignment file>\n";
my $options_usage  = "where general options are:\n";
#                           1         2         3         4         5         6         7         8
#                  12345678901234567890123456789012345678901234567890123456789012345678901234567890
#$options_usage .= "  -a            : the command-line argument is a stockholm alignment, not a directory\n";
$options_usage .= "  -h            : show brief help on version and usage\n";
$options_usage .= "  -1            : output alignment(s) in non-interleaved, 1 line/seq format\n";
$options_usage .= "  -m <f>        : CM file <f> created the alignment(s) (with ssu-align -m <f>)\n";
$options_usage .= "  -t <f>        : for structure diagrams, use template file <f>, not the default\n";
$options_usage .= "  --afa         : output aligned FASTA (.afa) alignments as well as Stockholm ones\n";
$options_usage .= "  --only-afa    : only output aligned FASTA (.afa) alignments, no Stockholm ones\n";
$options_usage .= "  --key-in <s>  : assume <s> is part of input file names, before the suffix\n";
$options_usage .= "  --key-out <s> : add <s> to all output file names, before the suffix\n";

$options_usage .= "\noptions related to masking alignments:\n";
$options_usage .= "  --pf <x>        : include columns w/<x> fraction of seqs w/prob >= --pt <y> [df: 0.95]\n";
$options_usage .= "  --pt <y>        : set probability threshold for --pf as <x> [default=0.95]\n";
$options_usage .= "  --no-prob       : exclude insert columns only, do not mask based on probabilities\n";
$options_usage .= "  --gapthresh <x> : only consider columns with <= <x> fraction gaps\n";
$options_usage .= "  --in-mask <f>   : mask alignment given 1/0s in 1-line mask file <f>, requires -a\n";
$options_usage .= "  --keep          : keep all intermediate files which are normally removed\n";
$options_usage .= "  --ps2pdf <s>    : <s> (!= \"ps2pdf\") is the command for converting ps to pdf\n";
$options_usage .= "  --ps-keep       : if --ps2pdf or ps2pdf is installed, save postscript (& pdf) files\n";
$options_usage .= "  --ps-only       : only save postscript secondary structure diagrams, no pdfs\n";

$options_usage .= "\noption for filtering alignments based on sequence identity (no masking):\n";
$options_usage .= "  --filter <x> : remove seqs such that no 2 seqs > <x> identical (1st seq is always kept)\n";

$options_usage .= "\noption for listing sequences in alignment(s) (no masking):\n";
$options_usage .= "  --list : output list file(s) of sequence names in alignment(s)\n";    

$options_usage .= "\noptions for converting a Stockholm alignment to aligned fasta (no masking):\n";
$options_usage .= "  --stk2afa : convert Stockholm alignment(s) to aligned FASTA\n";

$options_usage .= "\noptions for only removing sequences from an alignment, require -a (no masking):\n";
$options_usage .= "  --seq-r <f> : with -a, remove sequences with names listed in file <f>\n"; 
$options_usage .= "  --seq-k <f> : with -a, remove all sequences *except* those listed in file <f>\n"; 

###################
# Process options #
###################
my %opt_H = ();              # key: option (example "-h"); value: option argument (example ("0" or "1") if option takes no arg, actual argument if option takes arg)
my %opt_takes_arg_H  = ();   # key: option; value: "1" if option takes argument, "0" if not
my @opt_order_A  = ();       # order of options for printing in banner
my $opt;

$opt_takes_arg_H{"-a"}          = 0;  push(@opt_order_A, "-a");           
$opt_takes_arg_H{"-h"}          = 0;  push(@opt_order_A, "-h");           
$opt_takes_arg_H{"-1"}          = 0;  push(@opt_order_A, "-1");           
$opt_takes_arg_H{"-m"}          = 1;  push(@opt_order_A, "-m");           
$opt_takes_arg_H{"-t"}          = 1;  push(@opt_order_A, "-t");           
$opt_takes_arg_H{"--afa"}       = 0;  push(@opt_order_A, "--afa");      
$opt_takes_arg_H{"--only-afa"}  = 0;  push(@opt_order_A, "--only-afa");      
$opt_takes_arg_H{"--key-in"}    = 1;  push(@opt_order_A, "--key-in");     
$opt_takes_arg_H{"--key-out"}   = 1;  push(@opt_order_A, "--key-out");    
$opt_takes_arg_H{"--pf"}        = 1;  push(@opt_order_A, "--pf");      
$opt_takes_arg_H{"--pt"}        = 1;  push(@opt_order_A, "--pt");      
$opt_takes_arg_H{"--no-prob"}   = 0;  push(@opt_order_A, "--no-prob");      
$opt_takes_arg_H{"--gapthresh"} = 1;  push(@opt_order_A, "--gapthresh");      
$opt_takes_arg_H{"--in-mask"}   = 1;  push(@opt_order_A, "--in-mask");    
$opt_takes_arg_H{"--keep"}      = 0;  push(@opt_order_A, "--keep");
$opt_takes_arg_H{"--ps2pdf"}    = 1;  push(@opt_order_A, "--ps2pdf");
$opt_takes_arg_H{"--ps-keep"}   = 0;  push(@opt_order_A, "--ps-keep");      
$opt_takes_arg_H{"--ps-only"}   = 0;  push(@opt_order_A, "--ps-only");      
$opt_takes_arg_H{"--filter"}    = 1;  push(@opt_order_A, "--filter");      
$opt_takes_arg_H{"--list"}      = 0;  push(@opt_order_A, "--list");
$opt_takes_arg_H{"--stk2afa"}   = 0;  push(@opt_order_A, "--stk2afa");      
$opt_takes_arg_H{"--seq-r"}     = 1;  push(@opt_order_A, "--seq-r");      
$opt_takes_arg_H{"--seq-k"}     = 1;  push(@opt_order_A, "--seq-k");      

#set default options
foreach $opt (keys %opt_takes_arg_H) { 
    if($opt_takes_arg_H{$opt}) { $opt_H{$opt} = ""; }
    else                       { $opt_H{$opt} = 0; }
}

# the only global variables: default values
our $df_pf = 0.95;
our $df_pt = 0.95;

Getopt::Long::Configure ("bundling");
my $opt_return = GetOptions
    ('a'           => \$opt_H{"-a"},
     'h'           => \$opt_H{"-h"}, 
     '1'           => \$opt_H{"-1"},
     'm=s'         => \$opt_H{"-m"},
     't=s'         => \$opt_H{"-t"},
     'afa'         => \$opt_H{"--afa"},
     'only-afa'    => \$opt_H{"--only-afa"},
     'key-in=s'    => \$opt_H{"--key-in"},
     'key-out=s'   => \$opt_H{"--key-out"},
     'pf=s'        => \$opt_H{"--pf"},
     'pt=s'        => \$opt_H{"--pt"},
     'no-prob'     => \$opt_H{"--no-prob"},
     'gapthresh=s' => \$opt_H{"--gapthresh"},
     'in-mask'     => \$opt_H{"--in-mask"},
     'keep'        => \$opt_H{"--keep"},
     'ps2pdf=s'    => \$opt_H{"--ps2pdf"},
     'ps-keep'     => \$opt_H{"--ps-keep"},
     'ps-only'     => \$opt_H{"--ps-only"},
     'filter=s'    => \$opt_H{"--filter"},
     'list'        => \$opt_H{"--list"},
     'seq-r=s'     => \$opt_H{"--seq-r"},
     'seq-k=s'     => \$opt_H{"--seq-k"},
     'stk2afa'     => \$opt_H{"--stk2afa"});

if($opt_return != 1) { exit(1); }

if ($opt_H{"-h"}) { 
    PrintBanner($0, $script_desc, $date, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, 1, "");
    print $usage . "\n"; 
    print $options_usage; 
    exit(0); 
} 

my $key_in = "";
if($opt_H{"--key-in"}  ne "")  { $key_in   = "." . $opt_H{"--key-in"};  }
my $key_out = "";
if($opt_H{"--key-out"}  ne "") { $key_out   = "." . $opt_H{"--key-out"};  }


##############################################################################
# Determine the "mode" to run and check for incompatible option combinations.#
##############################################################################
# There are 5 possible modes, each is exclusive.
my $do_mask_mode        = 0; # default mode, mask the alignment
my $do_remove_seqs_mode = 0; # remove some sequences from the alignment given a list file, no masking
my $do_filter_mode      = 0; # filter alignment(s), no masking
my $do_list_mode        = 0; # list sequences in the alignment, no masking
my $do_stk2afa_mode     = 0; # convert a single alignment file to aligned fasta and exit

# Mask mode options.
if($opt_H{"--pf"} ne "")        { $do_mask_mode = 1; }
if($opt_H{"--pt"} ne "")        { $do_mask_mode = 1; }

if($opt_H{"--no-prob"}) 
{ 
    if($do_mask_mode) { printf STDERR ("\nERROR, --no-prob is incompatible with --pf and --pt.\n"); exit(1); }
    $do_mask_mode = 1; 
}
if($opt_H{"--gapthresh"} ne "")    { $do_mask_mode = 1; }
if($opt_H{"--in-mask"} ne "") { 
    if(!($opt_H{"-a"})) { printf STDERR ("\nERROR, --in-mask requires the -a option.\n"); exit(1); }
    if($do_mask_mode)   { printf STDERR ("\nERROR, --in-mask is incompatible with --pf, --pt, --no-prob, and --gapthresh.\n"); exit(1); }
    $do_mask_mode = 1; 
}

# Remove sequences options.
if(($opt_H{"--seq-r"} ne "") && ($opt_H{"--seq-k"} ne "")) { printf STDERR ("\nERROR, --seq-r and --seq-k are incompatible, choose one.\n"); exit(1); }
if($opt_H{"--seq-r"} ne "")  { $do_remove_seqs_mode = 1; }
if($opt_H{"--seq-k"} ne "")  { $do_remove_seqs_mode = 1; }

if($do_remove_seqs_mode && $do_mask_mode) { 
    printf STDERR ("\nERROR, --pf, --pt, --gapthresh, --filter, --no-prob and --in-mask are incompatible with --seq-k and --seq-r.\n"); exit(1); 
}
if($do_remove_seqs_mode && (! $opt_H{"-a"})) { 
    printf STDERR ("\nERROR,--seq-k and --seq-r require -a. They can only be used on a single alignment.\n"); exit(1); 
}

# Filter options.
if($opt_H{"--filter"} ne "") { $do_filter_mode = 1; }
if($do_filter_mode && $do_mask_mode) { 
    printf STDERR ("\nERROR, --pf, --pt, --gapthresh, --filter, --no-prob and --in-mask are incompatible with --filter.\nFilter first, then mask filtered alignments with a subsequent ssu-mask call\n"); exit(1); 
}
if($do_filter_mode && $do_remove_seqs_mode) { 
    printf STDERR ("\nERROR, --seq-k and --seq-r are incompatible with --filter.\n"); exit(1); 
}

# List sequences options.
if($opt_H{"--list"})      { $do_list_mode = 1;}
if($do_list_mode && $do_mask_mode) { 
    printf STDERR ("\nERROR, --pf, --pt, --gapthresh, --filter, --no-prob and --in-mask are incompatible with --list.\n"); exit(1); 
}
if($do_list_mode && $do_remove_seqs_mode) { 
    printf STDERR ("\nERROR, --seq-k and --seq-r are incompatible with --list.\n"); exit(1); 
}
if($do_list_mode && $do_filter_mode) { 
    printf STDERR ("\nERROR, --list is incompatible with --filter.\n"); exit(1); 
}

# stk2afa options
if($opt_H{"--stk2afa"})  { $do_stk2afa_mode = 1; }

if($do_stk2afa_mode && $do_mask_mode) { 
    printf STDERR ("\nERROR, --pf, --pt, --gapthresh, --filter, --no-prob and --in-mask are incompatible with --stk2afa.\n"); exit(1); 
}
if($do_stk2afa_mode && $do_remove_seqs_mode) { 
    printf STDERR ("\nERROR, --stk2afa is incompatible with --seq-k and --seq-r.\n"); exit(1); 
}
if($do_stk2afa_mode && $do_filter_mode) { 
    printf STDERR ("\nERROR, --stk2afa is incompatible with --filter.\n"); exit(1); 
}
if($do_stk2afa_mode && $do_list_mode) { 
    printf STDERR ("\nERROR, --stk2afa is incompatible with --list.\n"); exit(1); 
}

if(($do_remove_seqs_mode + $do_list_mode + $do_filter_mode + $do_stk2afa_mode) == 0) { $do_mask_mode = 1; }

if($opt_H{"--ps2pdf"}  && (! $do_mask_mode)) { printf STDERR ("\nERROR, --ps2pdf is incompatible with --filter, --list, --stk2afa, --seq-r and --seq-k\n"); exit(1); }
if($opt_H{"--ps-keep"} && (! $do_mask_mode)) { printf STDERR ("\nERROR, --ps-keep is incompatible with --filter, --list, --stk2afa, --seq-r and --seq-k\n"); exit(1); }
if($opt_H{"--ps-only"} && (! $do_mask_mode)) { printf STDERR ("\nERROR, --ps-only is incompatible with --filter, --list, --stk2afa, --seq-r and --seq-k\n"); exit(1); }
if($opt_H{"--keep"}    && (! $do_mask_mode)) { printf STDERR ("\nERROR, --keep is incompatible with --filter, --list, --stk2afa, --seq-r and --seq-k\n"); exit(1); }

if(($opt_H{"--afa"})  && ((! $do_mask_mode) && (! $do_filter_mode)))      { printf STDERR ("\nERROR, --afa is incompatible with --list, --stk2afa, --seq-r, and --seq-k\n"); exit(1); }
if(($opt_H{"--only-afa"})  && ((! $do_mask_mode) && (! $do_filter_mode))) { printf STDERR ("\nERROR, --only-afa is incompatible with --list, --stk2afa, --seq-r, and --seq-k\n"); exit(1); }

if($opt_H{"--afa"}  && ($opt_H{"--only-afa"})) { printf STDERR ("\nERROR, --afa is incompatible with --only-afa\n"); exit(1); }

if($opt_H{"--ps-only"} && ($opt_H{"--ps2pdf"} ne "")) { printf STDERR ("\nERROR, --ps-only is incompatible with --ps2pdf\n"); exit(1); }

###################################################
# Process command-line arguments and print banner #
###################################################
if(scalar(@ARGV) != 1) {   
    print "Incorrect number of command line arguments.\n";
    print $usage;
    print "\nTo see more help on available options, do ssu-mask -h\n\n";
    exit(1);
}
my ($dir) = $ARGV[0];
$dir =~ s/\/$//;

my ($sum_file, $sum_file2print, $log_file, $log_file2print);
my @files_to_unlink_A = ();
my @stk_suffix_A = (".stk", ".sto");
if(! $opt_H{"-a"}) { 
    #validate that $dir exists
    if(!(-d $dir)) { printf STDERR ("\nERROR, directory $dir does not exist.\n"); exit(1); }
    $sum_file       = $dir . "\/" . $dir . $key_out . ".ssu-mask.sum";
    $log_file       = $dir . "\/" . $dir . $key_out . ".ssu-mask.log";
    $sum_file2print = RemoveDirPath($sum_file);
    $log_file2print = RemoveDirPath($log_file);
}
else {
    $sum_file       = SwapOrAppendFileSuffix($dir, \@stk_suffix_A, $key_out . ".ssu-mask.sum", 0);
    $log_file       = SwapOrAppendFileSuffix($dir, \@stk_suffix_A, $key_out . ".ssu-mask.log", 0);
    $sum_file2print = $sum_file;
    $log_file2print = $log_file;
}

# open the summary and log files
open(OUT, ">" . $sum_file) || die "ERROR, couldn't open file $sum_file for writing";
close(OUT);
open(OUT, ">" . $log_file) || die "ERROR, couldn't open file $log_file for writing";
close(OUT);

PrintBanner($0, $script_desc, $date, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, 1, $sum_file);
PrintBanner($0, $script_desc, $date, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, 0, $log_file);

##################################
# Validate that everything is go #
##################################
my @stk_list_A = ();
my ($cm_file, $template_file, $alimanip, $ssdraw, $weight, $seqstat, $reformat);
validate_and_setup_ssu_mask($ssualigndir, $dir, $key_in, \%opt_H, \$cm_file, \$template_file, \$alimanip, \$ssdraw, \$weight, \$seqstat, \$reformat, \@stk_list_A, $log_file, $sum_file);
my $naln = scalar(@stk_list_A);
my $aln_file;

my $alimanip_options = "";


##########################
# Mask mode: Do the work #
##########################
my $max_width;
my ($i, $tmp, $command, $aln_root, $aln_root2print, $final_key, $nec_width, $dashes, $print_input_aln);
my $ssdraw_failed_at_least_once = 0;
my $ssdraw_worked_at_least_once = 0;

if($do_mask_mode) 
{ 
    my ($do_pmask, $do_gmask, $extra_chars);
    if($opt_H{"--no-prob"})         { $do_pmask = 0; }
    else                            { $do_pmask = 1; }
    if($opt_H{"--gapthresh"} ne "") { $do_gmask = 1; }
    else                            { $do_gmask = 0; }
    if($do_pmask && $do_gmask)      { $extra_chars = 13; } #13 is for ".maskdiff" + (".pdf" or ".stk")
    elsif($opt_H{"--keep"})         { $extra_chars = 10; } #10 is for ".cmask" + (".pdf" or ".stk")
    else                            { $extra_chars =  9; }  #9 is for ".mask" + (".pdf" or ".stk")

    # determine max file name width
    $max_width = length("file name");
    for($i = 0; $i < $naln; $i++) { 
	$aln_file = $stk_list_A[$i];
	$aln_root2print = SwapOrAppendFileSuffix($aln_file, \@stk_suffix_A, "", $opt_H{"-a"});
	$nec_width = length($aln_root2print) + length($key_out) + $extra_chars; 
	if($max_width < $nec_width) { $max_width = $nec_width; }
    }					     
    $dashes = ""; for($i = 0; $i < $max_width; $i++) { $dashes .= "-"; }

    PrintStringToFile($sum_file, 1, sprintf("#\n# Masking alignments...\n"));
    PrintStringToFile($sum_file, 1, sprintf("#\n"));
    PrintStringToFile($sum_file, 1, sprintf("# %-*s  %6s  %4s  %5s  %-12s\n", $max_width, "", "", "", "", "    mask"));
    PrintStringToFile($sum_file, 1, sprintf("# %-*s  %6s  %4s  %5s  %12s\n", $max_width, "", "", "", "", "------------"));
    PrintStringToFile($sum_file, 1, sprintf("# %-*s  %6s  %4s  %5s  %5s  %5s\n", $max_width, "file name", "in/out", "type", "\#cols", "incl.", "excl."));
    PrintStringToFile($sum_file, 1, sprintf("# %-*s  %6s  %4s  %5s  %5s  %5s\n", $max_width, $dashes, "------", "----", "-----", "-----", "-----"));
    
    # Mask each alignment
    my $rfmask2use = "";
    my $allmask2use = "";
    my $mask_opts = "";
    my $mask_root = "";
    my $keep_mask = 0;
    my $print_input_aln = 0;
    my $mask_ok_if_fails = 0;
    my $do_draw = 0;
    my $ssdraw_worked = 0;
    my ($pt_opt, $pf_opt);

    $pt_opt = $opt_H{"--pt"};
    $pf_opt = $opt_H{"--pf"};
    if($pt_opt eq "") { $pt_opt = $df_pt; }
    if($pf_opt eq "") { $pf_opt = $df_pf; }

    for($i = 0; $i < $naln; $i++) { 
	$aln_file = $stk_list_A[$i];
	$aln_root       = SwapOrAppendFileSuffix($aln_file, \@stk_suffix_A, "", 1);
	$aln_root2print = SwapOrAppendFileSuffix($aln_file, \@stk_suffix_A, "", $opt_H{"-a"});
	
	if($opt_H{"--in-mask"} ne "") { # mask the alignment using the --in-mask mask 
	    my ($mask_worked, $n0, $n1, $inmask_masked_aln_file, $mask_file, $keep_mask, $do_draw, $mask_ok_if_fails);

	    if(!$opt_H{"-a"}) { 
		PrintErrorAndExit("ERROR, --in-mask requires the -a option.", $sum_file, 1); 
	    }
	    if(!(-e $opt_H{"--in-mask"})) { 
		PrintErrorAndExit("ERROR, the --in-mask file " . $opt_H{"--in-mask"} . " does not exist.", $sum_file, 1); 
	    }

	    # first try --mask-rf (to see if the mask is non-gap RF length (instead of full alignment length))
	    $rfmask2use       = $opt_H{"--in-mask"};
	    $allmask2use      = "";
	    $keep_mask        = 0; 
	    $print_input_aln  = 1;
	    $mask_ok_if_fails = 1; #it's okay if --mask-rf does not work, we'll try --mask-all 
	    $mask_opts        = "";
	    $mask_root        = "mask";
	    if(($ssdraw ne "") && ($template_file ne "")) { $do_draw          = 1; }
	    else                                          { $do_draw          = 0; }
	    $mask_worked = mask_alignment($alimanip, \%opt_H, $ssdraw, $mask_root, $aln_file, $aln_file, \@stk_suffix_A, $keep_mask, $print_input_aln, 
					  $mask_opts, $rfmask2use, "", $do_draw, $max_width, $mask_ok_if_fails, $template_file, 
					  \$n0, \$n1, \$inmask_masked_aln_file, \$mask_file, \$ssdraw_worked, \@files_to_unlink_A, $sum_file, $log_file);
	    if(!($mask_worked)) { 
		#try --mask-all (to see if the mask is full alignment length)
		$mask_ok_if_fails = 0;
		$rfmask2use       = "";
		$allmask2use      = $opt_H{"--in-mask"};
		mask_alignment($alimanip, \%opt_H, $ssdraw, $mask_root, $aln_file, $aln_file, \@stk_suffix_A, $keep_mask, $print_input_aln, 
			       $mask_opts, "", $allmask2use, $do_draw, $max_width, $mask_ok_if_fails, $template_file, 
			       \$n0, \$n1, \$inmask_masked_aln_file, \$mask_file, \$ssdraw_worked, \@files_to_unlink_A, $sum_file, $log_file);
		# mask_alignment will exit in error if masking does not work this time
	    }
	    if   ($do_draw && $ssdraw_worked)    { $ssdraw_worked_at_least_once = 1; }
	    elsif($do_draw && (!$ssdraw_worked)) { $ssdraw_failed_at_least_once = 1; }
	}
	else {  #--in-mask not enabled
	    my ($cmasked_aln_file, $cmask_file, $pmasked_aln_file, $pmask_file, $gmasked_aln_file, $gmask_file, $pgmasked_aln_file, $pgmask_file);
	    my ($pgmaskdiff_ps, $pgmaskdiff_ps2print, $pgmaskdiff_pdf, $pgmaskdiff_pdf2print);
	    my ($cn0, $cn1, $pn0, $pn1, $gn0, $gn1, $pgn0, $pgn1);
	    $mask_ok_if_fails = 0;
	    $rfmask2use       = "";
	    $allmask2use      = "";

	    # First masking: remove all insert columns and number the RF columns 
	    if($do_pmask || $do_gmask) { $mask_root = "cmask"; }
	    else                       { $mask_root = "mask";  } # the final mask
	    $keep_mask        = 0;
	    $print_input_aln  = 1;
	    $do_draw          = 0; #don't draw this time
	    $mask_opts = "-k --num-rf";
	    mask_alignment($alimanip, \%opt_H, $ssdraw, $mask_root, $aln_file, $aln_file, \@stk_suffix_A, $keep_mask, $print_input_aln, 
			   $mask_opts, "", "", $do_draw, $max_width, $mask_ok_if_fails, $template_file, 
			   \$cn0, \$cn1, \$cmasked_aln_file, \$cmask_file, \$ssdraw_worked, \@files_to_unlink_A, $sum_file, $log_file);
	    if   ($do_draw && $ssdraw_worked)    { $ssdraw_worked_at_least_once = 1; }
	    elsif($do_draw && (!$ssdraw_worked)) { $ssdraw_failed_at_least_once = 1; }
	    
	    # Probabilistic masking, if necessary
	    if($do_pmask) { 
		if($do_gmask) { $mask_root = "pmask"; }
		else          { $mask_root = "mask";  } # the final mask
		$keep_mask = $opt_H{"--keep"};
		$print_input_aln = 0;
		if(($ssdraw ne "") && ($template_file ne "")) { $do_draw          = 1; }
		else                                          { $do_draw          = 0; }
		$mask_opts = "-k --p-rf --pfract $pf_opt --pthresh $pt_opt";
		mask_alignment($alimanip, \%opt_H, $ssdraw, $mask_root, $cmasked_aln_file, $aln_file, \@stk_suffix_A, $keep_mask, $print_input_aln, 
			       $mask_opts, "", "", $do_draw, $max_width, $mask_ok_if_fails, $template_file, 
			       \$pn0, \$pn1, \$pmasked_aln_file, \$pmask_file, \$ssdraw_worked, \@files_to_unlink_A, $sum_file, $log_file);
		if   ($do_draw && $ssdraw_worked)    { $ssdraw_worked_at_least_once = 1; }
		elsif($do_draw && (!$ssdraw_worked)) { $ssdraw_failed_at_least_once = 1; }
	    }
	    
	    # Gap-based masking, if necessary
	    if($do_gmask) { 
		if($do_pmask) { 
		    $mask_root = "gmask"; 
		    $keep_mask = $opt_H{"--keep"};
		}
		else { #the final mask
		    $mask_root = "mask";  
		    $keep_mask = 1;
		}
		$print_input_aln = 0;
		if(($ssdraw ne "") && ($template_file ne "")) { $do_draw          = 1; }
		else                                          { $do_draw          = 0; }
		$mask_opts = "-k -g --gapthresh " . $opt_H{"--gapthresh"};
		mask_alignment($alimanip, \%opt_H, $ssdraw, $mask_root, $cmasked_aln_file, $aln_file, \@stk_suffix_A, $keep_mask, $print_input_aln, 
			       $mask_opts, "", "", $do_draw, $max_width, $mask_ok_if_fails, $template_file, 
			       \$gn0, \$gn1, \$gmasked_aln_file, \$gmask_file, \$ssdraw_worked, \@files_to_unlink_A, $sum_file, $log_file);
		if   ($do_draw && $ssdraw_worked)    { $ssdraw_worked_at_least_once = 1; }
		elsif($do_draw && (!$ssdraw_worked)) { $ssdraw_failed_at_least_once = 1; }
	    }
	    
	    # If we did both probabilistic and gap-based masking, take the union of the masks
	    if($do_pmask && $do_gmask) { # this is always the final mask
		$pgmasked_aln_file = SwapOrAppendFileSuffix($aln_file, \@stk_suffix_A, $key_out . ".mask.stk", 1);
		$pgmask_file       = SwapOrAppendFileSuffix($aln_file, \@stk_suffix_A, $key_out . ".mask", 1);

		#create the union of the masks, any column that is excluded (a '0') in either mask is a '0' in the union
		write_union_of_masks($pmask_file, $gmask_file, $pgmask_file, $sum_file);
		$mask_root = "mask";
		$keep_mask = 1;
		$print_input_aln = 0;
		if(($ssdraw ne "") && ($template_file ne "")) { $do_draw          = 1; }
		else                                          { $do_draw          = 0; }
		$mask_opts = "-k";
		$rfmask2use = $pgmask_file;
		mask_alignment($alimanip, \%opt_H, $ssdraw, $mask_root, $cmasked_aln_file, $aln_file, \@stk_suffix_A, $keep_mask, $print_input_aln, 
			       $mask_opts, $pgmask_file, "", $do_draw, $max_width, $mask_ok_if_fails, $template_file, 
			       \$pgn0, \$pgn1, \$pgmasked_aln_file, \$pgmask_file, \$ssdraw_worked, \@files_to_unlink_A, $sum_file, $log_file);
		if   ($do_draw && $ssdraw_worked)    { $ssdraw_worked_at_least_once = 1; }
		elsif($do_draw && (!$ssdraw_worked)) { $ssdraw_failed_at_least_once = 1; }

		if(($ssdraw ne "") && ($template_file ne "")) 
		{ 
		    # draw the difference between the pmask and the gmask
		    my $do_column_breakdown = 0;
		    $ssdraw_worked = run_ssdraw_for_ssu_mask($ssdraw, $template_file, "--mask-diff $pmask_file --mask $gmask_file", $cmasked_aln_file, $aln_file, \@stk_suffix_A, 
						$key_out, "maskdiff", $max_width, \%opt_H, $pgn0, $pgn1, $do_column_breakdown, \@files_to_unlink_A, $sum_file, $log_file);
		    if   ($ssdraw_worked)  { $ssdraw_worked_at_least_once = 1; }
		    elsif(!$ssdraw_worked) { $ssdraw_failed_at_least_once = 1; }
		}
	    }
	}
	if($i < ($naln-1)) { 
	    PrintStringToFile($sum_file, 1, sprintf("#\n"));
	}
    }
}    


############################
# Filter mode: Do the work #
############################
if($do_filter_mode) { 
    my $max_width_fil = length("file name");
    my ($filter_root);
    $filter_root = "fil";
    for($i = 0; $i < $naln; $i++) { 
	$aln_file       = $stk_list_A[$i];
	$aln_root2print = SwapOrAppendFileSuffix($aln_file, \@stk_suffix_A, "", $opt_H{"-a"});
	$nec_width = length($aln_root2print) + length($key_out) + length(".") + length($filter_root) + length(".stk");
	if($max_width_fil < $nec_width) { $max_width_fil = $nec_width; }
    }
    my $dashes_fil = ""; for($i = 0; $i < $max_width_fil; $i++) { $dashes_fil .= "-"; }
    my $wide_dashes_fil = $dashes_fil . "----------";
    my $max_width_in = $max_width_fil - length($key_out) - 4; #max_width_in is max length of a filtered file, minus 4 for diff between .fil.stk and .stk
    if($max_width_in < length("file name")) { $max_width_in = length("file name"); }
    my $dashes_in = ""; for($i = 0; $i < $max_width_in; $i++) { $dashes_in .= "-"; }
    my $wide_dashes_in = $dashes_in . "----------";

    PrintStringToFile($sum_file, 1, sprintf("#\n# Filtering alignments so that no 2 seqs are more than " . $opt_H{"--filter"} . " identical.\n"));
    PrintStringToFile($sum_file, 1, sprintf("#\n"));
    PrintStringToFile($sum_file, 1, sprintf("# %-*s  %-*s\n", $max_width_in+10, "input alignment", $max_width_fil+10, "filtered alignment"));
    PrintStringToFile($sum_file, 1, sprintf("# %-*s  %-*s\n", $max_width_in+10, $wide_dashes_in, $max_width_fil+10, $wide_dashes_fil));
    PrintStringToFile($sum_file, 1, sprintf("# %-*s  %8s  %-*s  %8s\n", $max_width_in, "file name", "num seqs", $max_width_fil, "file name", "num seqs"));
    PrintStringToFile($sum_file, 1, sprintf("# %-*s  %8s  %-*s  %8s\n", $max_width_in, $dashes_in, "--------", $max_width_fil, $dashes_fil, "--------"));

    for($i = 0; $i < $naln; $i++) { 
	$aln_file = $stk_list_A[$i];
	filter_alignment($weight, $seqstat, \%opt_H, $filter_root, $aln_file, $key_out, \@stk_suffix_A, $max_width_in, $max_width_fil, \@files_to_unlink_A, $sum_file, $log_file);
    }
}    


##########################
# List mode: Do the work #
##########################
if($do_list_mode) 
{ 
    # determine max file name width
    my $max_width_list = length("list file name");
    for($i = 0; $i < $naln; $i++) { 
	$aln_file       = $stk_list_A[$i];
	$aln_root2print = SwapOrAppendFileSuffix($aln_file, \@stk_suffix_A, "", $opt_H{"-a"});
	$nec_width = length($aln_root2print) + length($key_out) + 5; #5 is for ".list"
	if($max_width_list < $nec_width) { $max_width_list = $nec_width; }
    }					     
    my $dashes_list = ""; for($i = 0; $i < $max_width_list; $i++) { $dashes_list.= "-"; }
    my $max_width_aln = $max_width_list - length($key_out) - 1; #max_width_aln is max length of a list file, minus 1 for diff between .list and .stk
    if($max_width_aln < length("aln file name")) { $max_width_aln = length("aln file name"); } 
    my $dashes_aln = ""; for($i = 0; $i < $max_width_aln; $i++) { $dashes_aln .= "-"; }

    PrintStringToFile($sum_file, 1, sprintf("#\n# Listing sequences in alignments.\n"));
    PrintStringToFile($sum_file, 1, sprintf("#\n"));
    PrintStringToFile($sum_file, 1, sprintf("# %-*s  %-*s  %8s\n", $max_width_aln, "aln file name", $max_width_list, "list file name", "num seqs"));
    PrintStringToFile($sum_file, 1, sprintf("# %-*s  %-*s  %8s\n", $max_width_aln, $dashes_aln, $max_width_list, $dashes_list, "--------"));

    my ($list_file, $list_file2print, $aln_file2print, $nseq, $command_worked);
    for($i = 0; $i < $naln; $i++) { 
	$aln_file = $stk_list_A[$i];
	if($opt_H{"-a"}) { # print directory as well as aln name for stockholm alignment, save list to cwd
	    $aln_file2print = $aln_file;
	    $list_file       = SwapOrAppendFileSuffix($aln_file, \@stk_suffix_A, $key_out . ".list", 0);
	    $list_file2print = $list_file;
	}
	else { # print no directory for either stk or list file, save list file to same dir stk is in
	    $aln_file2print  = RemoveDirPath($aln_file);
	    $list_file       = SwapOrAppendFileSuffix($aln_file, \@stk_suffix_A, $key_out . ".list", 1);
	    $list_file2print = RemoveDirPath($list_file);
	}
	$command = "$alimanip --list $list_file $aln_file"; 
	RunExecutable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");

	my $nseq = get_num_lines_in_file($list_file, $sum_file);
	
	PrintStringToFile($sum_file, 1, sprintf("  %-*s  %-*s  %8d\n", $max_width_aln, $aln_file2print, $max_width_list, $list_file2print, $nseq));
    }
}


######################################
# Sequence removal mode: Do the work #
######################################
if($do_remove_seqs_mode) 
{ 
    # determine max file name width
    my $max_width = length("subset aln file name");
    $aln_file       = $stk_list_A[0];
    $aln_root2print = SwapOrAppendFileSuffix($aln_file, \@stk_suffix_A, "", $opt_H{"-a"});
    $nec_width = length($aln_root2print) + length($key_out) + 9; #9 is for ".seq{r,k}.stk"
    if($max_width < $nec_width) { $max_width = $nec_width; }
    my $dashes = ""; for($i = 0; $i < $max_width; $i++) { $dashes.= "-"; }
    my $command_worked;

    PrintStringToFile($sum_file, 1, sprintf("#\n# Removing some sequences from an alignment.\n"));
    PrintStringToFile($sum_file, 1, sprintf("#\n"));
    PrintStringToFile($sum_file, 1, sprintf("# %-*s  %8s\n", $max_width, "subset aln file name", "num seqs"));
    PrintStringToFile($sum_file, 1, sprintf("# %-*s  %8s\n", $max_width, $dashes, "--------"));
    
    if($naln != 1)     { PrintErrorAndExit("ERROR, --seq-r and --seq-k require the -a option.", $sum_file, 1); }
    if(! $opt_H{"-a"}) { PrintErrorAndExit("ERROR, --seq-r and --seq-k require the -a option.", $sum_file, 1); }

    if($opt_H{"--seq-r"} ne "") { 
	my $seqr_aln = $aln_root2print . $key_out . ".seqr.stk";
	if(!(-e $opt_H{"--seq-r"})) { 
	    PrintErrorAndExit("ERROR, the --seq-r file " . $opt_H{"--seq-r"} . " does not exist.", $sum_file, 1); 
	}
	$command = "$alimanip -o $seqr_aln --seq-r " . $opt_H{"--seq-r"} . " $aln_file";
	RunExecutable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");
	
	#determine number of sequences in the alignment
	my $nali = 0;
	my @nseq_A = ();
	DetermineNumSeqsStockholm($seqstat, $seqr_aln, $log_file, \@nseq_A, \$nali);
	if($nali != 1) { 
	    my $errmsg = "\nERROR, unexpectedly found %d (not 1) alignments in $seqr_aln.\n"; 
	    PrintStringToFile($sum_file, 0, $errmsg);
	    die $errmsg; 
	}
	PrintStringToFile($sum_file, 1, sprintf("  %-*s  %8d\n", $max_width, $seqr_aln, $nseq_A[0]));
    }
    elsif($opt_H{"--seq-k"} ne "") { 
	my $seqk_aln = $aln_root2print . $key_out . ".seqk.stk";
	if(!(-e $opt_H{"--seq-k"})) { 
	    PrintErrorAndExit("ERROR, the --seq-k file " . $opt_H{"--seq-k"} . " does not exist.", $sum_file, 1); 
	}
	$command = "$alimanip -o $seqk_aln --seq-k " . $opt_H{"--seq-k"} . " $aln_file";
	RunExecutable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");

	#determine number of sequences in alignment (just number of sequences in the --seq-klist file) 
	my $nseq = get_num_lines_in_file($opt_H{"--seq-k"}, $sum_file);
	PrintStringToFile($sum_file, 1, sprintf("  %-*s  %8d\n", $max_width, $seqk_aln, $nseq));
    }
}


#############################
# stk2afa mode: Do the work #
#############################
if($do_stk2afa_mode) 
{ 
    # determine max file name width
    my $max_width_afa = length("aligned FASTA file name");
    for($i = 0; $i < $naln; $i++) { 
	$aln_file       = $stk_list_A[$i];
	$aln_root2print = SwapOrAppendFileSuffix($aln_file, \@stk_suffix_A, "", ($opt_H{"-a"}));
	$nec_width = length($aln_root2print) + length($key_out) + 4; #4 is for ".afa"
	if($max_width_afa < $nec_width) { $max_width_afa = $nec_width; }
    }					     
    my $dashes_afa = ""; for($i = 0; $i < $max_width_afa; $i++) { $dashes_afa.= "-"; }
    my $max_width_aln = $max_width_afa - length($key_out); #max_width_aln is max length of a afa file ('.afa' is same # chars as '.stk')
    if($max_width_aln < length("Stockholm aln file name")) { $max_width_aln = length("Stockholm aln file name"); } 
    my $dashes_aln = ""; for($i = 0; $i < $max_width_aln; $i++) { $dashes_aln .= "-"; }

    PrintStringToFile($sum_file, 1, sprintf("#\n# Converting Stockholm alignments to aligned FASTA...\n"));
    PrintStringToFile($sum_file, 1, sprintf("#\n"));
    PrintStringToFile($sum_file, 1, sprintf("# %-*s  %-*s\n", $max_width_aln, "Stockholm aln file name", $max_width_afa, "aligned FASTA file name"));
    PrintStringToFile($sum_file, 1, sprintf("# %-*s  %-*s\n", $max_width_aln, $dashes_aln, $max_width_afa, $dashes_afa));

    my ($afa_file, $afa_file2print, $aln_file2print, $nseq, $command_worked);
    for($i = 0; $i < $naln; $i++) { 
	$aln_file         = $stk_list_A[$i];
	if($opt_H{"-a"}) { # print directory as well as aln name for stockholm alignment, save afa to cwd
	    $aln_file2print = $aln_file;
	    $afa_file       = SwapOrAppendFileSuffix($aln_file, \@stk_suffix_A, $key_out . ".afa", 0);
	    $afa_file2print = $afa_file;
	}
	else { # print no directory for either stk or afa file, save afa file to same dir stk is in
	    $aln_file2print  = RemoveDirPath($aln_file);
	    $afa_file       = SwapOrAppendFileSuffix($aln_file, \@stk_suffix_A, $key_out . ".afa", 1);
	    $afa_file2print = RemoveDirPath($afa_file);
	}
	$command = "$reformat -o $afa_file --informat stockholm afa $aln_file"; 
	RunExecutable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");

	PrintStringToFile($sum_file, 1, sprintf("  %-*s  %-*s\n", $max_width_aln, $aln_file2print, $max_width_afa, $afa_file2print));
    }
}


############
# Conclude #
############
my $dir2print = "";
if(! $opt_H{"-a"}) {  
    $dir2print = $dir;
    if($do_filter_mode) {
	my $fil_key2print = $key_out . "." . "fil";
	$fil_key2print =~ s/\.//;
	PrintStringToFile($sum_file, 1, sprintf("#\n# To mask these alignments run ssu-mask with the option \"--key-in $fil_key2print\"\n"));
    }
}

if($do_mask_mode) { 
    PrintStringToFile($sum_file, 1, sprintf("#\n"));
    if    ($ssdraw_worked_at_least_once && (! $ssdraw_failed_at_least_once)) { 
	PrintStringToFile($sum_file, 1, sprintf("# All attempts to draw structure diagrams of masks were successful.\n"));
    }
    elsif($ssdraw_worked_at_least_once && $ssdraw_failed_at_least_once) { 
	PrintStringToFile($sum_file, 1, sprintf("# Some, but not all, attempts to draw structure diagrams of masks were successful.\n"));
    }
    elsif((! $ssdraw_worked_at_least_once) && (! $ssdraw_failed_at_least_once)) { 
	PrintStringToFile($sum_file, 1, sprintf("# No structure diagrams were attempted. Unable to locate default template file.\n"));
    }
    elsif((! $ssdraw_worked_at_least_once) && $ssdraw_failed_at_least_once) { 
	if(($opt_H{"-m"} eq "") && (! $opt_H{"-a"})) { 
	    PrintStringToFile($sum_file, 1, sprintf("# All attempts to draw structure diagrams failed.\n# This shouldn't happen, but masking was unaffected.\n"));
	}
	elsif ($opt_H{"-a"}) {
	    PrintStringToFile($sum_file, 1, sprintf("# All attempts to draw structure diagrams failed.\n# Input alignment must have been created with a non-default, user-created model.\n"));
	}
	elsif ($opt_H{"-m"} ne "") { 
	    PrintStringToFile($sum_file, 1, sprintf("# All attempts to draw structure diagrams failed.\n# " . $opt_H{"-m"} . " must contain non-default, user-created model(s).\n"));
	}
    }
}

# remove temporary files, if any
my $file;
foreach $file (@files_to_unlink_A) { 
    UnlinkFile($file, $log_file);
}

$total_seconds += SecondsSinceEpoch($time_hires_installed);
PrintConclusion($sum_file, $log_file, $sum_file2print, $log_file2print, $total_seconds, $time_hires_installed, $dir2print);

# Success! Exit normally
exit(0);


###############
# Subroutines #
###############


#####################################################################
# Subroutine: validate_and_setup_ssu_mask()
# Incept:     EPN, Mon Nov  3 15:05:56 2008
# 
# Purpose:    Validate that: 
#             - the CM file exists. 
#             - the required executable programs exist.
#             - there is at least 1 alignment in $dir directory
#               to operate on
#
# Arguments: 
# $ssualigndir:       dir defined by SSUALIGNDIR environment variable 
# $dir:               the directory we will create files in
# $key_in:            "" or a key that is included in input file names, just prior to the suffix
#                     e.g. $key_in = "fookey", $dir = "foodir", aln file is foodir/foodir.archaea.fookey.stk
# $opt_HR:            reference to the hash of command-line options
# $cm_file_ref:       RETURN; the path to the CM file, either default CM file or $opt_HR->{"-m"}
# $template_file_ref: RETURN; the path to the template file, either default template file or $opt_HR->{"-t"}
# $alimanip_ref:      RETURN; the esl-alimanip command
# $ssdraw_ref:        RETURN; the esl-ssdraw command
# $weight_ref:        RETURN; the esl-weight command, only relevant if --filter enabled
# $seqstat_ref:       RETURN; the esl-seqstat command, only relevant if --filter enabled
# $reformat_ref:      RETURN; the esl-reformat command, only relevant if --afa, --only-afa, or --stk2afa enabled
# $stk_list_arr_ref:  RETURN: ref to array of alignment files to operate on
# $log_file:          the log file
# $sum_file:          the summary file
#
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If any of the above validations do not occur, we
#             print a message to STDERR explaining why it's
#             exiting early and then exit with non-zero status.
#
####################################################################
sub validate_and_setup_ssu_mask { 
    my $narg_expected = 14;
    if(scalar(@_) != $narg_expected) { printf STDERR ("\nERROR, validate_and_setup_ssu_mask() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($ssualigndir, $dir, $key_in, $opt_HR, $cm_file_ref, $template_file_ref, $alimanip_ref, $ssdraw_ref, $weight_ref, $seqstat_ref, $reformat_ref, $stk_list_arr_ref) = @_;

    #Validate that we can read the CM file
    my $cm_file = "";
    if($opt_HR->{"-m"} ne "") {
	$cm_file = $opt_HR->{"-m"};
	if(!(-e $cm_file)) { PrintErrorAndExit("ERROR, CM file $cm_file, specified with -m does not exist.", $sum_file, 1); }
    }
    else { # -m not enabled, assume the user used the default CM file:
	$cm_file = $ssualigndir . "/ssu-align-0p1.cm";
	if(!(-e $cm_file)) { PrintErrorAndExit("ERROR, the default CM file $cm_file does not exist.\nIf you used a different CM file to create the alignments in $dir, use the -m option.", $sum_file, 1); }
    }

    #if --in-mask <s> enabled, verify that <s> exists
    if($opt_HR->{"--in-mask"} ne "") { 
	if(!(-e $opt_HR->{"--in-mask"})) { PrintErrorAndExit("ERROR, mask file " . $opt_HR->{"--in-mask"} . ", specified with --in-mask does not exist.", $sum_file, 1); }
    }	

    #Validate that we can read the template postscript diagram file, if we can't that's okay but only if a non-default CM has been specified with -m.
    if($opt_HR->{"-t"} ne "") { 
	$template_file = $opt_HR->{"-t"};
	if(!(-e $template_file)) { PrintErrorAndExit("ERROR, template postscript file $template_file, specified with -t does not exist.", $sum_file, 1); }
    }
    elsif($opt_HR->{"-m"} eq "") { # -t not enabled and -m not enabled, we assume default template file should exist for the default CM file
	$template_file = $ssualigndir . "/ssu-align-0p1.ps";
	if(!(-e $template_file)) { PrintErrorAndExit("ERROR, the default template file $template_file does not exist and you did not specify a non-default CM file with -m.\nIf you used a non-default CM file, use -m.\nIf you want to use a non-default structure template file use -t.", $sum_file, 1); }
    }
    else { #-m enabled, -t not enabled: with this combo if the default template file exists we'll try to do ssu-align with it,
	   # if not, then we can still do masking but we won't try to call ssu-draw
	#check if default template exists:
	$template_file = "";
	if(-e ($ssualigndir . "/ssu-align-0p1.ps")) { 
	    $template_file = $ssualigndir . "/ssu-align-0p1.ps";
	}
    }
    #Validate that esl-alimanip and esl-ssdraw (if we need it) exist
    my $alimanip = "ssu-esl-alimanip";
    my $command_worked;
    RunExecutable("$alimanip -h > /dev/null", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $alimanip is not in your PATH environment\nvariable. See the User's Guide Installation section.");;

    my $ssdraw = "";
    if($template_file ne "") { 
	$ssdraw = "ssu-esl-ssdraw";
	RunExecutable("$ssdraw -h > /dev/null", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $ssdraw is not in your PATH environment\nvariable. See the User's Guide Installation section.");;
    }

    #Validate that 'esl-weight' and 'esl-seqstat' exist if --filter enabled.
    my $weight = "";
    my $seqstat = "";
    if($opt_HR->{"--filter"} ne "") { 
	$weight = "ssu-esl-weight";
	RunExecutable("$weight -h > /dev/null", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $weight (required b/c --filter enabled) is not in your PATH environment\nvariable. See the User's Guide Installation section.");;
	$seqstat = "ssu-esl-seqstat";
	RunExecutable("$seqstat -h > /dev/null", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $seqstat (required b/c --filter enabled) is not in your PATH environment\nvariable. See the User's Guide Installation section.");;
    }

    #Validate that 'esl-seqstat' works if --seq-r or --seq-k
    if(($opt_H{"--seq-r"} ne "") || ($opt_H{"--seq-k"})) { 
	$seqstat = "ssu-esl-seqstat";
	RunExecutable("$seqstat -h > /dev/null", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $seqstat (required b/c --seq-r or --seq-k enabled) is not in your PATH environment\nvariable. See the User's Guide Installation section.");;
    }	


    #Validate that 'esl-reformat' works if --afa, --only-afa, or --stk2afa
    my $reformat = "";
    if(($opt_H{"--afa"}) || ($opt_H{"--only-afa"}) || ($opt_H{"--stk2afa"})) { 
	$reformat = "ssu-esl-reformat";
	RunExecutable("$reformat -h > /dev/null", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $reformat (required b/c --afa, --only-afa or --stk2afa enabled) is not in your PATH environment\nvariable. See the User's Guide Installation section.");;
    }	

    my $naln = 0;
    my $errmsg = "";
    my ($aln_name, $alist_file);
    if($opt_HR->{"-a"}) { # special mode, single command line argument is not a directory, it's an alignment
	$aln_name = $dir;
	if(! (-e $aln_name)) { 
	    PrintErrorAndExit("ERROR, the alignment file $aln_name does not exist.", $sum_file, 1); 
	}
	push(@{$stk_list_arr_ref}, $aln_name);
	$naln = 1; 
    }
    else { 
	# Validate there is at least 1 alignment in the input dir
	if(! (-d $dir)) { 
	    if(-e $dir) { 
		PrintErrorAndExit("ERROR, the command-line argument $dir is a file, not a directory.\nIt should be the directory that includes the input alignment files,\nor if you want to operate on a single alignment, use the -a option.", $sum_file, 1); 
	    }
	    else { 
		PrintErrorAndExit("ERROR, the directory $dir with input alignment files does not exist.", $sum_file, 1); 
	    }
	}
	my ($name, $line);
	my @names_A = ();
	open(CM, $cm_file) || FileOpenFailure($cm_file, $sum_file, $!, "reading");
	while($line = <CM>) { 
	    if($line =~ s/NAME\s+//) { 
		chomp $line;
		push(@names_A, $line);
	    }
	}
	close(CM);
	foreach $name (@names_A) { 
	    $aln_name = $dir . "/" . $dir . "." . $name . $key_in . ".stk";
	    if(-e $aln_name) { 
		push(@{$stk_list_arr_ref}, $aln_name);
		$naln++; 
	    }
	}
	if($naln == 0) { 
	    $errmsg = "ERROR, found 0 alignments created by ssu-align using the CM file $cm_file\nin directory $dir.\n\n";
	    PrintStringToFile($sum_file, 0, $errmsg);
	    printf STDERR $errmsg;
	    $errmsg = "The following alignments were searched for, but none were found:\n";
	    PrintStringToFile($sum_file, 0, $errmsg);
	    printf STDERR $errmsg;
	    foreach $name (@names_A) { 
		$aln_name = $dir . "/" . $dir . "." . $name . $key_in . ".stk";
		$errmsg = "\t$aln_name\n";
		PrintStringToFile($sum_file, 0, $errmsg);
		printf STDERR $errmsg;
	    }
	    exit(1);
	}
    }

    $$cm_file_ref       = $cm_file;
    $$template_file_ref = $template_file;
    $$alimanip_ref      = $alimanip;
    $$ssdraw_ref        = $ssdraw;
    $$weight_ref        = $weight;
    $$seqstat_ref       = $seqstat;
    $$reformat_ref      = $reformat;
    
    return;
}

#####################################################################
# Subroutine: write_union_of_masks()
# Incept:     EPN, Thu Sep 24 14:11:40 2009
# 
# Purpose:    Given two mask files of equal length, write a new 
#             mask file that is the 'union' of them both, defined
#             as, any column that is excluded from either mask
#             (a '0') is excluded from the union mask.
#
# Arguments: 
#   $mask1_file:      file name with mask 1.
#   $mask1_file:      file name with mask 2.
#   $union_mask_file: file name for outputting union to.
#   $sum_file:        summary file
#
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If anything unexpected occurs, print a message to 
#             STDERR explaining why we're exiting early and then 
#             exit with non-zero status.
#
####################################################################
sub write_union_of_masks {
    my $narg_expected = 4;
    if(scalar(@_) != $narg_expected) { printf STDERR ("\nERROR, write_union_of_masks() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($mask1_file, $mask2_file, $union_mask_file, $sum_file) = @_;

    open(MASK1, $mask1_file) || FileOpenFailure($mask1_file, $sum_file, $!, "reading");
    my $mask1 = <MASK1>;
    chomp $mask1;
    my @mask1_A = split("", $mask1);
    close(MASK1);

    open(MASK2, $mask2_file) || FileOpenFailure($mask2_file, $sum_file, $!, "reading");
    my $mask2 = <MASK2>;
    chomp $mask2;
    my @mask2_A = split("", $mask2);
    close(MASK2);

    my $mask1_len = scalar(@mask1_A); 
    my $mask2_len = scalar(@mask2_A); 
    if($mask1_len != $mask2_len) { PrintErrorAndExit("ERROR, when trying to create the union of $mask1_file and $mask2_file, their lengths differ: $mask1_len != $mask2_len.", $sum_file, 1); }

    my ($i, $combo);
    my $umask = "";
    for($i = 0; $i < $mask1_len; $i++) 
    { 
	$combo = $mask1_A[$i] . $mask2_A[$i];
	if   ($combo eq "11") { $umask .= "1"; }
	elsif($combo eq "10") { $umask .= "0"; }
	elsif($combo eq "01") { $umask .= "0"; }
	elsif($combo eq "00") { $umask .= "0"; }
	else { PrintErrorAndExit(sprintf("ERROR, a non-1/0 character found in $mask1_file or $mask2_file at position %d", ($i+1)), $sum_file, 1); }
    }
    
    open(OUT, ">" . $union_mask_file) || FileOpenFailure($union_mask_file, $sum_file, $!, "writing");
    printf OUT ($umask . "\n");
    close(OUT);

    return;
}

#####################################################################
# Subroutine: summarize_mask()
# Incept:     EPN, Thu Sep 24 15:42:44 2009
# 
# Purpose:    Given a mask file, return the number of 0s and 1s
#             in the file.
#
# Arguments: 
#   $mask_file: file name with mask in it.
#   $n0_ref:    RETURN: number of 0s in mask file
#   $n1_ref:    RETURN: number of 1s in mask file
#   $sum_file:  ssu-mask summary file
# 
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If anything unexpected occurs, print a message to 
#             STDERR explaining why we're exiting early and then 
#             exit with non-zero status.
#
####################################################################
sub summarize_mask {
    my $narg_expected = 4;
    if(scalar(@_) != $narg_expected) { printf STDERR ("\nERROR, summarize_mask() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($mask_file, $n0_ref, $n1_ref, $sum_file) = @_;

    open(MASK, $mask_file) || FileOpenFailure($mask_file, $sum_file, $!, "reading");
    my $mask = <MASK>;
    close(MASK);
    chomp $mask;
    my $n1 = length($mask);
    my $n0 = ($mask =~ tr/0//);
    $n1 -= $n0;
    # make sure there aren't extra characters
    $mask =~ s/0//g;
    $mask =~ s/1//g;
    if($mask ne "") { 
	PrintErrorAndExit("\nERROR, mask in file $mask_file has non-1/0 chars.\n", $sum_file, 1);
	# above call will call exit() to kill program
    }

    $$n1_ref = $n1;
    $$n0_ref = $n0;
    return;
}


#####################################################################
# subroutine: mask_alignment()
# incept:     EPN, Fri Sep 25 13:30:51 2009
# 
# Purpose:    Mask an alignment using the easel miniapp esl-alimanip.
#
# Arguments:  
#   $alimanip:            path and name of esl-alimanip/ssu-esl-alimanip executable
#   $opt_HR:              reference to the hash of command-line options
#   $ssdraw:              path and name of esl-ssdraw/ssu-esl-ssdraw executable
#   $mask_root:           name for mask-related files, e.g. 'cmask'
#   $aln_file2mask:       name of alignment file to mask, with path
#   $aln_file_for_naming: name of alignment file to use for naming new ones
#   $stk_suffix_AR:       reference to array of legal stockholm suffixes
#   $keep_mask:           '1' to keep 'mask' file output from esl-alimanip
#   $print_input_aln:     '1' to print info on input alignment to the screen
#   $mask_opts:           string of options to pass to esl-alimanip
#   $rfmask_file2use:     name of file to use as argument with --mask-rf to esl-alimanip
#   $allmask_file2use:    name of file to use as argument with --mask-all to esl-alimanip
#   $do_draw:             '1' to draw masks with esl-ssdraw
#   $max_width:           width of output string for printing output file names
#   $mask_ok_if_fails:    '1' if we keep going upon a esl-alimanip failure, '0' to exit
#                         if esl-alimanip fails with non-0 return code.
#   $template_file:       path to template file needed by esl-ssdraw
#   $n0_R:                RETURN; number of 0s in computed mask
#   $n1_R:                RETURN; number of 1s in computed mask
#   $masked_stk_file_R:   RETURN; name of masked alignment file just created
#   $mask_file_R:         RETURN; name of mask file just created
#   $ssdraw_worked_R:     RETURN; '1' if esl-ssdraw successfully run, else '0'
#   $files_to_unlink_AR:  REFERENCE to array of files to unlink
#   $sum_file:            file to print output file notices to
#   $log_file:            log file
# 
# Returns:  Nothing, if it returns, everything is valid.
# 
####################################################################
sub mask_alignment { 
    my $narg_expected = 24;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, mask_alignment() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($alimanip, $opt_HR, $ssdraw, $mask_root, $aln_file2mask, $aln_file_for_naming, $stk_suffix_AR, $keep_mask, $print_input_aln, 
	$mask_opts, $rfmask_file2use, $allmask_file2use, $do_draw, $max_width, $mask_ok_if_fails, $template_file, 
	$n0_R, $n1_R, $masked_stk_file_R, $mask_file_R, $ssdraw_worked_R, $files_to_unlink_AR, $sum_file, $log_file) = @_;

    if(($rfmask_file2use ne "") && ($allmask_file2use ne "")) { 
	PrintErrorAndExit("ERROR, mask_alignment() entered with both \$rfmask_file2use ($rfmask_file2use) and \$allmask_file2use $allmask_file2use defined.\nThese are incompatible: one must be the empty string.", $sum_file, 1); 
    } 	

    my($masked_stk_file, $mask_file, $masked_stk_file2print, $mask_file2print, $masked_afa_file, $masked_afa_file2print, $aln_file2mask2print);
    my($n0, $n1, $is_final, $extra_opts, $ssdraw_failed, $command_worked, $mask_suffix);

    # Determine names for output files
    if($mask_root eq "mask") { $is_final = 1; $mask_suffix = $key_out . ".mask"; }
    else                     { $is_final = 0; $mask_suffix = $key_out . "." . $mask_root . ".mask"; }

    if($opt_H{"-a"}) { # print directory as well as aln name for input alignment, save masked alns to CWD
	$aln_file2mask2print   = $aln_file2mask;;
	$masked_stk_file       = SwapOrAppendFileSuffix($aln_file_for_naming, \@stk_suffix_A, $key_out . "." . $mask_root . ".stk", 0);
	$masked_stk_file2print = $masked_stk_file;
	$masked_afa_file       = SwapOrAppendFileSuffix($aln_file_for_naming, \@stk_suffix_A, $key_out . "." . $mask_root . ".afa", 0);
	$masked_afa_file2print = $masked_afa_file;
	$mask_file             = SwapOrAppendFileSuffix($aln_file_for_naming, \@stk_suffix_A, $mask_suffix, 0);
	$mask_file2print       = $mask_file;

    }
    else { # do not print directories of input alignment, save masked alns to same directory where input alignment is
	$aln_file2mask2print   = RemoveDirPath($aln_file2mask);
	$masked_stk_file       = SwapOrAppendFileSuffix($aln_file_for_naming, \@stk_suffix_A, $key_out . "." . $mask_root . ".stk", 1);
	$masked_stk_file2print = RemoveDirPath($masked_stk_file);
	$masked_afa_file       = SwapOrAppendFileSuffix($aln_file_for_naming, \@stk_suffix_A, $key_out . "." . $mask_root . ".afa", 1);
	$masked_afa_file2print = RemoveDirPath($masked_afa_file);
	$mask_file             = SwapOrAppendFileSuffix($aln_file_for_naming, \@stk_suffix_A, $mask_suffix, 1);
	$mask_file2print       = RemoveDirPath($mask_file);
    }

    # Commands from previous implementation (for reference)
    # cmask: $command = "$alimanip -k --num-rf --kmask $cmask_file -o $cmasked_stk_file $aln_file2mask";
    # pmask: $command = "$alimanip --p-rf --pf $opt_HR->{"--pf"} --pt $opt_HR->{"--pt"} -k --kmask $pmask_file -o $pmasked_stk_file $cmasked_stk_file";
    # gmask: $command = "$alimanip --verbose -g --gapthresh $opt_HR->{"--gapthresh"} -k --kmask $gmask_file -o $gmasked_stk_file $cmasked_stk_file";
    # pgmask:$command = "$alimanip -k --mask-rf $pgmask_file -o $pgmasked_stk_file $cmasked_stk_file";
    if   ($rfmask_file2use ne "")  { $extra_opts = "--mask-rf $rfmask_file2use";  $mask_file = $rfmask_file2use; }
    elsif($allmask_file2use ne "") { $extra_opts = "--mask-all $allmask_file2use"; $mask_file = $allmask_file2use; }
    else                           { $extra_opts = "--kmask $mask_file"; }
    if($opt_HR->{"-1"})            { $extra_opts .= " -1"; }
    $command = "$alimanip $mask_opts $extra_opts -o $masked_stk_file $aln_file2mask";
    my $errmsg = "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.";
    my $die_if_fails = 1;
    if($mask_ok_if_fails) { 
	$errmsg = "";
	$die_if_fails = 0;
    }
    RunExecutable("$command", $die_if_fails, $die_if_fails, $log_file, \$command_worked, $errmsg);
    if(! $command_worked) { return 0; } #if (! $mask_ok_if_fails), RunExecutable will cause death if (! $command_worked)

    summarize_mask($mask_file, \$n0, \$n1, $sum_file); 

    if($print_input_aln) { 
	PrintStringToFile($sum_file, 1, sprintf("  %-*s  %6s  %4s  %5s  %5s  %5s\n", $max_width, $aln_file2mask2print, "input", "aln", ($n0+$n1), "-", "-"));
    }

    my $ssdraw_worked = 0;
    if($do_draw) { 
	# Draw the mask, if we can, if we can't that's okay just alert the caller by setting $ssdraw_worked = 0
	my $do_column_breakdown = 1;
	$ssdraw_worked = run_ssdraw_for_ssu_mask($ssdraw, $template_file, "--mask-col --mask $mask_file", $aln_file2mask, $aln_file_for_naming, $stk_suffix_AR,
						 $key_out, $mask_root, $max_width, $opt_HR, $n0, $n1, $do_column_breakdown, $files_to_unlink_AR, $sum_file, $log_file);
    }

    if((($rfmask_file2use ne "") || ($allmask_file2use ne "")) 
       || ($opt_HR->{"--keep"} || $keep_mask || $is_final)) { 
	PrintStringToFile($sum_file, 1, sprintf("  %-*s  %6s  %4s  %5s  %5s  %5s\n", $max_width, $mask_file2print, "output", "mask", ($n0+$n1), $n1, $n0));
	if(!($opt_HR->{"--only-afa"})) { 
	    PrintStringToFile($sum_file, 1, sprintf("  %-*s  %6s  %4s  %5s  %5s  %5s\n", $max_width, $masked_stk_file2print, "output", "aln", $n1, "-", "-"));
	}
	else { # --only-afa enabled, we'll remove the masked stk file at end of execution
	    push(@{$files_to_unlink_AR}, $masked_stk_file);
	}

	if(($opt_HR->{"--afa"}) || ($opt_HR->{"--only-afa"})) { # convert stk to afa
	    $command = "$reformat -o $masked_afa_file --informat stockholm afa $masked_stk_file"; 
	    RunExecutable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");
	    PrintStringToFile($sum_file, 1, sprintf("  %-*s  %6s  %4s  %5s  %5s  %5s\n", $max_width, $masked_afa_file2print, "output", "aln", $n1, "-", "-"));
	}
    }
    else { # these files are not permanent, we'll remove them at end of execution
	push(@{$files_to_unlink_AR}, $mask_file);
	push(@{$files_to_unlink_AR}, $masked_stk_file);
    }

    $$n0_R = $n0;
    $$n1_R = $n1;
    $$masked_stk_file_R = $masked_stk_file;
    $$mask_file_R = $mask_file;
    $$ssdraw_worked_R = $ssdraw_worked;
    return 1;
}    


#####################################################################
# Subroutine: filter_alignment()
# Incept:     EPN, Tue Oct  6 13:17:54 2009
# 
# Purpose:    Filter an alignment based on sequence identity with
#             a call to the esl-weight program.
#
# Arguments:  
#   $weight:                path and name of esl-weight/ssu-esl-weight executable
#   $seqstat:               path and name of esl-weight/ssu-esl-seqstat executable
#   $opt_HR:                reference to the hash of command-line options
#   $filter_root:           name for mask-related files, usually 'f'
#   $aln_file2filter:       name of alignment file to filter, with path
#   $key_out:               for inclusion in output file names
#   $stk_suffix_AR:         reference to array of legal stockholm suffixes
#   $max_width_in:          width of output string for input alignment file names
#   $max_width_fil:         width of output string for filtered alignment file names
#   $files_to_unlink_AR:    REFERENCE to array of files to unlink
#   $sum_file:              file to print output notices to
#   $log_file:              log file for printing commands
# 
# Returns:  Nothing, if it returns, everything is valid.
#
####################################################################
sub filter_alignment { 
    my $narg_expected = 12;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, filter_alignment() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($weight, $seqstat, $opt_HR, $filter_root, $aln_file2filter, $key_out, $stk_suffix_AR, $max_width_in, $max_width_fil, $files_to_unlink_AR, $sum_file, $log_file) = @_;

    my($filtered_stk_file, $nseq_input, $nseq_filtered, $filtered_stk_file2print, $command_worked, $filtered_afa_file, $filtered_afa_file2print, $aln_file2filter2print); 

    if($opt_H{"-a"}) { # save new alignments to CWD, regardless of where original alignment exists
	$aln_file2filter2print   = $aln_file2filter;
	$filtered_stk_file       = SwapOrAppendFileSuffix($aln_file2filter, \@stk_suffix_A, $key_out . "." . $filter_root . ".stk", 0);
	$filtered_stk_file2print = $filtered_stk_file;
	$filtered_afa_file       = SwapOrAppendFileSuffix($aln_file2filter, \@stk_suffix_A, $key_out . "." . $filter_root . ".afa", 0);
	$filtered_afa_file2print = $filtered_afa_file;
    }
    else { # save new alignments to same directory as alignment we're filtering, but don't print the dir path prefix
	$aln_file2filter2print   = RemoveDirPath($aln_file2filter);
	$filtered_stk_file       = SwapOrAppendFileSuffix($aln_file2filter, \@stk_suffix_A, $key_out . "." . $filter_root . ".stk", 1);
	$filtered_stk_file2print = RemoveDirPath($filtered_stk_file);
	$filtered_afa_file       = SwapOrAppendFileSuffix($aln_file2filter, \@stk_suffix_A, $key_out . "." . $filter_root . ".afa", 1);
	$filtered_afa_file2print = RemoveDirPath($filtered_afa_file);
    }    
    my @nseq_A = ();
    my $nali = 0;
    DetermineNumSeqsStockholm($seqstat, $aln_file2filter, $log_file, \@nseq_A, \$nali);
    if($nali != 1) { die "\nERROR, unexpectedly found %d (not 1) alignments in $aln_file2filter.\n"; }
    $nseq_input = $nseq_A[0];

    # esl-weight -f --idf 0.75 10.stk
    if($opt_HR->{"--filter"} < 0.) { PrintErrorAndExit(sprintf("ERROR, with --filter <f>, <f> must be between 0.0 and 1.0, you entered %.4f.\n", $opt_HR->{"--filter"}), $sum_file, 1); }
    if($opt_HR->{"--filter"} > 1.) { PrintErrorAndExit(sprintf("ERROR, with --filter <f>, <f> must be between 0.0 and 1.0, you entered %.4f.\n", $opt_HR->{"--filter"}), $sum_file, 1); }
    $command = "$weight -o $filtered_stk_file -f --idf " . $opt_HR->{"--filter"} . " $aln_file2filter";
    RunExecutable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");
    @nseq_A = ();
    DetermineNumSeqsStockholm($seqstat, $filtered_stk_file, $log_file, \@nseq_A, \$nali);
    if($nali != 1) { 
	my $errmsg = "\nERROR, unexpectedly found %d (not 1) alignments in $filtered_stk_file.\n"; 
	PrintStringToFile($sum_file, 0, $errmsg);
	die $errmsg; 
    }

    $nseq_filtered = $nseq_A[0];

    if(!($opt_HR->{"--only-afa"})) { 
	PrintStringToFile($sum_file, 1, sprintf("  %-*s  %8d  %-*s  %8d\n", $max_width_in, $aln_file2filter2print, $nseq_input, $max_width_fil, $filtered_stk_file2print, $nseq_filtered));
    }
    else { # --only-afa enabled, remove the stk filtered file eventually
	push(@{$files_to_unlink_AR}, $filtered_stk_file2print);
    }

    if(($opt_HR->{"--afa"}) || ($opt_HR->{"--only-afa"})){ 
	$command = "$reformat -o $filtered_afa_file --informat stockholm afa $filtered_stk_file"; 
	RunExecutable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");
	PrintStringToFile($sum_file, 1, sprintf("  %-*s  %8d  %-*s  %8d\n", $max_width_in, $aln_file2filter2print, $nseq_input, $max_width_fil, $filtered_afa_file2print, $nseq_filtered));
    }
    return 1;
}    


#####################################################################
# Subroutine: run_ssdraw_for_ssu_mask
# Incept:     EPN, Tue Oct 13 07:15:09 2009
# 
# Purpose:    Call esl-ssdraw for a given alignment and template file.
#             Try to convert the postscript to pdf.
#
# Arguments:
#   $ssdraw:              path and name of esl-alimanip/ssu-esl-alimanip executable
#   $template_file:       name of template file to use
#   $ssdraw_opts:         string defining options for esl-ssdraw call
#   $aln_file:            alignment file to draw
#   $aln_file_for_naming: alignment file to use to derive names of ps, pdf files
#   $stk_suffix_AR:       reference to array of legal stockholm suffixes
#   $key_out:             optional extra key for output files
#   $draw_key:            another optional extra key for output files
#   $max_width:           width of output string for printing output file names
#   $opt_HR:              REFERENCE to hash of command-line options
#   $n0:                  number of 0s in the mask (passed in)
#   $n1:                  number of 1s in the mask (passed in)
#   $do_column_breakdown: TRUE to print number of columns included vs excluded in output
#   $files_to_unlink_AR:  REFERENCE to array of files to unlink
#   $sum_file:            file to print output notices to
#   $log_file:            log file
#
# Returns:    '1' if esl-ssdraw worked (exited cleanly (returned 0)), 
#             '0' if it did not work (returned non-0 value)
# 
####################################################################
sub run_ssdraw_for_ssu_mask { 
    my $narg_expected = 16;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, run_ssdraw_for_ssu_mask() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($ssdraw, $template_file, $ssdraw_opts, $aln_file, $aln_file_for_naming, $stk_suffix_AR, $key_out, 
	$draw_key, $max_width, $opt_HR, $n0, $n1, $do_column_breakdown, $files_to_unlink_AR, $sum_file, $log_file) = @_;

    my($draw_ps, $draw_pdf, $draw_ps2print, $draw_pdf2print, $command_worked);
    
    if($opt_H{"-a"}) { # save diagrams to CWD
	$draw_ps        = SwapOrAppendFileSuffix($aln_file_for_naming, \@stk_suffix_A, $key_out . "." . $draw_key . ".ps", 0);
	$draw_ps2print  = $draw_ps;
	$draw_pdf       = SwapOrAppendFileSuffix($aln_file_for_naming, \@stk_suffix_A, $key_out . "." . $draw_key . ".pdf", 0);
	$draw_pdf2print = $draw_pdf;
    }
    else { # save diagrams to same dir as aln
	$draw_ps        = SwapOrAppendFileSuffix($aln_file_for_naming, \@stk_suffix_A, $key_out . "." . $draw_key . ".ps", 1);
	$draw_ps2print  = RemoveDirPath($draw_ps);
	$draw_pdf       = SwapOrAppendFileSuffix($aln_file_for_naming, \@stk_suffix_A, $key_out . "." . $draw_key . ".pdf", 1);
	$draw_pdf2print = RemoveDirPath($draw_pdf);
    }
    
    my $command = "$ssdraw $ssdraw_opts $aln_file $template_file $draw_ps";
    my $die_if_fails = 0;
    my $print_output_upon_failure = 0;
    RunExecutable("$command", $die_if_fails, $print_output_upon_failure, $log_file, \$command_worked, "");

    if(! $command_worked) { # it didn't work, don't exit just alert caller by returning 0
	return 0; 
    } 

    # unless --ps-only, try ps2pdf, it's okay if it doesn't work (unless --ps2pdf, in which case its not ok)
    my $keep_ps = 1;
    if(! $opt_HR->{"--ps-only"}) { 
	my $ps2pdf;
	if($opt_HR->{"--ps2pdf"} ne "") { $ps2pdf = $opt_HR->{"--ps2pdf"}; }
	else                            { $ps2pdf = "ps2pdf"; }
	$die_if_fails = 0;
	$print_output_upon_failure = 0;
	my $errmsg = "";
	if($opt_HR->{"--ps2pdf"} ne "") { 
	    $die_if_fails = 1; 
	    $errmsg = "ERROR, --ps2pdf " . $opt_HR->{"--ps2pdf"} . " was enabled, but command $command did not work."; 
	}
	TryPs2Pdf($ps2pdf, $draw_ps, $draw_pdf, $die_if_fails, $print_output_upon_failure, $log_file, \$command_worked, $errmsg);
	
	if($command_worked) { 
	    if($do_column_breakdown) { 
		PrintStringToFile($sum_file, 1, sprintf("  %-*s  %6s  %4s  %5s  %5s  %5s\n", $max_width, $draw_pdf2print, "output", "pdf", ($n0+$n1), $n1, $n0));
	    }
	    else { 
		PrintStringToFile($sum_file, 1, sprintf("  %-*s  %6s  %4s  %5s  %5s  %5s\n", $max_width, $draw_pdf2print, "output", "pdf", ($n0+$n1), "-", "-"));
	    }
	    # if --ps-keep is not enabled and we successfully have the pdf ($command_worked above), remove the ps eventually
	    if(! $opt_HR->{"--ps-keep"}) { 
		$keep_ps = 0;
	    }
	}
    }
    if($keep_ps) { # $keep_ps is set to 0 only if we successfully make a pdf above and --ps-keep was not enabled
	if($do_column_breakdown) { 
	    PrintStringToFile($sum_file, 1, sprintf("  %-*s  %6s  %4s  %5s  %5s  %5s\n", $max_width, $draw_ps2print, "output", "ps", ($n0+$n1), $n1, $n0));
	}
	else { 
	    PrintStringToFile($sum_file, 1, sprintf("  %-*s  %6s  %4s  %5s  %5s  %5s\n", $max_width, $draw_ps2print, "output", "ps", ($n0+$n1), "-", "-"));
	}
    }
    else { # we'll remove the ps eventually
	push(@{$files_to_unlink_AR}, $draw_ps);
    }
    return 1; #if ssdraw failed we returned 0 above
}


###########################################################
# Subroutine: get_num_lines_in_file
# Incept: EPN, Mon Nov  2 10:12:08 2009
#
# Purpose: Determine the number of '\n' delimited lines
#          in a file. Print out error message to summary
#          file and die with error message if the file
#          does not exist.
#
# Returns: Number of lines in the file. 
#          If the file can't be opened we die.
#
###########################################################
sub get_num_lines_in_file {
    my $narg_expected = 2;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, get_num_lines_in_file() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($filename, $sum_file) = $_[0];

    my $line;
    my $nlines = 0;
    open(IN, $filename) || FileOpenFailure($filename, $sum_file, $!, "reading");

    while($line = <IN>) { $nlines++; }
    close(IN);

    return $nlines;
}

    

