#!/usr/bin/perl
#
# ssu-align
# Eric Nawrocki
# EPN, Wed Oct 29 10:12:05 2008
#
# Usage: ssu-align [options] <target database sequence file name> <output root for output files>
#             
# Synopsis:
#
# Aligns SSU sequences to SSU CMs.
# Given a CM file with >=1 SSU CMs and a target sequence file with putative
# SSU sequences: 
#
# Step 1. Define likely start/ends (seq boundaries) to align using cmsearch 
#         in viterbi HMM mode (or forward HMM mode if --forward).
# Step 2. Extract those subsequences into a new target fasta file using
#         esl-sfetch.
# Step 3. Align sequences in new fasta file from step 2 to the corresponding CM
#         using cmalign.
#
# If x CMs exist, with x > 1, in the CM file, then x new subsequence files 
# are created in Step 2, one for each CM and containing the sequences that
# score highest to that CM. Then in Step 3, each CM is used to align its 
# target file. For example the CM file may contain archael, bacterial, and 
# eukaryotic CMs, and step 1 will 'classify' each seq as arc, bac, or euk, 
# and then in Step 3 the appropriate CM is used to align each sequence. 
#
# See definition of $options_usage for options, below.
#
use Getopt::Long;
use Cwd 'abs_path';
use strict;
use warnings;

#Make sure the SSUALIGNDIR environmental variable is set and the directory exists
my $ssualigndir = $ENV{'SSUALIGNDIR'};
if(! exists($ENV{'SSUALIGNDIR'})) { 
    printf STDERR ("ERROR, the environment variable SSUALIGNDIR is not set, please set it to the directory where you installed SSU-ALIGN.\n"); 
    exit(1); 
}
if(! (-d $ssualigndir)) { 
    printf STDERR ("ERROR, the ssu-align directory specified by your environment variable SSUALIGNDIR does not exist, see the User's Guide Installation section.\n"); 
    exit(1); 
}    
#Make sure the SSUALIGNDIR directory includes ssu-subs.pm
my $subs_file = $ssualigndir . "/ssu-subs.pm";
if(! (-e $subs_file)) { 
    printf STDERR ("ERROR, the required perl module ssu-subs.pm is not in the directory specified by your SSUALIGNDIR environment variable.\n"); 
    exit(1); 
}
require $subs_file;

my $total_time = -1 * time();
my $script_desc    = "define and align SSU rRNA sequences";
my $date           = scalar localtime();
my $usage          = "Usage: ssu-align [-options] <sequence file> <output dir to create>\n";
my $options_usage  = "where general options are:\n";
#                           1         2         3         4         5         6         7         8
#                  12345678901234567890123456789012345678901234567890123456789012345678901234567890
$options_usage .= "  -h     : show brief help on version and usage\n";
$options_usage .= "  -1     : output alignments in non-interleaved, 1 line/seq format\n";
$options_usage .= "  -m <s> : use CM file <f> instead of the default CM file\n";
$options_usage .= "  -b <f> : set minimum bit score of a surviving subsequence as <f> (default: 100)\n";
$options_usage .= "  -l <n> : set minimum length    of a surviving subsequence as <n> (default: 1)\n";
$options_usage .= "  -f     : force; if <output dir> already exists - empty it and fill it\n" ,
$options_usage .= "  --ff   : really force; remove <output dir> and all its subdirectories\n" ,

$options_usage .= "\noptions for running ssu-align in 'prep' mode to split up a large job:\n";
$options_usage .= "  --prep-n <n> : split target seq file into multiple files with <n> seqs each\n";
$options_usage .= "  --prep-p <n> : split target seq file into <n> files with equal number of seqs\n";

$options_usage .= "\noptions for skipping either the 1st (search) stage or 2nd (alignment) stage)\n";
$options_usage .= "  --no-align  : only search target sequence file for hits, skip alignment step\n";
$options_usage .= "  --no-search : only align  target sequence file, skip initial search step\n"; 

$options_usage .= "\nexpert options for tuning the initial search stage:\n";
$options_usage .= "  --no-trunc : do not truncate seqs to HMM predicted start/end, align full seqs\n";
$options_usage .= "  --toponly  : only search the top strand [default: search both strands]\n";
$options_usage .= "  --forward  : use the HMM forward algorithm for searching, not HMM viterbi\n";
$options_usage .= "  --global   : search with globally configured HMM [default: local]\n";

$options_usage .= "\nexpert options for tuning the alignment stage:\n";
$options_usage .= "  --filter <f> : filter aln based on seq identity, allow no 2 seqs > <f> identical\n";
$options_usage .= "  --no-prob    : DO NOT append posterior probabilities to alignments\n";
$options_usage .= "  --mxsize <f> : increase mx size for cmalign to <f> Mb (default: 4096)\n";


###################
# Process options #
###################
my %opt_H = ();              # key: option (example "-h"); value: option argument (example ("0" or "1") if option takes no arg, actual argument if option takes arg)
my %opt_takes_arg_H  = ();   # key: option; value: "1" if option takes argument, "0" if not
my @opt_order_A  = ();       # order of options for printing in banner
my %opt_is_prep_H = ();      # key: option; value: "1" if option will get passed to child ssu-align calls in prep mode, "0" if not
my $opt;

$opt_takes_arg_H{"-h"}          = 0;  push(@opt_order_A, "-h");           $opt_is_prep_H{"-h"}          = 0;
$opt_takes_arg_H{"-1"}          = 0;  push(@opt_order_A, "-1");           $opt_is_prep_H{"-1"}          = 1;
$opt_takes_arg_H{"-m"}          = 1;  push(@opt_order_A, "-m");           $opt_is_prep_H{"-m"}          = 1;
$opt_takes_arg_H{"-b"}          = 1;  push(@opt_order_A, "-b");           $opt_is_prep_H{"-b"}          = 1;
$opt_takes_arg_H{"-l"}          = 1;  push(@opt_order_A, "-l");           $opt_is_prep_H{"-l"}          = 1;
$opt_takes_arg_H{"-f"}          = 0;  push(@opt_order_A, "-f");           $opt_is_prep_H{"-f"}          = 0;
$opt_takes_arg_H{"--ff"}        = 0;  push(@opt_order_A, "--ff");         $opt_is_prep_H{"--ff"}        = 0;
$opt_takes_arg_H{"--prep-n"}    = 1;  push(@opt_order_A, "--prep-n");     $opt_is_prep_H{"--prep-n"}    = 0;
$opt_takes_arg_H{"--prep-p"}    = 1;  push(@opt_order_A, "--prep-p");     $opt_is_prep_H{"--prep-p"}    = 0;
$opt_takes_arg_H{"--no-align"}  = 0;  push(@opt_order_A, "--no-align");   $opt_is_prep_H{"--no-align"}  = 1;
$opt_takes_arg_H{"--no-search"} = 0;  push(@opt_order_A, "--no-search");  $opt_is_prep_H{"--no-search"} = 1;
$opt_takes_arg_H{"--no-trunc"}  = 0;  push(@opt_order_A, "--no-trunc");   $opt_is_prep_H{"--no-trunc"}  = 1;
$opt_takes_arg_H{"--toponly"}   = 0;  push(@opt_order_A, "--toponly");    $opt_is_prep_H{"--toponly"}   = 1;
$opt_takes_arg_H{"--forward"}   = 0;  push(@opt_order_A, "--forward");    $opt_is_prep_H{"--forward"}   = 1;
$opt_takes_arg_H{"--global"}    = 0;  push(@opt_order_A, "--global");     $opt_is_prep_H{"--global"}    = 1;
$opt_takes_arg_H{"--filter"}    = 1;  push(@opt_order_A, "--filter");     $opt_is_prep_H{"--filter"}    = 1;
$opt_takes_arg_H{"--no-prob"}   = 0;  push(@opt_order_A, "--no-prob");    $opt_is_prep_H{"--no-prob"}   = 1;
$opt_takes_arg_H{"--mxsize"}    = 1;  push(@opt_order_A, "--mxsize");     $opt_is_prep_H{"--mxsize"}    = 1;

#set default options
foreach $opt (keys %opt_takes_arg_H) { 
    if($opt_takes_arg_H{$opt}) { $opt_H{$opt} = ""; }
    else                       { $opt_H{$opt} = 0; }
}

# the only global variables, defaults and special strings
our $df_min_bit = 100;
our $df_min_len = 1;
our $df_mxsize = 4096;
our $df_cmsearch_T = -1;
our $df_none_name = "<NONE>";

Getopt::Long::Configure ("bundling");
my $opt_return = GetOptions
    ('h'         => \$opt_H{"-h"}, 
     '1'         => \$opt_H{"-1"},
     'm=s'       => \$opt_H{"-m"},
     'b=f'       => \$opt_H{"-b"},
     'l=n'       => \$opt_H{"-l"},
     'f'         => \$opt_H{"-f"},
     'ff'        => \$opt_H{"--ff"},
     'prep-n=n'  => \$opt_H{"--prep-n"},
     'prep-p=n'  => \$opt_H{"--prep-p"},
     'no-align'  => \$opt_H{"--no-align"},
     'no-search' => \$opt_H{"--no-search"},
     'no-trunc'  => \$opt_H{"--no-trunc"},
     'toponly'   => \$opt_H{"--toponly"},
     'forward'   => \$opt_H{"--forward"},
     'global'    => \$opt_H{"--global"},
     'filter=f'  => \$opt_H{"--filter"},
     'no-prob'   => \$opt_H{"--no-prob"},
     'mxsize'    => \$opt_H{"--mxsize"});

if($opt_return != 1) { exit(1); }

#determine options we'd use for subsequent ssu-align calls on split dataset if we're in prep mode
my $prep_enabled_options;
foreach $opt (@opt_order_A) { 
    if($opt_is_prep_H{$opt}) { 
	if($opt_takes_arg_H{$opt}) { if($opt_H{$opt} ne "") { $prep_enabled_options .= " " . $opt . " " . $opt_H{$opt}; } }
	else                  	   { if($opt_H{$opt})       { $prep_enabled_options .= " " . $opt; } }
    }
}

if ($opt_H{"-h"}) { 
    PrintBanner($0, $script_desc, $date, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, 1, "");
    # passing "" as last arg tells PrintBanner not to print banner to a file (usually it does, to the ssu-align output file)
    print $usage . "\n"; 
    print $options_usage; 
    exit(1);  
}

# Check for incompatible option combinations.
if(($opt_H{"--no-align"}) && 
   (($opt_H{"--filter"} ne '') ||
    ($opt_H{"-1"})             ||
    ($opt_H{"--no-prob"})      ||
    ($opt_H{"--mxsize"}))) { 
    printf STDERR ("\nERROR, --no-align is incompatible with alignment-specific options: -1,--filter,--no-prob, and --mxsize.\n"); exit(1); 
}

if(($opt_H{"--no-search"}) && 
   (($opt_H{"-b"} ne '') ||
    ($opt_H{"-l"})      ||
    ($opt_H{"--toponly"})  ||
    ($opt_H{"--no-trunc"})  ||
    ($opt_H{"--forward"})  ||
    ($opt_H{"--global"}))) {
    printf STDERR ("\nERROR, --no-search is incompatible with search-specific options: -b,-l,--toponly,--no-trunc,--forward, and --global.\n"); exit(1); 
}

if(($opt_H{"--prep-n"} ne "") && ($opt_H{"--prep-p"} ne "")) { 
    printf STDERR ("\nERROR, --prep-n and --prep-p are incompatible, choose one or the other.\n"); exit(1);
}    
# Check for incompatible option ranges
if(($opt_H{"-l"} ne "")       && ($opt_H{"-l"} <= 0))       { printf STDERR ("\nERROR, with -l <n>, <n> must be greater than 0.\n"); exit(1); }
if(($opt_H{"--prep-n"} ne "") && ($opt_H{"--prep-n"} <= 0)) { printf STDERR ("\nERROR, with --prep-n <n>, <n> must be greater than 0.\n"); exit(1); }
if(($opt_H{"--prep-p"} ne "") && ($opt_H{"--prep-p"} <= 0)) { printf STDERR ("\nERROR, with --prep-p <n>, <n> must be greater than 0.\n"); exit(1); }
if(($opt_H{"--mxsize"} ne "") && ($opt_H{"--mxsize"} <= 0.)) { printf STDERR ("\nERROR, with --mxsize <f>, <f> must be greater than 0.\n"); exit(1); }
if(($opt_H{"--filter"} ne "") && (($opt_H{"--filter"} < 0.) || ($opt_H{"--filter"} > 1.))) { printf STDERR ("\nERROR, with --filter <f>, <f> must be between 0. and 1.\n"); exit(1); }


###################################################
# Process command-line arguments and print banner #
###################################################
if(scalar(@ARGV) != 2) {   
    print "Incorrect number of command line arguments.\n";
    print $usage;
    print "\nTo see more help on available options, do ssu-draw -h\n\n";
    exit(1);
}
my ($target_file, $out_root) = @ARGV;


#####################################################
# Create the output directory and sum and log files #
#####################################################
my $out_dir      = $out_root;
my $out_dir_root = $out_dir . "/" . $out_root;
my ($sum_file, $sum_file2print);
my ($log_file, $log_file2print);
if($opt_H{"--prep-n"} || $opt_H{"--prep-p"}) { 
    $sum_file       = $out_dir_root . ".ssu-align.prep.sum";
    $sum_file2print = $out_root     . ".ssu-align.prep.sum";
    $log_file       = $out_dir_root . ".ssu-align.prep.log";
    $log_file2print = $out_root     . ".ssu-align.prep.log";
}
else {
    $sum_file       = $out_dir_root . ".ssu-align.sum";
    $sum_file2print = $out_root     . ".ssu-align.sum";
    $log_file       = $out_dir_root . ".ssu-align.log";
    $log_file2print = $out_root     . ".ssu-align.log";
}

create_output_dir($out_dir, \%opt_H, $sum_file, $log_file); 
PrintBanner($0, $script_desc, $date, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, 1, $sum_file);
PrintBanner($0, $script_desc, $date, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, 0, $log_file);


##################################################################
# Validate that everything is go and determine output file names #
##################################################################
my ($ssualign, $cmsearch, $cmalign, $sfetch, $weight, $cm_file);
validate_and_setup_ssu_align($ssualigndir, $target_file, \%opt_H, \$ssualign, \$cmsearch, \$cmalign, \$sfetch, \$weight, \$cm_file, $log_file);

# determine number of sequences in the target sequence file
my $nseq_target_file = DetermineNumSeqsFasta($target_file);
if($nseq_target_file == -1) { die "\nERROR, the target sequence file must be FASTA formatted, but non-whitespace found before first \">\" in $target_file.\nThis is not valid FASTA.\n"; }
if($nseq_target_file == 0)  { die "\nERROR, the target sequence file must be FASTA formatted, but no \">\" found in $target_file.\nThe file is either empty or not valid FASTA.\n"; }

my (@indi_cm_name_A);
process_cm_file($out_root, $cm_file, \%opt_H, \@indi_cm_name_A);
my $ncm = scalar(@indi_cm_name_A); 
if(($opt_H{"--no-search"}) && ($ncm > 1)) { printf("ERROR, the --no-search option only works if the CM file contains exactly 1 CM, $cm_file has $ncm CMs in it.\n"); exit(1); }

my ($tab_file, $description_width, $search_time);
my $max_file_name_width = 0;
my $abs_orig_cm_file = abs_path($cm_file);

my ($cluster_prefix, $cluster_suffix);
if($opt_H{"--prep-n"} || $opt_H{"--prep-p"}) { 
    prepare_only($target_file, $out_dir, $out_root, \%opt_H, $ssualign, $weight, $cm_file, $prep_enabled_options, $nseq_target_file, \@indi_cm_name_A, \$max_file_name_width, $sum_file, $log_file);
    PrintStringToFile($sum_file, 1, (sprintf("  %-*s  ssu-align output file (*this* text printed to stdout)\n", $max_file_name_width, $sum_file2print)));
    PrintStringToFile($sum_file, 1, sprintf("  %-*s  log file with commands executed by this script\n", $max_file_name_width, $log_file2print));
    PrintStringToFile($sum_file, 1, sprintf("#\n# All output files created in directory \.\/%s\/\n", $out_dir));
    PrintStringToFile($sum_file, 1, sprintf("#\n", $out_dir));

    exit(0);
}
# if we get here, neither --prep-p nor --prep-n were enabled


############################################################################
# Step 1: Define sequence ends (and classify seqs if > 1 CM) with cmsearch #
############################################################################
if(! $opt_H{"--no-search"}) { 
    $search_time = -1 * time();
    search_sequences_with_each_model(\%opt_H, $cmsearch, $cm_file, $target_file, $out_dir_root, $nseq_target_file, 
				     \@indi_cm_name_A, \$tab_file, \$max_file_name_width, \$description_width, $sum_file);
    $search_time += time();
}


################################
# Step 2: Extract subsequences #
################################
my %bestmatch_cm_H = ();
my %new_target_file_per_cm_name_H = ();
my %hmmscores2print_H = ();
my $max_seq_name_width;

if(! $opt_H{"--no-search"}) { 
    classify_and_extract_subseqs(\%opt_H, $tab_file, $target_file, $out_dir_root, $sfetch, $max_file_name_width, \@indi_cm_name_A, \%bestmatch_cm_H, \%new_target_file_per_cm_name_H, \%hmmscores2print_H, \$max_seq_name_width, $sum_file);
}
else { 
    # No initial search stage; align all the sequences in the full target sequence file to the only CM (we've checked there's only 1 CM)
    $new_target_file_per_cm_name_H{$indi_cm_name_A[0]} = $target_file;
}


###########################
# Step 3: Align sequences #
###########################
my ($align_time);
my %cmscores2print_H = ();
if(! $opt_H{"--no-align"}) {
    $align_time = -1 * time();
    align_subseqs(\%opt_H, $out_dir_root, $cmalign, $max_file_name_width, $description_width, $weight, \@indi_cm_name_A, \%new_target_file_per_cm_name_H, \%cmscores2print_H, $sum_file); 
    $align_time += time();
}


#############################
# Step 4: Print scores file #
#############################
my $scores_file       = $out_dir_root . ".scores";
my $scores_file2print = $out_root     . ".scores";
if(! $opt_H{"--no-search"}) { 
    print_scores_file($target_file, $ncm, $scores_file, $scores_file2print, $max_seq_name_width, \@indi_cm_name_A, \%bestmatch_cm_H, \%cmscores2print_H, \%hmmscores2print_H, $sum_file);
    PrintStringToFile($sum_file, 1, sprintf("  %-*s  list of CM/HMM scores for each sequence\n", $max_file_name_width, $scores_file2print));
}


############
# Conclude #
############
$total_time += time();
PrintConclusion($sum_file, $log_file2print, $sum_file2print, "", $out_dir);

# print 3 different timings: search, alignment, total
if(! $opt_H{"--no-align"})  { PrintTiming("# CPU time (search):    ", $search_time, $sum_file); }
if(! $opt_H{"--no-search"}) { PrintTiming("# CPU time (alignment): ", $align_time, $sum_file); }
PrintTiming("# CPU time (total):     ", $total_time, $sum_file); 
PrintStringToFile($sum_file, 1, sprintf("#\n", $out_dir));

#remove esl-sfetch index file we created for the target file
my $ssi_file = $target_file . ".ssi";
if(-e $ssi_file) { UnlinkFile($ssi_file, $log_file); }

# Success! Exit normally
exit(0); 


###############
# Subroutines #
###############


#####################################################################
# Subroutine: validate_and_setup_ssu_align()
# Incept:     EPN, Mon Nov  3 15:05:56 2008
# 
# Purpose:    Validation and setup:
#             - validate that the sequence file exists
#             - validate that the required executable programs exist
#             - validate that the CM file exists
#
# Arguments: 
# $ssualigndir:    dir defined by SSUALIGNDIR environment variable 
# $target_file:    the target sequence file 
# $opt_HR:         reference to the hash of command-line options
# $ssualign_R:     RETURN; ssu-align executable command
# $cmsearch_R:     RETURN; cmsearch executable command
# $cmalign_R:      RETURN; cmalign executable command
# $sfetch_R:       RETURN; esl-sfetch executable command
# $weight_R:       RETURN; esl-weight executable command
# $cm_file_R:      RETURN; the path to the CM file, either default CM file or <s> from -m <s>
# $log_file:       file to print commands to 
# 
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If a required program does not exist, the program 
#             prints a message to STDERR explaining why it's
#             exiting early and then exits with non-zero status.
#
####################################################################
sub validate_and_setup_ssu_align { 
    my $narg_expected = 10;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, validate_and_setup_ssu_align() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($ssualigndir, $target_file, $opt_HR, $ssualign_R, $cmsearch_R, $cmalign_R, $sfetch_R, $weight_R, $cm_file_R, $log_file) = @_;

    #Make sure the CM file exists
    my $cm_file = "";
    if($opt_HR->{"-m"} ne "") { 
	$cm_file = $opt_HR->{"-m"}; 
	if(!(-e $cm_file))   { printf STDERR ("ERROR, CM file $cm_file, specified with -M does not exist.\n"); exit(1); }
    }
    else { 
	$cm_file = $ssualigndir . "/ssu-align-0p1.cm";
	if(!(-e $cm_file))   { printf STDERR ("ERROR, the default CM file $cm_file does not exist.\n"); exit(1); }
    }

    #Make sure the target file exists
    if(!(-e $target_file))   { printf STDERR ("ERROR, target sequence file $target_file does not exist.\n"); exit(1); }

    my ($tmp, $command_worked);
    my $cmsearch   = "ssu-cmsearch";
    my $cmalign    = "ssu-cmalign";
    my $sfetch     = "ssu-esl-sfetch";
    my $weight     = "ssu-esl-weight";
    my $ssualign   = "ssu-align";
    # check that the required programs are in the PATH
    if(!($opt_HR->{"--no-search"})) { 
	RunExecutable("$cmsearch -h", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $cmsearch is not in your PATH environment\nvariable. See the User's Guide Installation section.");;
	RunExecutable("$sfetch -h", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $sfetch is not in your PATH environment\nvariable. See the User's Guide Installation section.");;
    }
    if(!($opt_HR->{"--no-align"})) { 
	RunExecutable("$cmalign -h", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $cmalign is not in your PATH environment\nvariable. See the User's Guide Installation section.");;
    }
    if($opt_HR->{"--filter"} ne "") { 
	RunExecutable("$weight -h", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $weight is not in your PATH environment\nvariable. See the User's Guide Installation section.");;
    }
    if(($opt_HR->{"--prep-n"} ne "") || ($opt_HR->{"--prep-p"})) { 
	RunExecutable("$ssualign -h", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $ssualign is not in your PATH environment\nvariable. See the User's Guide Installation section.");;
    }

    $$ssualign_R    = $ssualign;
    $$cmsearch_R    = $cmsearch;
    $$cmalign_R     = $cmalign;
    $$sfetch_R  = $sfetch;
    $$weight_R  = $weight;
    $$cm_file_R     = $cm_file;

    return;
}



#####################################################################
# Subroutine: create_output_dir()
# Incept:     EPN, Mon Nov  3 15:22:26 2008
# 
# Purpose:    Create a new directory <$outdir> for the output files. 
#             If the directory already exists and <$do_clobber>, 
#             delete all of the files within it.
# 
# Arguments:  
# $out_dir:   directory to create
# $opt_HR:    reference to the hash of command-line options
# $sum_file:  summary file, created (opened) here
# $log_file:  log file, created (opened) here
#
# Returns:    Nothing.
#
# Exits:      If the directory already exists and <$do_clobber> is
#             FALSE. If a system call unexpectedly fails and returns 
#             a non-zero status code. 
# 
####################################################################
sub create_output_dir { 
    my $narg_expected = 4;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, create_output_dir() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($out_dir, $opt_HR, $sum_file, $log_file) = @_;

    my ($command, $tmp, $command_worked, $maybe_dir, $has_subdir, $has_ssualign_subdir, $ran_command, $output);
    $has_subdir = 0;
    $has_ssualign_subdir = 0;
    $ran_command = 0;
    # create output directory
    if(-d $out_dir) { 
	if((! $opt_HR->{"-f"}) && (! $opt_HR->{"--ff"})) { 
	    printf STDERR ("ERROR, output directory $out_dir already exists. Delete it or use -f to overwrite it.\n"); exit(1); 
	}
	elsif(($opt_HR->{"-f"}) && (! $opt_HR->{"--ff"})) { 
            # directory $out_dir exists, -f enabled  but --ff not enabled, check to see if there's any subdirectories in it:
	    foreach $maybe_dir (glob("$out_dir/*")) { 
		if(-d $maybe_dir) { # $maybe_dir is a dir
		    $has_subdir = 1;
		    if($maybe_dir !~ m/^$out_dir\.(\d+)/) { # subdirectory not created by ssu-align
			printf STDERR ("Subdirectory $maybe_dir of $out_dir exists; it doesn't appear to have been created by ssu-align.\nEither delete it, or use --ff to remove all subdirectories of $out_dir.");
		    }
		    else { # subdirectory (probably) created by ssu-align
			$has_ssualign_subdir = 1;
		    }
		}
	    }
	    if($has_ssualign_subdir) { 
		printf STDERR ("Subdirectories of $out_dir exist that appear to have been created by ssu-alignsu-align.\nEither delete them, or use --ff to remove them all.");
	    }
	    if($has_subdir) { exit(1); }
	}
	# if we get here, $out_dir exists, but either it has no subdirectories, or --ff was enabled, or both
	# remove the contents of the directory with rm -rf and remove the directory
	$command = "rm -rf $out_dir 2>&1";
	$output = `$command`; 
        # Note: we can't use RunExecutable, b/c that requires a output file to write to, which will be put
	# into $out_dir, and since that hasn't been created yet, we can't write to it. Instead if the command
	# succeeds, we write it to the log file at the end of the function.
	if($? == -1) { 
	    printf STDERR ("\nERROR, the command \"rm -rf $out_dir did not successfully complete.\n"); 
	    exit(1);
	}
	$ran_command = 1;
	if(-d $out_dir) { printf STDERR ("ERROR, output directory $out_dir still exists after the command \"rmdir $out_dir\".\n"); exit(1); }
    }

    # make the directory 
    mkdir($out_dir) || die "\nERROR, unable to make directory $out_dir.\n";

    # open the sum and log files
    open(OUT, ">" . $sum_file) || die "ERROR, creating file $sum_file.";
    close(OUT);
    open(OUT, ">" . $log_file) || die "ERROR, creating file $log_file.";
    close(OUT);

    #if we did a 'rm -rf' command, print that to the log file:
    if($ran_command) { 
	PrintStringToFile($log_file, 0, ("Executing: \(" . $command . "\)\n"));
	PrintStringToFile($log_file, 0, ("Output:\n\(" . $output . "\)\n\n"));
    }
    return;
}


#####################################################################
# Subroutine: process_cm_file()
# Incept:     EPN, Tue Nov  4 08:20:47 2008
# 
# Purpose:    Validate and process the CM file. A CM file 
#             <$my_cm_file_copy> is valid if each of the <x> CM 
#             within it is has a unique name. 
#
# Arguments:  
# $out_root:             command-line argument, the root for output files
# $cm_file:              the CM file we'll use
# $opt_HR:               reference to the hash of command-line options
# $indi_cm_name_AR:      RETURN; array of individual CM names in the
#                        order they appear in the CM file
# 
# Returns:    Fills RETURN arguments as listed above.
#
# Exits:      If two CMs in <$cm_file> have the same name we exit,
#             or we can't open <$cm_file>. In both cases, program
#             exits with non-zero return status.
# 
####################################################################
sub process_cm_file { 
    my $narg_expected = 4;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, process_cm_file() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($out_root, $cm_file, $opt_HR, $indi_cm_name_AR) = @_;
    
    my($line, $cm_name);
    my %cm_name_exists_H = ();

    if(open(CM, $cm_file) == 0) { printf STDERR ("ERROR, could not open $cm_file for reading.\n"); exit(1); }
    while($line = <CM>) {
	# the lines we're interested in look like this:
	#NAME     archaea
	if($line =~ /^NAME\s+(\S+)/) { 
	    $cm_name = $1;
	    push(@{$indi_cm_name_AR}, $cm_name);
	    if(exists($cm_name_exists_H{$cm_name})) { printf STDERR ("ERROR, two CMs in CM file $cm_file have the name $cm_name. Each CM must have a unique name.\n"); exit(1); }
	    $cm_name_exists_H{$cm_name} = 1;
	    if($cm_name eq $df_none_name) { printf STDERR ("ERROR, you can't use a CM with the name $df_none_name, that's reserved for indicating which sequences are not the best-match to any models.\n"); exit(1); }
	}
    }
    close(CM);
    return;
}									 


#####################################################################
# Subroutine: prepare_only()
# Incept:     EPN, Mon Nov  3 15:25:23 2008
# 
# Purpose:    Carry out a special mode of ssu-align for creating
#             scripts to split up large alignment jobs into many
#             smaller jobs. This subroutine is called only if --prep-n or 
#             --prep-p is enabled on the command line. 
# 
#             The target sequence file <$target_file> is partitioned
#             into > 1 new, smaller fasta files. A shell script 
#             named <$out_dir_root.sh> is created that calls 'ssu-align'
#             once each for each of the new fasta files. A separate perl 
#             script named <$out_dir_root.merge.pl> is created that is to be
#             run after the alignments in <$out_dir_root.sh> are complete.
#             This script merges all the small alignments into
#             one big alignment.
# 
# Arguments:  
# $target_file              the target sequence file
# $out_dir                  output directory
# $out_root                 root for output files
# $opt_HR:                  reference to the hash of command-line options
# $ssualign:                the ssu-align executable command
# $weight                   esl-weight command
# $cm_file:                 the CM file 
# $prep_options:            options to pass to children jobs
# $nseq_target_file:        number of sequences in $target_file
# $indi_cm_name_AR:         reference to array with names of individual CMs
# $max_file_name_width_R:   RETURN; maximum length of a file name
# $sum_file:                file to print output file notices to
#
# Returns:    Nothing.
#
# Exits:      Upon successful completion with a zero status code 
#             (normal). Exits early upon failure with informative
#             message and non-zero status code. 
# 
####################################################################
sub prepare_only { 
    my $narg_expected = 12;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, prepare_only() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($target_file, $out_dir, $out_root, $opt_HR, $ssualign, $weight, $cm_file, $prep_options, $nseq_target_file, $indi_cm_name_AR, $max_file_name_width_R, $sum_file) = @_;

    # Steps we'll perform
    # 1. partition the target seq file
    # 2. print ssu-align.pl calls for each target seq file to screen
    # 3. print cmalign --merge calls to eventually merge resulting 
    #    alignments from ssu-align.pl calls in 2 together.
    # 4. exit

    my ($shell_script, $shell_script2print, $merge_script, $merge_script2print, $remainder, $n, $target_subfile_root, $target_subfile, $sub_output);
    my ($nseq_this_file, $line, $ncm, $ndig, $tmp, $description_width, $dashes1, $dashes2);
    my ($i, $nmerge, $iter, $nstop, $lower, $upper, $merged_root, $merged_name, $fil_merged_name, $merged_lower_name, $merged_upper_name, $cm_name);

    $ncm = scalar(@{$indi_cm_name_AR});

    $shell_script       = $out_dir_root . ".sh";
    $shell_script2print = $out_root . ".sh";
    $merge_script       = $out_dir_root . ".merge.pl";
    $merge_script2print = $out_root . ".merge.pl";
    if(open(SH, ">" . $shell_script) == 0) { printf STDERR ("ERROR, could not open $shell_script for writing.\n"); exit(1); }

    #determine number of seqs per file (if --prep-p)
    my ($prep_nseq, $prep_nproc);
    if($opt_HR->{"--prep-p"} ne "") { 
	$prep_nproc = $opt_HR->{"--prep-p"};
	$prep_nseq  = int($nseq_target_file / ($prep_nproc)); 
	$remainder  = $nseq_target_file - ($prep_nseq * $prep_nproc);
	if($remainder > 0) { $prep_nseq++; }
    }
    elsif($opt_HR->{"--prep-n"} ne "") { 
	$prep_nproc = int($nseq_target_file / ($prep_nseq));
	$remainder  = $nseq_target_file - ($prep_nseq * $prep_nproc);
	if($remainder > 0) { $prep_nproc++; }
    }
    else { printf STDERR ("ERROR, in prepare_only but neither --prep-p nor --prep-n enabled on the command-line. This shoudln't happen.\n"); exit(1); }

    if(($opt_HR->{"--prep-p"} ne "") && ($prep_nproc > $nseq_target_file)) { 
	printf STDERR ("ERROR, --prep-p %d enabled, but there's only %d sequences in the target file.\n", $prep_nproc, $nseq_target_file); exit(1); 
    }
    if(($opt_HR->{"--prep-n"} ne "") && ($prep_nproc == 1)) {
	printf STDERR ("ERROR, --prep-n %d enabled, but there's only %d sequences in the target file.\nNo need to use --prep-n, you're requesting the target file be split into only 1 partition.\n", $prep_nseq, $nseq_target_file); exit(1); 
    }

    $ndig = 1; $tmp = $prep_nproc; while($tmp > 10) { $ndig++; $tmp /= 10.; }
    my $max_file_name_width = length($merge_script2print);
    $target_subfile_root = $target_file . "." . $n;
    $target_subfile_root =~ s/^.+\///;  # remove path 
    if($max_file_name_width < (length($target_subfile_root) + $ndig)) { 
	$max_file_name_width = length($target_subfile_root) + $ndig;
    }
    if($max_file_name_width < (length($out_root . ".ssu-align.prep.out"))) { 
	$max_file_name_width = length($out_root . ".ssu-align.prep.out");
    }
    if($max_file_name_width < (length("output file name"))) { 
	$max_file_name_width = length("output file name"); 
    }
    my $max_cm_name_width = MaxLengthScalarInArray($indi_cm_name_AR);
    
    $description_width = length("perl script to merge alignments when  completes");
    $description_width += length($shell_script2print);
    $dashes1 = ""; for($i = 0; $i < $max_file_name_width; $i++) { $dashes1 .= "-"; } 
    $dashes2 = ""; for($i = 0; $i < $description_width; $i++)   { $dashes2 .= "-"; } 
    
    PrintStringToFile($sum_file, 1, sprintf("#\n# Prep mode: Splitting up ssu-align job into %d smaller jobs.\n", $prep_nproc));
    PrintStringToFile($sum_file, 1, sprintf("#\n"));
    PrintStringToFile($sum_file, 1, sprintf("# %-*s  %-*s\n", $max_file_name_width, "output file name", $description_width, "description"));
    PrintStringToFile($sum_file, 1, sprintf("# %-*s  %-*s\n", $max_file_name_width, $dashes1, $description_width, $dashes2));

    # 1. partition the target seq file AND
    # 2. print ssu-align calls for each target seq file to stdout
    $n = 1;
    $target_subfile_root = $target_file . "." . $n;
    $target_subfile_root =~ s/^.+\///;  # remove path 
    $target_subfile      = $out_dir . "/" . $target_subfile_root;
    if(open(SUB, ">" . $target_subfile) == 0) { printf STDERR ("ERROR, could not open $target_subfile for writing.\n"); exit(1); }
    $nseq_this_file = -1;
    if(open(FULL, $target_file) == 0) { printf STDERR ("ERROR, could not open $target_file for reading.\n"); exit(1); }
    while($line = <FULL>) { 
	if($line =~ m/^>/) { 
	    if(++$nseq_this_file == $prep_nseq) { 
		close(SUB); 
		PrintStringToFile($sum_file, 1, sprintf("  %-*s  partition %*d fasta sequence file\n", $max_file_name_width, $target_subfile_root, $ndig, $n));
		printf SH ("%s%s%s\n", $cluster_prefix, "$ssualign -f $prep_enabled_options $target_subfile_root $out_root." . $n, $cluster_suffix);
		$target_subfile_root = $target_file . "." . (++$n);
		$target_subfile_root =~ s/^.+\///;  # remove path 
		$target_subfile      = $out_dir . "/" . $target_subfile_root;
		if(open(SUB, ">" . $target_subfile) == 0) { printf STDERR ("ERROR, could not open $target_subfile for writing.\n"); exit(1); }
		$nseq_this_file = 0;
	    }
	}
	print SUB ($line);
    }
    close(FULL);
    close(SUB);
    PrintStringToFile($sum_file, 1, sprintf("  %-*s  partition %*d fasta sequence file\n", $max_file_name_width, $target_subfile_root, $ndig, $n));
    printf SH ("%s%s%s\n", $cluster_prefix, "$ssualign $prep_enabled_options $target_subfile_root $out_root." . $n, $cluster_suffix);
    close(SH); 
    if($n != $prep_nproc) { printf STDERR ("ERROR, problem partitioning target fasta file $target_file into $prep_nproc files, only $n files were successfully created.\n"); exit(1); }

    my @to_mergeA;
    my @new_to_mergeA;

    # 3. print cmalign --merge calls to eventually merge resulting 
    #    alignments from ssu-align.pl calls in 2 together.
    if(! $opt_HR->{"--no-align"}) { 
	if(open(MG, ">" . $merge_script) == 0) { printf STDERR ("ERROR, could not open $merge_script for writing.\n"); exit(1); }
	
	my $m;
	for($m = 1; $m <= $ncm; $m++) { 
	    $cm_name = $indi_cm_name_AR->[($m-1)];
	    printf MG ("\# Merging alignments to CM %d of %d\n", $m, $ncm);
	    @to_mergeA = ();
	    for($i = 1; $i <= $prep_nproc; $i++) { push(@to_mergeA, $i); }
	    $nmerge = scalar(@to_mergeA);
	    $iter = 0;
	    while($nmerge > 1) { 
		$iter++;
		@new_to_mergeA = ();
		if (($nmerge % 2) == 0) { $nstop = $nmerge; } else { $nstop = $nmerge+1; }
		for($i = 0; $i < $nstop; $i+=2) { 
		    $lower = $to_mergeA[$i];
		    if($i == (scalar(@to_mergeA)-1)) { 
			# special case, we have a single alignment remaining, not a pair of alignments, 
			# if nec, copy it to a new name if it exists (so the merging process can march along), else we do nothing
			$upper = $lower;
			$lower =~ s/\-.+//;
			$upper =~ s/.+\-//;
			$merged_root = $lower . "-" . $upper;
			$merged_name = $out_root . "." . $merged_root. "." . $cm_name . ".merged.stk";
			if($iter > 1) { $merged_lower_name = $out_root . "." . $to_mergeA[$i] . "." . $cm_name . ".merged.stk"; }
			else          {	$merged_lower_name = $out_root . "." . $to_mergeA[$i] . "/" . $out_root . "." . $to_mergeA[$i] . "." . $cm_name . ".stk"; }
			if($merged_name ne $merged_lower_name) { 
			    printf MG ("if(-e \"$merged_lower_name\") { \n"); 
			    printf MG ("\tsystem(\"cp $merged_lower_name $merged_name\");\n");
			    printf MG ("\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"cp $merged_lower_name $merged_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
			    printf MG ("}\n");
			    #erase intermediate alignment if it exists
			    if($iter > 1) { 
				printf MG ("if(-e \"$merged_lower_name\") { \n"); 
				printf MG ("\tsystem(\"rm -f $merged_lower_name\");\n");
				printf MG ("\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"rm -f $merged_lower_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
				printf MG ("}\n");
			    }
			}
		    }
		    else { #normal case, we have a pair of alignments to merge together
			$upper = $to_mergeA[($i+1)]; 
			$lower =~ s/\-.+//;
			$upper =~ s/.+\-//;
			$merged_root = $lower . "-" . $upper;
			if($opt_HR->{"--enabled"} ne "") { 
			    $merged_name     = $out_root . "." . $merged_root . "." . $cm_name . ".merged.nf.stk";
			    $fil_merged_name = $out_root . "." . $merged_root . "." . $cm_name . ".merged.stk";
			}
			else { 
			    $merged_name = $out_root . "." . $merged_root . "." . $cm_name . ".merged.stk";
			}
			if($iter > 1) { 
			    $merged_lower_name = $out_root . "." . $to_mergeA[$i] .     "." . $cm_name . ".merged.stk";
			    $merged_upper_name = $out_root . "." . $to_mergeA[($i+1)] . "." . $cm_name . ".merged.stk";
			}
			else { #iter == 1
			    $merged_lower_name = $out_root . "." . $to_mergeA[$i]     . "/" . $out_root . "." . $to_mergeA[$i] .     "." . $cm_name . ".stk";
			    $merged_upper_name = $out_root . "." . $to_mergeA[($i+1)] . "/" . $out_root . "." . $to_mergeA[($i+1)] . "." . $cm_name . ".stk";
			}
			push(@new_to_mergeA, $merged_root);
			printf MG ("if(-e \"$merged_lower_name\") { \n"); 
			printf MG ("\tif(-e \"$merged_upper_name\") { \n"); 
			#DEBUGGING printf STDERR ("cm: $m iter: $iter i: $i $merged_lower_name $merged_upper_name\n");
			printf MG ("\t\tsystem(\"$cmalign -o $merged_name --merge --cm-idx $m $cm_file $merged_lower_name $merged_upper_name\");\n");
			printf MG ("\t\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"$cmalign -o $merged_name --merge --cm-idx $m $merged_lower_name $merged_upper_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
			if($opt_HR->{"--filter"}) { 
			    printf MG ("\t\tsystem(\"$weight -f --idf " . $opt_HR->{"--filter"} . " $merged_name > $fil_merged_name\");\n");
			    printf MG ("\t\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"$weight -f --idf " . $opt_HR->{"--filter"} . " $merged_name > $fil_merged_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
			    #erase non-filtered alignment
			    printf MG ("if(-e \"$merged_name\") { \n"); 
			    printf MG ("\tsystem(\"rm -f $merged_name\");\n");
			    printf MG ("\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"rm -f $merged_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
			    printf MG ("} \n");
			}
			printf MG ("\t\t}\n");
			# else $merged_lower_name exists, but $merged_upper_name does not exist
			printf MG ("\telse { \n");
			printf MG ("\t\tsystem(\"cp $merged_lower_name $merged_name\");\n");
			printf MG ("\t\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"cp $merged_lower_name $merged_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
			printf MG ("\t}\n");
			printf MG ("}\n");
			printf MG ("elsif((-e \"$merged_upper_name\")) { \n"); 
			# else $merged_upper_name exists, but $merged_lower_name does not exist
			printf MG ("\tsystem(\"cp $merged_upper_name $merged_name\");\n");
			printf MG ("\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"cp $merged_upper_name $merged_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
			printf MG ("}\n");
			printf MG ("\n");
			# else: neither $merged_upper_name exists, nor $merged_lower_name exists, do nothing next iteration will handle this
			
			# erase the intermediate alignments if they exist 
			if($iter > 1) { 
			    printf MG ("if(-e \"$merged_lower_name\") { \n"); 
			    printf MG ("\tsystem(\"rm -f $merged_lower_name\");\n");
			    printf MG ("\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"rm -f $merged_lower_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
			    printf MG ("} \n");
			    printf MG ("if(-e \"$merged_upper_name\") { \n"); 
			    printf MG ("\tsystem(\"rm -f $merged_upper_name\");\n");
			    printf MG ("\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"rm -f $merged_upper_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
			    printf MG ("} \n");
			    printf MG ("\n");
			}
		    }
		}
		if (($nmerge % 2) != 0) { 
		    if($iter == 1) { push(@new_to_mergeA, $to_mergeA[($nmerge-1)] . "-" . $to_mergeA[($nmerge-1)]); } #special case, push 9-9 (for example), only nec if first iter, otherwise we're okay
		    else           { push(@new_to_mergeA, $to_mergeA[($nmerge-1)]); }  #push 5-6 in iter 2 (for example)
		}
		@to_mergeA = @new_to_mergeA;
		$nmerge = scalar(@to_mergeA);
	    }
	}
	close(MG);
    }
    
    PrintStringToFile($sum_file, 1, sprintf("  %-*s  shell script that will run ssu-align %d times\n", $max_file_name_width, $shell_script2print, $prep_nproc));
    if(! $opt_HR->{"--no-search"}) { 
	PrintStringToFile($sum_file, 1, sprintf("  %-*s  perl script to merge alignments when %s completes\n", $max_file_name_width, $merge_script2print, $shell_script2print));
    }
    $shell_script =~ s/$out_dir\///;
    $merge_script =~ s/$out_dir\///;
    #PrintStringToFile($sum_file, 1, sprintf("To execute (doesn't work if you're going to use a cluster):\ncd $out_dir; sh $shell_script; perl $merge_script;\n"));

    $$max_file_name_width_R = $max_file_name_width;
    return;
}


#####################################################################
# Subroutine: search_sequences_with_each_model()
# Incept:     EPN, Mon Nov  3 15:42:17 2008
# 
# Purpose:    Run cmsearch on the target sequence file <$target_file>
#             in HMM mode to define start/stops of each sequence,
#             and to verify they're likely SSU at all.
#             
# Arguments:  
# $opt_HR:                 reference to the hash of command-line options
# $cmsearch:               the cmsearch executable
# $cm_file:                CM file
# $target_file:            the target sequence file
# $out_dir_root:           output file root, for naming output files
# $nseq_target_file:       number of sequences in target file
# $indi_cm_name_AR:        ref to array with individual CM names
# $tab_file_R:             RETURN; name of tab file to return
# $max_file_name_width_R:  RETURN; num chars in max length file name
# $description_width_R:    RETURN; num chars in description
# $sum_file:                file to print output file notices to
#
# Returns:    Nothing.
#
# Exits:      If the cmsearch call doesn't finish with a zero status
#             code we exit. cmsearch should print an error message 
#             to standard error if this occurs.
# 
####################################################################
sub search_sequences_with_each_model { 
    my $narg_expected = 11;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, search_sequences_with_each_model() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($opt_HR, $cmsearch, $cm_file, $target_file, $out_dir_root, $nseq_target_file, $indi_cm_name_AR, $tab_file_R, $max_file_name_width_R, $description_width_R, $sum_file) = @_;

    my ($i, $cmsearch_opts, $tab_file, $tab_file2print, $alg_flag, $max_file_name_width, $dashes1, $dashes2, $tmp, $command, $command_worked);

    $tab_file = $out_dir_root . ".tab";
    $tab_file2print = $out_root . ".tab";
    if   ($opt_HR->{"--forward"}) { $alg_flag = "--forward"; } 
    else                          { $alg_flag = "--viterbi"; } 
    if   ($opt_HR->{"--global"})  { $alg_flag .= " -g"; }

    # print info on what we just created
    $max_file_name_width  = MaxLengthScalarInArray($indi_cm_name_AR); 
    $description_width    = $max_file_name_width;
    $description_width   += length("list of sequences to align with  CM");
    if($description_width < length("boundaries/scores of hits defined by HMM(s)")) { $description_width = length("boundaries/scores of hits defined by HMM(s)"); }

    $max_file_name_width += length($out_root . "." . ".hits.list");
    if($max_file_name_width < length("output file name")) { $max_file_name_width = length("output file name"); }
    $dashes1 = ""; for($i = 0; $i < $max_file_name_width; $i++) { $dashes1 .= "-"; } 
    $dashes2 = ""; for($i = 0; $i < $description_width; $i++)   { $dashes2 .= "-"; } 

    PrintStringToFile($sum_file, 1, sprintf("#\n# Stage 1: Determining SSU start/end positions and best-matching models...\n"));
    PrintStringToFile($sum_file, 1, sprintf("#\n"));
    PrintStringToFile($sum_file, 1, sprintf("# %-*s  %-*s\n", $max_file_name_width, "output file name", $description_width, "description"));
    PrintStringToFile($sum_file, 1, sprintf("# %-*s  %-*s\n", $max_file_name_width, $dashes1, $description_width, $dashes2));

    $cmsearch_opts = " --hmm-cW 1.5 --no-null3 --noalign ";
    my $cmsearch_T = $df_cmsearch_T;
    if($opt_HR->{"--toponly"}) { $cmsearch_opts .= " --toponly"; }

    $command = "$cmsearch $cmsearch_opts -T $cmsearch_T --tab $tab_file $alg_flag $cm_file $target_file";
    RunExecutable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");
    PrintStringToFile($sum_file, 1, sprintf("  %-*s  locations/scores of hits defined by HMM(s)\n", $max_file_name_width, $tab_file2print));

    $$tab_file_R            = $tab_file;
    $$max_file_name_width_R = $max_file_name_width;
    $$description_width_R   = $description_width;
    return;
}


#####################################################################
# Subroutine: classify_and_extract_subseqs()
# Incept:     EPN, Mon Nov  3 17:14:33 2008
# 
# Purpose:    Extract subsequences given the cmsearch tab file 
#             output. Also determine the CM c that has the highest
#             scoring hit to each sequence s and classify s as 
#             belonging to c. Then when we do alignment, for each 
#             CM we align all of that CM's seqs to it. Each sequence
#             is classified as belonging to only 1 CM. If only
#             1 CM exists in the CM file, then all sequences
#             will automatically be classified to it.
#             
# Arguments: 
# $opt_HR:                         reference to the hash of command-line options
# $tab_file:                       name of the tab output file.
# $target_file:                    name of the target sequence filee
# $out_dir_root:                   output root, for naming output files
# $sfetch:                         esl-sfetch executable
# $max_file_name_width:            max length of a file name
# $indi_cm_name_AR:                reference to array of individual CM names
# $bestmatch_cm_HR:                RETURN; reference to hash of best-matching CM for each sequence
# $new_target_file_per_cm_name_HR: RETURN; reference to hash of newly created target sequence file (key is CM name)
# $hmmscores2print_HR:             RETURN; reference to hash of hmm scores to print
# $max_seq_name_width_R:           RETURN; max length of a sequence name
# $sum_file:                       file to print output file notices to
#
# Returns:    Nothing, except values stored in RETURN arguments (see above)
#
# Exits:      If an executable call doesn't finish with a non-zero status code, we exit. 
# 
####################################################################
sub classify_and_extract_subseqs { 
    my $narg_expected = 12;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, classify_and_extract_subseqs() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($opt_HR, $tab_file, $target_file, $out_dir_root, $sfetch, $max_file_name_width, $indi_cm_name_AR, $bestmatch_cm_HR, $new_target_file_per_cm_name_HR,
	$hmmscores2print_HR, $max_seq_name_width_R, $sum_file) = @_;
    my $cur_max_seq_name_width = 0;
    my $max_seq_name_width = 0;

    my %seq_exists_in_order_array_H = ();
    my @cm_name_from_tab_file_A = ();
    my($cm_name, $line);
    my($model_name, $seq_name, $tstart, $tend, $qstart, $qend, $bit, $E, $gc, $tlen, $m, $i, $max_cm_name_width);
    my %bit_cm_seq_HH = ();
    my %bit_seq_cm_HH = ();
    my %start_cm_seq_HH = ();
    my %end_cm_seq_HH = ();
    my @tmp_A = ();

    $max_cm_name_width = MaxLengthScalarInArray($indi_cm_name_AR); 
    if($max_cm_name_width < length("model name")) { $max_cm_name_width = length("model name"); } 

    # Parse tab file, keep track of best scoring hit above our min length and min bit score for each CM for each seq
    if(open(TAB, $tab_file) == 0) { printf STDERR ("ERROR, could not open $tab_file for reading.\n"); exit(1); }
    $cm_name = "";

    # Set $min_len and $min_bit based on command-line options and defaults
    my ($min_len, $min_bit);
    if($opt_HR->{"-l"} ne "") { $min_len = $opt_HR->{"-l"}; }
    else                      { $min_len = $df_min_len;     }
    if($opt_HR->{"-b"} ne "") { $min_bit = $opt_HR->{"-b"}; }
    else                      { $min_bit = $df_min_bit;     }
    my $do_truncate;
    if($opt_HR->{"--no-trunc"}) { $do_truncate = 0; }
    else                        { $do_truncate = 1; }
    
    my @seq_order_A = ();
    while($line = <TAB>) { 
	chomp $line;
	if($line =~ m/^\#\s+CM\:\s+(.+)$/) { 
	    push(@cm_name_from_tab_file_A, $1);
	}
	if($line !~ m/^\#/) { 
	    $line =~ s/^\s+//;
	    @tmp_A = split(/\s+/, $line);
	    if(scalar(@tmp_A) != 9) { 
		printf STDERR ("ERROR, unable to read following line of $tab_file, it should have 9 tokens.\n"); printf("$line\n"); exit(1); 
	    }
	    ($cm_name, $seq_name, $tstart, $tend, $qstart, $qend, $bit, $E, $gc) = @tmp_A;
	    if($tend > $tstart) { $tlen = $tend - $tstart + 1; }
	    else                { $tlen = $tstart - $tend + 1; }
	    if((!(exists($bit_cm_seq_HH{$cm_name}{$seq_name}))) || ($bit > $bit_cm_seq_HH{$cm_name}{$seq_name})) { 
		if(($tlen >= $min_len) && ($bit >= $min_bit)) { 
		    $bit_cm_seq_HH{$cm_name}{$seq_name}   = $bit;
		    $bit_seq_cm_HH{$seq_name}{$cm_name}   = $bit;
		    $start_cm_seq_HH{$cm_name}{$seq_name} = $tstart;
		    $end_cm_seq_HH{$cm_name}{$seq_name}   = $tend;
		    if(!(exists($seq_exists_in_order_array_H{$seq_name}))) { push(@seq_order_A, $seq_name); $seq_exists_in_order_array_H{$seq_name} = 1; }
		}
	    }
	}
    }
    # Make sure our tab file contains the same CMs in the same order as our CM file did.
    if(scalar(@cm_name_from_tab_file_A) != scalar(@{$indi_cm_name_AR})) { 
	printf STDERR ("ERROR, %d CMs read in tab file != %d CMs read from CM file.\n", scalar(@cm_name_from_tab_file_A), scalar(@{$indi_cm_name_AR}));
	exit(1);
    }
    for($m = 0; $m < scalar(@cm_name_from_tab_file_A); $m++) { 
	if($cm_name_from_tab_file_A[$m] ne $indi_cm_name_AR->[$m]) { 
	    printf STDERR ("ERROR, CM number %d (%s) from the tab file output is not the same as CM %d from the CM file (%s).\n", $cm_name_from_tab_file_A[$m], $indi_cm_name_AR->[$m]);
	    exit(1);
	}
    }

    # classify each seq: determine highest scoring model for each seq
    # also keep track of second best scoring model for each seq, so 
    # we can print that to the .scores file, if only one model scored
    # above threshold, store second best scoring model as best scoring 
    # model, we'll sort this out when we print the scores file
    my @tmp_bit_A = ();
    my @tmp_cm_A = ();
    my %by_cm_name_HA = ();
    my %by_cm_bit_HA = ();
    my %by_cm_start_HA = ();
    my %by_cm_end_HA = ();
    my ($dashes, $output, $command, $command_worked);
    my ($winner_idx, $winner_cm, $winner_bit);
    my ($second_idx, $second_cm, $second_bit);
    foreach $seq_name (@seq_order_A) { # only sequences with at least 1 model that scored above threshold are in @seq_order_A
	@tmp_bit_A = ();
	@tmp_cm_A  = ();
	foreach $cm_name (sort keys (%{$bit_seq_cm_HH{$seq_name}})) { 
	    push(@tmp_bit_A, $bit_seq_cm_HH{$seq_name}{$cm_name});
	    push(@tmp_cm_A, $cm_name);
	}
	$winner_idx = ArgmaxArray(\@tmp_bit_A);
	$winner_cm  = $tmp_cm_A[$winner_idx];
	$winner_bit = $tmp_bit_A[$winner_idx];

	# temporarily set second-best model as best, this will be overwritten if a second-best model exists
	$second_idx = $winner_idx;
	$second_cm  = $winner_cm;
	$second_bit = $winner_bit;

	splice(@tmp_bit_A, $winner_idx, 1);
	splice(@tmp_cm_A,  $winner_idx, 1);
	if(scalar(@tmp_bit_A) > 0) { 
	    $second_idx = ArgmaxArray(\@tmp_bit_A);
	    $second_cm  = $tmp_cm_A[$second_idx];
	    $second_bit = $tmp_bit_A[$second_idx];
	}

	push(@{$by_cm_name_HA{$winner_cm}},  $seq_name);
	push(@{$by_cm_bit_HA{$winner_cm}},   $winner_bit);
	push(@{$by_cm_start_HA{$winner_cm}}, $start_cm_seq_HH{$winner_cm}{$seq_name});
	push(@{$by_cm_end_HA{$winner_cm}},   $end_cm_seq_HH{$winner_cm}{$seq_name});

	$hmmscores2print_HR->{$seq_name} = sprintf("%d %d %.2f %s %.2f",
						   $start_cm_seq_HH{$winner_cm}{$seq_name}, $end_cm_seq_HH{$winner_cm}{$seq_name}, 
						    $winner_bit, $second_cm, $second_bit);
	$bestmatch_cm_HR->{$seq_name} = $winner_cm;
    }

    # For each CM c, list the target sequences that score highest to c in tabular format
    # and then fetch them with esl-sfetch
    my ($index_file, $ncm_with_at_least_one_seq, $list_file, $list_file2print, $sfetch_in_file, $nwinners, $hits_file, $hits_file2print, $sfetch_options);
    $ncm_with_at_least_one_seq = 0;
    $index_file = $target_file . ".ssi";
    
    #if index file exists, remove it and remake it (wasteful, but this is the only way to know for sure that the index was created for this specific file)
    if(-e $index_file) { UnlinkFile($index_file, $log_file); } 
    $command = "$sfetch \-\-index $target_file"; 
    RunExecutable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");

    for($m = 0; $m < scalar(@{$indi_cm_name_AR}); $m++) { 
	$cm_name = $indi_cm_name_AR->[$m];
	$list_file = $out_dir_root . "." . $cm_name . ".hits.list"; 
	$list_file2print = $out_root . "." . $cm_name . ".hits.list"; 
	$sfetch_in_file = $out_dir_root . "." . $cm_name . ".hits.in";
	if(!(exists($by_cm_name_HA{$cm_name}))) { $nwinners = 0; }
	else                                    { $nwinners = scalar(@{$by_cm_name_HA{$cm_name}}); }

	if($nwinners > 0) { 
	    $ncm_with_at_least_one_seq++;
	    if(open(OUTLIST,  ">" . $list_file) == 0)      { printf STDERR ("ERROR, could not open $list_file for writing.\n"); exit(1); }
	    if(open(SFETCHIN, ">" . $sfetch_in_file) == 0) { printf STDERR ("ERROR, could not open $sfetch_in_file for writing.\n"); exit(1); }

	    # determine max seq name width 
	    $cur_max_seq_name_width = length("target name");
	    for($i = 0; $i < $nwinners; $i++) { if(length($by_cm_name_HA{$cm_name}[$i]) > $cur_max_seq_name_width) { $cur_max_seq_name_width = length($by_cm_name_HA{$cm_name}[$i]); } }
	    $dashes = "";
	    for($i = 0; $i < $cur_max_seq_name_width; $i++) { $dashes .= "-"; }
	    printf OUTLIST  ("# List of %d subsequences to align to CM: $cm_name\n", $nwinners);
	    printf OUTLIST  ("# Created by ssu-align.pl.\n#\n");
	    printf OUTLIST  ("# %-*s  %6s  %6s  %8s\n", $cur_max_seq_name_width, "target name", "start", "stop", "score");
	    printf OUTLIST  ("# %*s  %6s  %6s  %8s\n", $cur_max_seq_name_width, $dashes, "------", "------", "--------");

	    for($i = 0; $i < $nwinners; $i++) { 
		#PrintStringToFile($sum_file, 1, sprintf("%4d  $cm_name  %25s  %7.2f  %8d  %8d\n", ($i+1), $by_cm_name_HA{$cm_name}[$i], $by_cm_bitHA{$cm_name}[$i], $by_cm_startHA{$cm_name}[$i], $by_cm_endHA{$cm_name}[$i]));
		printf OUTLIST ("  %-*s  %6d  %6d  %8.2f\n", $cur_max_seq_name_width, $by_cm_name_HA{$cm_name}[$i], $by_cm_start_HA{$cm_name}[$i], $by_cm_end_HA{$cm_name}[$i], $by_cm_bit_HA{$cm_name}[$i]);
		if($do_truncate) { printf SFETCHIN ("$by_cm_name_HA{$cm_name}[$i]\t$by_cm_start_HA{$cm_name}[$i]\t$by_cm_end_HA{$cm_name}[$i]\t$by_cm_name_HA{$cm_name}[$i]\n"); }
		else             { printf SFETCHIN ("$by_cm_name_HA{$cm_name}[$i]\n"); }
	    }
	    #PrintStringToFile($sum_file, 1, sprintf("\n"));
	    close(OUTLIST);
	    close(SFETCHIN);
	    PrintStringToFile($sum_file, 1, sprintf("  %-*s  list of sequences to align with $cm_name CM\n", $max_file_name_width, $list_file2print));

	    $hits_file = $out_dir_root . "." . $cm_name . ".hits.fa";
	    $hits_file2print = $out_root . "." . $cm_name . ".hits.fa";
	    if(-e ($hits_file)) { UnlinkFile($hits_file, $log_file); }
	    if($do_truncate) { $sfetch_options = "-Cf"; }
	    else             { $sfetch_options = "-f";  }
	    $command = "$sfetch -o $hits_file $sfetch_options $target_file $sfetch_in_file";
	    RunExecutable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");
	    #PrintStringToFile($sum_file, 1, sprintf("esl-sfetch -Cf $target_file $listfile > $hits_file\n"));
	    if(-e $hits_file) { 
		if($nwinners > 1) { PrintStringToFile($sum_file, 1, sprintf("  %-*s  %7d sequences to align with $cm_name CM\n", $max_file_name_width, $hits_file2print, scalar(@{$by_cm_name_HA{$cm_name}}))); }
		else              { PrintStringToFile($sum_file, 1, sprintf("  %-*s  %7d sequence  to align with $cm_name CM\n", $max_file_name_width, $hits_file2print, scalar(@{$by_cm_name_HA{$cm_name}}))); }
	    }
	    UnlinkFile($sfetch_in_file, $log_file);
	    $new_target_file_per_cm_name_HR->{$cm_name} = $hits_file;
	    if($cur_max_seq_name_width > $max_seq_name_width) { $max_seq_name_width = $cur_max_seq_name_width; };
	}
    }
    if($ncm_with_at_least_one_seq == 0) { 
	printf STDERR ("\nERROR, 0 seqs had cmsearch hits with bit score > $min_bit and length > $min_len to any of the %d CMs in the tab file $tab_file.\nYou can change the minimum bit score to <x> with -b <x>, and minimum length to <n> with -l <n>.\n", scalar(@{$indi_cm_name_AR}));
	exit(1);
    }

    $$max_seq_name_width_R = $max_seq_name_width;
    return;
}


#####################################################################
# Subroutine: align_subseqs()
# Incept:     EPN, Mon Nov  3 17:20:42 2008
# 
# Purpose:    For each CM c, align all of c's classified sequences to
#             c using cmalign. If 0 seqs are classified as belonging
#             to c, skip the alignment step for c.
#
# Arguments:
# $opt_HR:                         reference to the hash of command-line options
# $out_dir_root:                   output directory and output root, concatenated
# $cmalign:                        cmalign executable
# $max_file_name_width:            num chars in max length of a file name
# $description_width:              num chars in description field of output
# $weight:                         esl-weight executable
# $indi_cm_name_AR:                reference to array of individual CM names
# $new_target_file_per_cm_name_HR: reference to hash, key CM name, value target file to align with that CM
# $cmscores2print_HR:              reference to hash of CM scores to print
# $sum_file:                       file to print output file notices to
#
# Returns:    Nothing.
#
# Exits:      If a cmalign call doesn't finish with a zero status
#             code. cmsearch should print an error message to
#             standard error if this occurs.
#  
####################################################################
sub align_subseqs { 
    my $narg_expected = 10;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, align_subseqs() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($opt_HR, $out_dir_root, $cmalign, $max_file_name_width, $description_width, $weight, $indi_cm_name_AR, $new_target_file_per_cm_name_HR, $cmscores2print_HR, $sum_file) = @_;

    my($i, $ncm, $m, $cm_file_name, $cm_name, $hits_file, $align_psecs, $cmalign_out, $cmalign_stk);
    my($cmalign_out2print, $cmalign_stk2print, $fil_cmalign_stk, $fil_cmalign_stk2print, $dashes1, $dashes2);
    my($line, $seq_name, $cmsc, $cmstructsc, $command, $command_worked, $tmp);
    my @el_A = ();

    $dashes1 = ""; for($i = 0; $i < $max_file_name_width; $i++) { $dashes1 .= "-"; } 
    $dashes2 = ""; for($i = 0; $i < $description_width;   $i++) { $dashes2 .= "-"; } 
    PrintStringToFile($sum_file, 1, sprintf("#\n"));
    PrintStringToFile($sum_file, 1, sprintf("# Stage 2: Aligning each sequence to its best-matching model...\n"));
    PrintStringToFile($sum_file, 1, sprintf("#\n"));
    PrintStringToFile($sum_file, 1, sprintf("# %-*s  %s\n", $max_file_name_width, "output file name", "description"));
    PrintStringToFile($sum_file, 1, sprintf("# %-*s  %-*s\n", $max_file_name_width, $dashes1, $description_width, $dashes2));

    $ncm = scalar(@{$indi_cm_name_AR});
    for($m = 1; $m <= $ncm; $m++) { 
	$cm_name = $indi_cm_name_AR->[($m-1)];
	if(exists($new_target_file_per_cm_name_HR->{$cm_name})) { # >= 1 sequences in this set were classified as the current CM
	    $hits_file      = $new_target_file_per_cm_name_HR->{$cm_name};
	    
	    $cmalign_out       = $out_dir_root . "." . $cm_name . ".cmalign";
	    $cmalign_out2print = $out_root     . "." . $cm_name . ".cmalign";
	    if($opt_HR->{"--filter"} ne "") { 
		$cmalign_stk           = $out_dir_root . "." . $cm_name . ".nf.stk";
		$cmalign_stk2print     = $out_root     . "." . $cm_name . ".nf.stk";
		$fil_cmalign_stk       = $out_dir_root . "." . $cm_name . ".stk";
		$fil_cmalign_stk2print = $out_root     . "." . $cm_name . ".stk";
	    }
	    else { 
		$cmalign_stk           = $out_dir_root . "." . $cm_name . ".stk";
		$cmalign_stk2print     = $out_root     . "." . $cm_name . ".stk";
	    }
	    
	    my $mxsize = $df_mxsize;
	    if($opt_HR->{"--mxsize"} ne "") { $mxsize = $opt_HR->{"--mxsize"}; }
	    my $prob_opt = "-p";
	    if($opt_HR->{"--no-prob"}) { $prob_opt = ""; }
	    $command = "$cmalign --cm-idx $m $prob_opt --mxsize $mxsize --sub -o $cmalign_stk $cm_file $hits_file > $cmalign_out 2>&1"; 
	    RunExecutable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");
	    
	    #open and parse the cmalign output
	    if(open(CMALIGN, $cmalign_out) == 0) { printf STDERR ("ERROR, could not open $cmalign_out for reading.\n"); exit(1); }
	    while($line = <CMALIGN>) { 
		if($line =~ s/^\s+\d+\s+//) { 
		    @el_A = split(/\s+/, $line);
		    $seq_name   = $el_A[0];
		    $cmsc       = $el_A[2];
		    $cmstructsc = $el_A[3];
		    $cmscores2print_HR->{$seq_name} = sprintf("%.2f %.2f", $cmsc, $cmstructsc);
		}
	    }
	    close(CMALIGN);

	    if($opt_HR->{"--filter"} ne "") { 
		$command = "$weight -f --idf " . $opt_HR->{"--filter"} . " $cmalign_stk > $fil_cmalign_stk 2>&1";
		RunExecutable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");
		PrintStringToFile($sum_file, 1, sprintf("  %-*s  complete %s alignment\n", $max_file_name_width, $cmalign_stk2print, $cm_name));
		PrintStringToFile($sum_file, 1, sprintf("  %-*s  filtered %s alignment\n", $max_file_name_width, $fil_cmalign_stk2print, $cm_name));
	    }
	    else { 
		PrintStringToFile($sum_file, 1, sprintf("  %-*s  %s alignment\n", $max_file_name_width, $cmalign_stk2print, $cm_name));
	    }
	    PrintStringToFile($sum_file, 1, sprintf("  %-*s  %s cmalign output\n", $max_file_name_width, $cmalign_out2print, $cm_name));
	}
    }
    return;
}


#####################################################################
# Subroutine: print_scores_file
# Incept:     EPN, Tue Jun 16 14:39:38 2009
# 
# Purpose:    Print the scores file with CM and HMM scores.
#             We want to print a line for each target sequence, since
#             we only aligned those that scored above a threshold,
#             this means we have to revisit the target database and
#             read all the seqs.
#
# Arguments: 
# $target_file:        name of the target sequence filee
# $ncm                 number of CMs we've searched with
# $scores_file:        the name of the 'scores' file we'll print to
# $scores_file2print:  name of scores file as we print to screen
# $max_seq_name_width: num chars in max length sequence
# $indi_cm_name_AR:    reference to array of CM names
# $bestmatch_cm_HR:    reference to hash of best-matching CM for each sequence
# $cmscores2print_HR:  reference to hash with CM scores and CM structure scores
# $hmmscores2print_HR: reference to hash with HMM scores
# $sum_file:           file to print output file notices to
# 
# Returns:    Nothing, if it returns, everything is valid.
# 
####################################################################
sub print_scores_file { 
    my $narg_expected = 10;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, print_scores_file() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($target_file, $ncm, $scores_file, $scores_file2print, $max_seq_name_width, $indi_cm_name_AR, $bestmatch_cm_HR, $cmscores2print_HR, $hmmscores2print_HR, $sum_file) = @_;

    my ($seq_name, $cmscore2print);
    my ($i, $bestmatch_cm, $max_cm_name_width);
    my ($dashes_seqname, $dashes_cmname, $dashes1, $dashes2);
    my ($cmsc, $cmstructsc, $start, $end, $whmmsc, $secondhmm, $shmmsc);
    my ($best_string, $nleading_spaces, $ntrailing_spaces, $second_string, $idx, $line);

    $dashes_seqname = ""; for($i = 0; $i < $max_seq_name_width; $i++) { $dashes_seqname .= "-"; } 

    $max_cm_name_width = MaxLengthScalarInArray($indi_cm_name_AR); 
    if($max_cm_name_width < length("best-matching model")) { $max_cm_name_width = length("best-matching model"); } 
    $dashes_cmname  = ""; for($i = 0; $i < $max_cm_name_width; $i++)  { $dashes_cmname .= "-"; } 
    
    if(open(SCORES,  ">" . $scores_file) == 0) { printf STDERR ("ERROR, could not open $scores_file for writing.\n"); exit(1); }
    if(open(TARGET, $target_file) == 0) { printf STDERR ("ERROR, could not open $target_file for reading.\n"); exit(1); }
    $i = 0;

    #print headers
    $dashes1 = ""; for($i = 0; $i < $max_cm_name_width + 39; $i++)  { $dashes1 .= "-"; } 
    $dashes2 = ""; for($i = 0; $i < $max_cm_name_width + 9;  $i++)  { $dashes2 .= "-"; } 

    # build column headers
    $best_string = "";
    $nleading_spaces  = int(($max_cm_name_width + 39 - length("best-matching model"))/2.);
    $ntrailing_spaces = ($max_cm_name_width + 39 - length("best-matching model")) - $nleading_spaces;
    for($i = 0; $i < $nleading_spaces;   $i++)  { $best_string .= " "; }
    $best_string .= "best-matching model";
    for($i = 0; $i < $ntrailing_spaces;  $i++)  { $best_string .= " "; }

    $second_string = "";
    $nleading_spaces  = int(($max_cm_name_width + 9 - length("second-best model"))/2.);
    $ntrailing_spaces = ($max_cm_name_width + 9 - length("second-best model")) - $nleading_spaces;
    for($i = 0; $i < $nleading_spaces;   $i++)  { $second_string .= " "; }
    $second_string .= "second-best model";
    for($i = 0; $i < $ntrailing_spaces;  $i++)  { $second_string .= " "; }

    printf SCORES ("# %7s  %-*s  %-*s", "", $max_seq_name_width, "", $max_cm_name_width + 39, $best_string);
    if($ncm > 1) { printf SCORES ("  %-*s", $max_cm_name_width + 9, $second_string); }
    printf SCORES ("\n");

    printf SCORES ("# %7s  %-*s  %-*s", "", $max_seq_name_width, "", $max_cm_name_width + 39, $dashes1);
    if($ncm > 1) { printf SCORES ("  %-*s", $max_cm_name_width + 9, $dashes2); }
    printf SCORES ("\n");

    printf SCORES ("# %7s  %-*s  %-*s  %4s  %4s  %7s  %7s  %7s", "idx", $max_seq_name_width, "sequence name", $max_cm_name_width, "model name",   "beg",  "end",  "CM sc",  "struct",  "HMM sc");
    if($ncm > 1) { printf SCORES ("  %-*s  %7s  %7s", $max_cm_name_width, "model name",   "HMM sc",  "HMMdiff"); }
    printf SCORES ("\n");

    printf SCORES ("# %7s  %-*s  %-*s  %4s  %4s  %7s  %7s  %7s", "-------", $max_seq_name_width, $dashes_seqname, $max_cm_name_width, $dashes_cmname, "----", "----", "-------", "-------", "-------");
    if($ncm > 1) { printf SCORES ("  %-*s  %7s  %7s", $max_cm_name_width, $dashes_cmname, "-------", "-------"); }
    printf SCORES ("\n");

    $idx = 1;
    while($line = <TARGET>) { 
	if($line =~ s/^\>//) { 
	    chomp $line;
	    $line =~ s/\s+.*$//;
	    $seq_name = $line;
	    if(exists($bestmatch_cm_HR->{$seq_name})) { 
		$bestmatch_cm = $bestmatch_cm_HR->{$seq_name};
		($cmsc, $cmstructsc)                         = split(/\s+/, $cmscores2print_HR->{$seq_name});
		($start, $end, $whmmsc, $secondhmm, $shmmsc) = split(/\s+/, $hmmscores2print_HR->{$seq_name});

		printf SCORES ("  %7d  %-*s  %-*s  %4d  %4d  %7.2f  %7.2f  %7.2f", $idx, $max_seq_name_width, $seq_name, $max_cm_name_width, $bestmatch_cm, $start, $end, $cmsc, $cmstructsc, $whmmsc);
		# if there was only 1 model that scored above threshold, we stored it as both the first and second model 
		if($ncm > 1 && ($secondhmm ne $bestmatch_cm)) { printf SCORES ("  %-*s  %7.2f  %7.2f", $max_cm_name_width, $secondhmm, $shmmsc, ($whmmsc - $shmmsc)); }
		elsif($ncm > 1)                               { printf SCORES ("  %-*s  %7s  %7s",    $max_cm_name_width, "-", "-", "-"); }
	    }
	    else {
		printf SCORES ("  %7d  %-*s  %-*s  %4s  %4s  %7s  %7s  %7s", $idx, $max_seq_name_width, $seq_name, $max_cm_name_width, $df_none_name, "-", "-", "-", "-", "-");
		if($ncm > 1) { printf SCORES ("  %-*s  %7s  %7s", $max_cm_name_width, "-", "-", "-"); }
	    }
	    printf SCORES ("\n");
	    $idx++;
	}
    }
    close(TARGET);
    close(SCORES);
}

