#!/usr/bin/perl
#
# ssu-align.pl
# Eric Nawrocki
# EPN, Wed Oct 29 10:12:05 2008
#
# Usage: perl ssu-align [options]
#             <target database sequence file name>
#             <output root for output files>
#             
# Synopsis:
# Aligns SSU sequences to SSU CMs.
# Given a CM file with >=1 SSU CMs and a target sequence file with putative
# SSU sequences: 
# Step 1. define likely start/ends (seq boundaries) to align using cmsearch 
#         in viterbi HMM mode (or forward HMM mode if --forward).
# Step 2. extract those subsequences into a new target fasta file.
# Step 3. sequences in new fasta file from step 2 are aligned to the CM.
#
# If more than x>1 CMs exist in the CM file, then x new subsequence files 
# are created in Step 2, one for each CM and containing the sequences that
# score highest to that CM. Then in Step 3, each CM is used to align its 
# target file. For example the CM file may contain archael, bacterial, and 
# eukaryotic CMs, and step 1 will 'classify' each seq as arc, bac, or euk, 
# and then in Step 3 the appropriate CM is used to align each sequence. 
#
# See definition of $options_usage for options, below.
#
use Getopt::Long;
use Cwd 'abs_path';
use strict;

my $total_time = -1 * time();
my $usage = "Usage: ssu-align [-options] <sequence file> <output dir and file name root>\n";
my $options_usage  = "where general options are:\n";
#                           1         2         3         4         5         6         7         8
#                  12345678901234567890123456789012345678901234567890123456789012345678901234567890
$options_usage .= "  -h     : show brief help on version and usage\n";
$options_usage .= "  -1     : output alignments in non-interleaved, 1 line/seq format\n";
$options_usage .= "  -m <s> : use CM file <f> instead of the default CM file\n";
$options_usage .= "  -F     : force; if <output dir> already exists - empty it and fill it\n" ,
$options_usage .= "  -b <f> : set minimum bit score of a surviving subsequence as <x> (default: 100)\n";
$options_usage .= "  -l <n> : set minimum length    of a surviving subsequence as <n> (default: 1)\n";

$options_usage .= "\noptions for running ssu-align in 'prep' mode to split up a large job:\n";
$options_usage .= "  --prep-n <n> : split target seq file into multiple files with <n> seqs each\n";
$options_usage .= "  --prep-c <n> : split target seq file into <n> files with equal number of seqs\n";

$options_usage .= "\noptions for skipping either the 1st (search) stage or 2nd (alignment) stage)\n";
$options_usage .= "  --no-align  : only search target sequence file for hits, skip alignment step\n";
$options_usage .= "  --no-search : only align  target sequence file, skip initial search step\n"; 

$options_usage .= "\nexpert options for tuning the initial search stage:\n";
$options_usage .= "  --no-trunc : do not truncate seqs to HMM predicted start/end, align full seqs\n";
$options_usage .= "  --toponly  : only search the top strand [default: search both strands]\n";
$options_usage .= "  --forward  : use the HMM forward algorithm for searching, not HMM viterbi\n";
$options_usage .= "  --global   : search with globally configured HMM [default: local]\n";

$options_usage .= "\nexpert options for tuning the alignment stage:\n";
$options_usage .= "  --filter <f> : filter aln based on seq identity, allow no 2 seqs > <x> identical\n";
$options_usage .= "  --no-prob    : DO NOT append posterior probabilities to alignments\n";
$options_usage .= "  --keep       : DO NOT erase local copies of individual CM files after running\n\n";
$options_usage .= "  --mxsize <f> : increase mx size for cmalign to <x> Mb (default: 4096)\n";

###################
# Process options #
###################
my %opt_H = ();              # key: option (example "-h"); value: option argument (example ("0" or "1") if option takes no arg, actual argument if option takes arg)
my %opt_takes_arg_H  = ();   # key: option; value: "1" if option takes argument, "0" if not
my @opt_order_A  = ();       # order of options for printing in banner
my %opt_is_prep_H = ();      # key: option; value: "1" if option will get passed to child ssu-align calls in prep mode, "0" if not

$opt_takes_arg_H{"-h"}          = 0;  push(@opt_order_A, "-h");           $opt_is_prep_H{"-h"}          = 0;
$opt_takes_arg_H{"-1"}          = 0;  push(@opt_order_A, "-1");           $opt_is_prep_H{"-1"}          = 1;
$opt_takes_arg_H{"-m"}          = 1;  push(@opt_order_A, "-m");           $opt_is_prep_H{"-m"}          = 1;
$opt_takes_arg_H{"-F"}          = 0;  push(@opt_order_A, "-F");           $opt_is_prep_H{"-F"}          = 0;
$opt_takes_arg_H{"-b"}          = 1;  push(@opt_order_A, "-b");           $opt_is_prep_H{"-b"}          = 1;
$opt_takes_arg_H{"-l"}          = 1;  push(@opt_order_A, "-l");           $opt_is_prep_H{"-l"}          = 1;
$opt_takes_arg_H{"--prep-n"}    = 1;  push(@opt_order_A, "--prep-n");     $opt_is_prep_H{"--prep-n"}    = 1;
$opt_takes_arg_H{"--prep-c"}    = 1;  push(@opt_order_A, "--prep-c");     $opt_is_prep_H{"--prep-c"}    = 1;
$opt_takes_arg_H{"--no-align"}  = 0;  push(@opt_order_A, "--no-align");   $opt_is_prep_H{"--no-align"}  = 1;
$opt_takes_arg_H{"--no-search"} = 0;  push(@opt_order_A, "--no-search");  $opt_is_prep_H{"--no-search"} = 1;
$opt_takes_arg_H{"--no-trunc"}  = 0;  push(@opt_order_A, "--no-trunc");   $opt_is_prep_H{"--no-trunc"}  = 1;
$opt_takes_arg_H{"--toponly"}   = 0;  push(@opt_order_A, "--toponly");    $opt_is_prep_H{"--toponly"}   = 1;
$opt_takes_arg_H{"--forward"}   = 0;  push(@opt_order_A, "--forward");    $opt_is_prep_H{"--forward"}   = 1;
$opt_takes_arg_H{"--global"}    = 0;  push(@opt_order_A, "--global");     $opt_is_prep_H{"--global"}    = 1;
$opt_takes_arg_H{"--filter"}    = 1;  push(@opt_order_A, "--filter");     $opt_is_prep_H{"--filter"}    = 1;
$opt_takes_arg_H{"--no-prob"}   = 0;  push(@opt_order_A, "--no-prob");    $opt_is_prep_H{"--no-prob"}   = 1;
$opt_takes_arg_H{"--keep"}      = 0;  push(@opt_order_A, "--keep");       $opt_is_prep_H{"--keep"}      = 1;
$opt_takes_arg_H{"--mxsize"}    = 1;  push(@opt_order_A, "--mxsize");     $opt_is_prep_H{"--mxsize"}    = 1;

#set default options
foreach $opt (%opt_takes_arg_H) { 
    if($opt_takes_arg_H{$opt}) { $opt_H{$opt} = ""; }
    else                       { $opt_H{$opt} = 0; }
}

my $df_min_bit = 100;
my $df_min_len = 1;
my $df_mxsize = 4096;
my $df_cmsearch_T = -1;

Getopt::Long::Configure ("bundling");
my $opt_return = GetOptions
    ('h'         => \$opt_H{"-h"}, 
     '1'         => \$opt_H{"-1"},
     'm=s'       => \$opt_H{"-m"},
     'F'         => \$opt_H{"-F"},
     'b=f'       => \$opt_H{"-b"},
     'l=n'       => \$opt_H{"-l"},
     'prep-n=n'  => \$opt_H{"--prep-n"},
     'prep-c=n'  => \$opt_H{"--prep-c"},
     'no-align'  => \$opt_H{"--no-align"},
     'no-search' => \$opt_H{"--no-search"},
     'no-trunc'  => \$opt_H{"--no-trunc"},
     'toponly'   => \$opt_H{"--toponly"},
     'forward'   => \$opt_H{"--forward"},
     'global'    => \$opt_H{"--global"},
     'filter=f'  => \$opt_H{"--filter"},
     'no-prob'   => \$opt_H{"--no-prob"},
     'keep'      => \$opt_H{"--keep"},
     'mxsize'    => \$opt_H{"--mxsize"});

if($opt_return != 1) { exit(1); }

if ($opt_H{"-h"}) { print $usage . "\n"; print $options_usage; exit(1); } 

# Check for incompatible option combinations.
if(($opt_H{"--no-align"}) && 
   (($opt_H{"--filter"} ne '') ||
    ($opt_H{"-1"})             ||
    ($opt_H{"--no-prob"})      ||
    ($opt_H{"--keep"})         ||
    ($opt_H{"--mxsize"}))) { 
    printf STDERR ("\nERROR, --no-align is incompatible with alignment-specific options: -1,--filter,--no-prob,--keep, and --mxsize.\n"); exit(1); 
}

if(($opt_H{"--no-search"}) && 
   (($opt_H{"-b"} ne '') ||
    ($opt_H{"-l"})      ||
    ($opt_H{"--toponly"})  ||
    ($opt_H{"--no-trunc"})  ||
    ($opt_H{"--forward"})  ||
    ($opt_H{"--global"})) P
    printf STDERR ("\nERROR, --no-search is incompatible with search-specific options: -b,-l,--toponly,--no-trunc,--forward, and --global.\n"); exit(1); 
}

if(($opt_H{"--prep-n"} ne "") && ($opt_H{"--prep-c"} ne "")) { 
    printf STDERR ("\nERROR, --prep-n and --prep-c are incompatible, choose one or the other.\n"); exit(1);
}    
# Check for incompatible option ranges
if(($opt_H{"-l"} ne "")       && ($opt_H{"-l"} <= 0))       { printf STDERR ("\nERROR, with -l <n>, <n> must be greater than 0.\n"); exit(1); }
if(($opt_H{"--prep-n"} ne "") && ($opt_H{"--prep-n"} <= 0)) { printf STDERR ("\nERROR, with --prep-n <n>, <n> must be greater than 0.\n"); exit(1); }
if(($opt_H{"--prep-c"} ne "") && ($opt_H{"--prep-c"} <= 0)) { printf STDERR ("\nERROR, with --prep-c <n>, <n> must be greater than 0.\n"); exit(1); }
if(($opt_H{"--mxsize"} ne "") && ($opt_H{"--mxsize"} <= 0.)) { printf STDERR ("\nERROR, with --mxsize <f>, <f> must be greater than 0.\n"); exit(1); }
if(($opt_H{"--filter"} ne "") && (($opt_H{"--filter"} < 0.) || ($opt_H{"--filter"} > 1.))) { printf STDERR ("\nERROR, with --filter <f>, <f> must be between 0. and 1.\n"); exit(1); }

################
# Print banner #
################
my @log2printA = ();
print_banner($0, \%opt_H, \@ARGV, \@log2printA);

if(scalar(@ARGV) != 1) {   
    print "Incorrect number of command line arguments.\n";
    print $usage;
    print "\nTo see more help on available options, do ssu-draw -h\n\n";
    exit(1);
}
my ($target_file, $out_root) = @ARGV;


##################################################################
# Validate that everything is go and determine output file names #
##################################################################
my ($ssualign, $cmsearch, $cmalign, $sfetch, $weight, $cm_file);
validate_and_setup($target_file, \$opt_H, \$ssualign, \$cmsearch, \$cmalign, \$sfetch, \$weight, \$cm_file);

# determine number of sequences in the target sequence file
my $nseq_target_file = determine_num_seqs($target_file);

# create the output directory we'll populate with our output files
my $out_dir      = $out_root;
my $out_dir_root = $out_dir . "/" . $out_root;
create_output_dir($out_dir, \$opt_H, $cm_file); 

my (@indi_cm_name_A, @indi_cm_file_name_A, @indi_cm_clen_A, @indi_cm_nbif_A);
process_cm_file($do_prep, $my_cm_file_copy, $out_root, \@indi_cm_name_A, \@indi_cm_file_name_A, \@indi_cm_clen_A, \@indi_cm_nbif_A);
my $ncm = scalar(@indi_cm_file_name_A); 
if((!$do_search) && ($ncm > 1)) { printf("ERROR, the -a option only works if the CM file contains exactly 1 CM, $cm_file has $ncm CMs in it.\n"); exit(1); }

my $log_file       = $out_dir_root . ".ssu-align.log";
my $log_file2print = $out_root . ".ssu-align.log";
my ($tab_file, $max_file_name_width, $description_width, $search_time);
my $abs_orig_cm_file = abs_path($cm_file);

my ($cluster_prefix, $cluster_suffix);
if($do_prep) { 
    prepare_only($ssualign, $do_align, $abs_orig_cm_file, $do_prep_nproc_set, $do_prep_nseq_set, $prep_nproc, $prep_nseq, $prep_enabled_options, $target_file, $out_dir, $out_root, $cluster_prefix, $cluster_suffix, $nseq_target_file, $esl_weight, $do_filteraln, $filter_id, $do_remove_local_cms, \$max_file_name_width, \@indi_cm_name_A, \@indi_cm_file_name_A, \@log2printA); 

    push(@log2printA, sprintf("  %-*s  log file (*this* text printed to stdout)\n", $max_file_name_width, $log_file2print));
    printf($log2printA[(scalar(@log2printA)-1)]);
    push(@log2printA, sprintf("#\n# All output files created in directory \.\/%s\/\n", $out_dir));
    printf($log2printA[(scalar(@log2printA)-1)]);
    push(@log2printA, sprintf("#\n"));
    printf($log2printA[(scalar(@log2printA)-1)]);
    print_log($log_file, \@log2printA);

    # remove local copy of the CM file that was copied to $out_dir
    system("rm -f $my_cm_file_copy");
    if(($? >> 8) != 0) { printf STDERR ("ERROR, system\(\"rm -f $my_cm_file_copy\"\) unexpectedly returned non-zero exit status %d\n", ($? >> 8)); exit($? >> 8); } 

    exit(0);
}
 

# if we get here, $do_prep is FALSE

############################################################################
# Step 1: Define sequence ends (and classify seqs if > 1 CM) with cmsearch #
############################################################################
if($do_search) { 
    $search_time = -1 * time();
    search_sequences_with_each_model($cmsearch, $my_cm_file_copy, $target_file, $out_dir_root, $nseq_target_file, $do_viterbi, $do_toponly,
				     \@indi_cm_name_A, \@indi_cm_clen_A, \@indi_cm_nbif_A, \@log2printA, \$tab_file, \$max_file_name_width, \$description_width);
    $search_time += time();
}
else { 
    $max_file_name_width = 30;
}
##############################
# Step 2: Extract subsequences
##############################
my %new_target_file_per_cm_name_H = ();
my %hmmscores2printH = ();
my @seq_orderA = ();
my %winning_cmH = ();
my $max_seq_name_width;
my $max_cm_name_width;

if($do_search) { 
    classify_and_extract_subseqs($do_truncate, $min_bit, $min_len, $tab_file, $target_file, $out_dir_root, $esl_sfetch, $max_file_name_width, \$max_seq_name_width, \$max_cm_name_width, \@indi_cm_name_A, \@log2printA, \@seq_orderA, \%winning_cmH, \%new_target_file_per_cm_name_H, \%hmmscores2printH);
}
else { 
    $new_target_file_per_cm_name_H{$indi_cm_name_A[0]} = $target_file;
    #system("cp %s %s\n", $target_file ($out_dir_root . "." . $indi_cm_name_A[0] . ".hits.fa")
}
###########################
# Step 3: Align sequences #
###########################
my ($align_time, %cmscores2printH);
if($do_align) {
    $align_time = -1 * time();
    align_subseqs($out_dir_root, $cmalign, $max_file_name_width, $description_width, $esl_weight, $do_filteraln, $filter_id, $mxsize, $cmalign_extra_options, $max_cm_name_width, \@indi_cm_name_A, \@indi_cm_file_name_A, \@indi_cm_clen_A, \@log2printA, \%new_target_file_per_cm_name_H, \%cmscores2printH); 
    $align_time += time();
}
$total_time += time();

#############################
# Step 4: Print scores file #
#############################
my $scores_file = $out_dir_root . ".scores";
my $scores_file2print = $out_root . ".scores";
print_scores_file($target_file, $ncm, $scores_file, $scores_file2print, $max_seq_name_width, $max_cm_name_width, \%winning_cmH, \%cmscores2printH, \%hmmscores2printH, \@log2printA);
push(@log2printA, sprintf("  %-*s  list of CM/HMM scores for each sequence\n", $max_file_name_width, $scores_file2print));
printf($log2printA[(scalar(@log2printA)-1)]);

#################
# Print timings #
#################
push(@log2printA, sprintf("  %-*s  log file (*this* text printed to stdout)\n", $max_file_name_width, $log_file2print));
printf($log2printA[(scalar(@log2printA)-1)]);

push(@log2printA, sprintf("#\n# All output files created in directory \.\/%s\/\n", $out_dir));
printf($log2printA[(scalar(@log2printA)-1)]);
push(@log2printA, sprintf("#\n"));
printf($log2printA[(scalar(@log2printA)-1)]);

if($do_search) { print_timing("# CPU time (search):    ", $search_time, \@log2printA); }
if($do_align)  { print_timing("# CPU time (alignment): ", $align_time, \@log2printA); }
print_timing("# CPU time (total):     ", $total_time, \@log2printA); 
push(@log2printA, sprintf("#\n"));
printf($log2printA[(scalar(@log2printA)-1)]);

print_log($log_file, \@log2printA);

my $i;
if($do_remove_local_cms) { 
# remove individual CM files
    for($i = 0; $i < scalar(@indi_cm_file_name_A); $i++) { 
	system("rm -f $indi_cm_file_name_A[$i]");
	if(($? >> 8) != 0) { printf STDERR ("ERROR, system\(\"rm -f $indi_cm_file_name_A[$i]\"\) unexpectedly returned non-zero exit status %d\n", ($? >> 8)); exit($? >> 8); } 
    }
# remove local copy of the CM file that was copied to $out_dir
    system("rm -f $my_cm_file_copy");
    if(($? >> 8) != 0) { printf STDERR ("ERROR, system\(\"rm -f $my_cm_file_copy\"\) unexpectedly returned non-zero exit status %d\n", ($? >> 8)); exit($? >> 8); } 
}

#remove esl-sfetch index file we created for the target file
my $ssi_file = $target_file . ".ssi";
system("rm -f $ssi_file");
if(($? >> 8) != 0) { printf STDERR ("ERROR, system\(\"rm -f $ssi_file\"\) unexpectedly returned non-zero exit status %d\n", ($? >> 8)); exit($? >> 8); } 

# success, exit normally
exit(0); 

###############
# SUBROUTINES #
###############

#####################################################################
# Subroutine: print_banner()
# Incept:     EPN, Tue Jun 16 07:26:13 2009
# 
# Purpose:    Print the ssu-align banner and determine prep options
#             that will be passed to subsequent ssu-align calls if
#             we're in prep mode.
#
# Arguments: 
#    $script_call:      call used to invoke this (ssu-align) script
#    $opt_HR:           REFERENCE to hash of command-line options
#    $opt_takes_arg_HR: REFERENCE to hash telling if each option takes an argument (1) or not (0)
#    $opt_order_AR:     REFERENCE to array specifying order of options
#    $opt_is_prep_HR:   REFERENCE to hash telling if each option gets passed on to child processes in prep mode
#    $argv_ref:         REFERENCE to @ARGV, command-line arguments
#    $prep_options_ref: REFERENCE to prep options, filled here
#    $log2printAR:      REFERENCE to log2print array with flog file text
#
# Returns:    Nothing, if it returns, everything is valid.
# 
####################################################################
sub print_banner { 
    my $narg_expected = 8;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, print_banner() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($script_call, $opt_HR, $opt_takes_arg_HR, $opt_order_AR, $opt_is_prep_HR, $argv_ref, $prep_options_ref, $log2printAR) = @_;

    my ($i, $script_name, $start_log_line);
    $script_call =~ s/^\.+\///;
    $script_name = $script_call;
    $script_name =~ s/.+\///;

    my $enabled_options = "";
    my $prep_enabled_options = "";
    foreach $opt (@{$opt_order_AR}) { 
	if($opt_takes_arg_HR->{$opt}) { if($opt_HR{$opt} ne "") { $enabled_options .= " " . $opt . " " . $opt_HR->{$opt}; } }
	else                  	      { if($opt_HR{$opt})       { $enabled_options .= " " . $opt; } }
	if($opt_is_prep_HR->{$opt}) { 
	    if($opt_takes_arg_HR->{$opt}) { if($opt_HR{$opt} ne "") { $prep_enabled_options .= " " . $opt . " " . $opt_HR->{$opt}; } }
	    else                  	  { if($opt_HR{$opt})       { $prep_enabled_options .= " " . $opt; } }
	}
    }

    $start_log_line = scalar(@{$log2printAR});

    push(@{$log2printAR}, sprintf("\# $script_name :: define and align SSU rRNA sequences\n"));
    push(@{$log2printAR}, sprintf("\# SSU-ALIGN 0.1 (October 2009)\n"));
    push(@{$log2printAR}, sprintf("\# Copyright (C) 2009 HHMI Janelia Farm Research Campus\n"));
    push(@{$log2printAR}, sprintf("\# Freely distributed under the GNU General Public License (GPLv3)\n"));
    push(@{$log2printAR}, sprintf("\# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n"));
    push(@{$log2printAR}, sprintf("%-10s %s ", "# command:", $script_call . $enabled_options));
    for($i = 0; $i < scalar(@{$argv_ref}) - 1; $i++) { 
	push(@{$log2printAR}, sprintf("$argv_ref->[$i] "));
    }
    push(@{$log2printAR}, sprintf("$argv_ref->[$i]\n"));
    push(@{$log2printAR}, sprintf("%-10s ", "# date:"));
    push(@{$log2printAR}, sprintf(scalar localtime()));
    push(@{$log2printAR}, sprintf("\n"));

    for($i = $start_log_line; $i < scalar(@{$log2printAR}); $i++) { 
	printf($log2printAR->[$i]);
    }
	
    #Return: prep_options we defined in this subroutine
    $$prep_options_ref = $prep_enabled_options;
    return;
}

#####################################################################
# Subroutine: validate_and_setup()
# Incept:     EPN, Mon Nov  3 15:05:56 2008
# 
# Purpose:    Validation and setup:
#             - validate that the sequence file exists
#             - validate that the required executable programs exist
#             - validate that the CM file exists
#
# Arguments: 
# $target_file:      the target sequence file 
# $opt_HR:           reference to the hash of command-line options
# $ssualign_ref:     RETURN; ssu-align executable command
# $cmsearch_ref:     RETURN; cmsearch executable command
# $cmalign_ref:      RETURN; cmalign executable command
# $sfetch_ref:       RETURN; esl-sfetch executable command
# $weight_ref:       RETURN; esl-weight executable command
# $cm_file_ref:      RETURN; the path to the CM file, either default CM file or <s> from -m <s>
# 
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If a required program does not exist, the program 
#             prints a message to STDERR explaining why it's
#             exiting early and then exits with non-zero status.
#
####################################################################
sub validate_and_setup { 
    my $narg_expected = 8;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, validate_and_setup() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($target_file, $opt_HR, $ssualign_ref, $cmsearch_ref, $cmalign_ref, $sfetch_ref, $weight_ref, $cm_file_ref) = @_;

    #Make sure the SSUALIGNDIR environmental variable is set.
    my $ssualigndir = $ENV{'SSUALIGNDIR'};
    if(! exists($ENV{'SSUALIGNDIR'})) { 
	printf STDERR ("ERROR, the environment variable SSUALIGNDIR is not set, please set it to the directory where you installed SSU-ALIGN.\n"); 
	exit(1); 
    }

    #Make sure the CM file exists
    my $cm_file = "";
    if($do_altcmfile) { 
	$cm_file = $opt_M; 
	if(!(-e $cm_file))   { printf STDERR ("ERROR, CM file $cm_file, specified with -M does not exist.\n"); exit(1); }
    }
    else { 
	$cm_file = $ssualigndir . "/ssu-align-0p1.cm";
	if(!(-e $cm_file))   { printf STDERR ("ERROR, the default CM file $cm_file does not exist.\n"); exit(1); }
    }

    #Make sure the target file exists
    if(!(-e $target_file))   { printf STDERR ("ERROR, target sequence file $target_file does not exist.\n"); exit(1); }

    my $trash;
    my $cmsearch   = "ssu-cmsearch";
    my $cmalign    = "ssu-cmalign";
    my $esl_sfetch = "ssu-esl-sfetch";
    my $esl_weight = "ssu-esl-weight";
    my $ssualign   = "ssu-align";
    # check that the required programs are in the PATH
    if(!($opt_HR->{"--no-search"})) { 
	$trash = `$cmsearch -h`;
	if($? == -1) { printf STDERR ("\nERROR, the required executable $cmsearch is not in your PATH environment\nvariable. See the User's Guide Installation section.\n"); exit(1); } 
	my $trash = `$esl_sfetch -h`;
	if($? == -1) { printf STDERR ("\nERROR, the required executable $esl_sfetch is not in your PATH environment\nvariable. See the User's Guide Installation section.\n"); exit(1); } 
    }
    if(!($opt_HR->{"--no-align"})) { 
	$trash = `$cmalign -h`;
	if($? == -1) { printf STDERR ("\nERROR, the required executable $cmalign is not in your PATH environment\nvariable. See the User's Guide Installation section.\n"); exit(1); } 
    }
    if($opt_HR->{"--filter"} ne "") { 
	my $trash = `$esl_weight -h`;
	if($? == -1) { printf STDERR ("\nERROR, the required executable $esl_weight is not in your PATH environment\nvariable. See the User's Guide Installation section.\n"); exit(1); } 
    }
    if(($opt_HR->{"--prep-n"} ne "") || ($opt_HR->{"--prep-c"})) { 
	my $trash = `$ssualign -h`;
	if($? == -1) { printf STDERR ("\nERROR, the required executable $ssualign is not in your PATH environment\nvariable. See the User's Guide Installation section.\n"); exit(1); } 
    }

    $$ssualign_ref    = $ssualign;
    $$cmsearch_ref    = $cmsearch;
    $$cmalign_ref     = $cmalign;
    $$esl_sfetch_ref  = $esl_sfetch;
    $$esl_weight_ref  = $esl_weight;
    $$cm_file_ref     = $cm_file;

    return;
}

#####################################################################
# Subroutine: determine_num_seqs()
# Incept:     EPN, Mon Nov  3 15:18:52 2008
# 
# Purpose:    Count the number of sequences in the fasta file 
#             <$target_file>.
#
# Arguments: 
# $target_file: the target sequence file 
#
# 
# Returns:    <$nseq_target_file>: number of sequences in 
#             <$target_file>.
# 
####################################################################
sub determine_num_seqs { 
    my $narg_expected = 1;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, determine_num_seqs() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($file) = $_[0];

    if(!(-e $file)) { printf STDERR ("ERROR, determine_num_seqs(), file $file does not exist.\n"); exit(1); }
    my $output = `grep \"\^\>\" $file | nl | tail -1`;
    chomp $output;
    $output =~ s/^\s+//;
    $output =~ s/\s+.*$//;
    return $output;
}

#####################################################################
# Subroutine: create_output_dir()
# Incept:     EPN, Mon Nov  3 15:22:26 2008
# 
# Purpose:    Create a new directory <$outdir> for the output files. 
#             If the directory already exists and <$do_clobber>, 
#             delete all of the files within it.
# 
# Arguments:  
# $out_dir:   directory to create
# $opt_HR:    reference to the hash of command-line options
#
# Returns:    Nothing.
#
# Exits:      If the directory already exists and <$do_clobber> is
#             FALSE. If a system call unexpectedly fails and returns 
#             a non-zero status code. 
# 
####################################################################
sub create_output_dir { 
    my $narg_expected = 2;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, create_output_dir() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($do_clobber, $out_dir) = @_;

    my ($command, $tmp);
    # create output directory
    if(-d $out_dir) { 
	if(!($opt_HR->{"-F"})) { 
	    printf STDERR ("ERROR, output directory $out_dir already exists. Delete it or use -F to overwrite it.\n"); exit(1); 
	}
	else { # dir exists, but -F enabled, so we remove it
	    if($out_dir eq "") { printf STDERR ("ERROR, trying to create directory named \"\"\n"); exit(1); }
	    $command = "rm -rf $out_dir/*";
	    $tmp = `$command`;
	    if(($? >> 8) != 0) { printf STDERR ("\nERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status %d\nand output:\n$tmp\n", ($? >> 8)); exit($? >> 8); }
	    $command = "rm -f $out_dir/\.\#*";
	    $tmp = `$command`;
	    if(($? >> 8) != 0) { printf STDERR ("\nERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status %d\nand output:\n$tmp\n", ($? >> 8)); exit($? >> 8); }
	    $command = "rmdir $out_dir";
	    $tmp = `$command`;
	    if(($? >> 8) != 0) { printf STDERR ("\nERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status %d\nand output:\n$tmp\n", ($? >> 8)); exit($? >> 8); }
	    if(-d $out_dir) { printf STDERR ("ERROR, output directory $out_dir still exists after the command $command.\n"); exit(1); }
	}
    }
    # if we get here, either $out_dir does not yet exist, or it does but -F was set on command line
    $command = "mkdir $out_dir";
    $tmp = `$command`;
    if(($? >> 8) != 0) { printf STDERR ("\nERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status %d\nand output:\n$tmp\n", ($? >> 8)); exit($? >> 8); }

    return;
}

#####################################################################
# subroutine: prepare_only()
# incept:     EPN, Mon Nov  3 15:25:23 2008
# 
# purpose:    Carry out a special mode of ssu-align.pl for creating
#             scripts to split up large alignment jobs into many
#             smaller jobs. This subroutine is called only if -n or 
#             -c is enabled on the command line. 
# 
#             The target sequence file <$target_file> is partitioned
#             into > 1 new, smaller fasta files. A shell script 
#             named <$out_dir_root.sh> is created that calls 'perl 
#             ssu-align.pl' once each for each of the new fasta 
#             files. A separate perl script named 
#             <$out_dir_root.merge.pl> is created that is to be run
#             after the alignments in <$out_dir_root.sh> are complete.
#             This script merges all the small alignments into
#             one big alignment.
# 
# returns:    Nothing.
#
# exits:      Upon successful completion with a zero status code 
#             (normal). Exits early upon failure with informative
#             message and non-zero status code. 
# 
####################################################################
sub prepare_only { 
    my $narg_expected = 23;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, prepare_only() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($ssualign, $do_align, $abs_orig_cm_file, $abs_params_file, $do_prep_nproc_set, $do_prep_nseq_set, $prep_nproc, $prep_nseq, $prep_enabled_options, $target_file, $out_dir, $out_root, $cluster_prefix, $cluster_suffix, $nseq_target_file, $esl_weight, $do_filteraln, $filter_id, $do_remove_local_cms, $max_file_name_widthR, $indi_cm_name_AR, $indi_cm_file_name_AR, $log2printAR) = @_;

    # Steps
    # 1. partition the target seq file
    # 2. print ssu-align.pl calls for each target seq file to screen
    # 3. print cmalign --merge calls to eventually merge resulting 
    #    alignments from ssu-align.pl calls in 2 together.
    # 4. exit

    my ($shell_script, $shell_script2print, $merge_script, $merge_script2print, $remainder, $n, $target_subfile_root, $target_subfile, $sub_output);
    my ($nseq_this_file, $line, $ncm, $indi_cm_file_name, $indi_cm_file_name_root, $ndig, $tmp, $start_log_line, $description_width, $dashes1, $dashes2);
    my ($i, $nmerge, $iter, $nstop, $lower, $upper, $merged_root, $merged_name, $fil_merged_name, $merged_lower_name, $merged_upper_name, $cm_name);

    $ncm = scalar(@{$indi_cm_file_name_AR});

    $shell_script = $out_dir_root . ".sh";
    $shell_script2print = $out_root . ".sh";
    $merge_script = $out_dir_root . ".merge.pl";
    $merge_script2print = $out_root . ".merge.pl";
    if(open(SH, ">" . $shell_script) == 0) { printf STDERR ("ERROR, could not open $shell_script for writing.\n"); exit(1); }
    #determine number of seqs per file (if $do_prep_nseq_set, we already know) 
    if($do_prep_nproc_set) { 
	$prep_nseq  = int($nseq_target_file / ($prep_nproc)); 
	$remainder  = $nseq_target_file - ($prep_nseq * $prep_nproc);
	if($remainder > 0) { $prep_nseq++; }
    }
    else { #do_prep_nseq_set
	$prep_nproc = int($nseq_target_file / ($prep_nseq)); 
	$remainder  = $nseq_target_file - ($prep_nseq * $prep_nproc);
	if($remainder > 0) { $prep_nproc++; }
    }
    if(($do_prep_nproc_set) && ($prep_nproc > $nseq_target_file)) { 
	printf STDERR ("ERROR, -c %d enabled, but there's only %d sequences in the target file.\n", $prep_nproc, $nseq_target_file); exit(1); 
    }
    if(($do_prep_nseq_set) && ($prep_nproc == 1)) {
	printf STDERR ("ERROR, -n %d enabled, but there's only %d sequences in the target file.\nNo need to use -n, you're requesting the target file be split into only 1 partition.\n", $prep_nseq, $nseq_target_file); exit(1); 
    }

    $ndig = 1; $tmp = $prep_nproc; while($tmp > 10) { $ndig++; $tmp /= 10.; }
    my $max_file_name_width = length($merge_script2print);
    if($max_file_name_width < (length($target_file) + 1 + $ndig)) { 
	$max_file_name_width = length($target_file) + 1 + $ndig;
    }
    my $max_cm_name_width = max_length_scalar_in_array($indi_cm_name_AR);
    
    $description_width = length("perl script to merge alignments when  completes");
    $description_width += length($shell_script2print);
    $dashes1 = ""; for($i = 0; $i < $max_file_name_width; $i++) { $dashes1 .= "-"; } 
    $dashes2 = ""; for($i = 0; $i < $description_width; $i++)   { $dashes2 .= "-"; } 
    
    push(@{$log2printAR}, sprintf("#\n# Prep mode: Splitting up ssu-align job into %d smaller jobs.\n", $prep_nproc));
    printf($log2printAR->[(scalar(@{$log2printAR})-1)]);
    push(@{$log2printAR}, sprintf("#\n"));
    printf($log2printAR->[(scalar(@{$log2printAR})-1)]);
    push(@{$log2printAR}, sprintf("# %-*s  %-*s\n", $max_file_name_width, "output file name", $description_width, "description"));
    printf($log2printAR->[(scalar(@{$log2printAR})-1)]);
    push(@{$log2printAR}, sprintf("# %-*s  %-*s\n", $max_file_name_width, $dashes1, $description_width, $dashes2));
    printf($log2printAR->[(scalar(@{$log2printAR})-1)]);
    $start_log_line = scalar(@{$log2printAR});

    # 1. partition the target seq file AND
    # 2. print ssu-align calls for each target seq file to stdout
    $n = 1;
    $target_subfile_root = $target_file . "." . $n;
    $target_subfile      = $out_dir . "/" . $target_subfile_root;
    if(open(SUB, ">" . $target_subfile) == 0) { printf STDERR ("ERROR, could not open $target_subfile for writing.\n"); exit(1); }
    $nseq_this_file = -1;
    if(open(FULL, $target_file) == 0) { printf STDERR ("ERROR, could not open $target_file for reading.\n"); exit(1); }
    while($line = <FULL>) { 
	if($line =~ m/^>/) { 
	    if(++$nseq_this_file == $prep_nseq) { 
		close(SUB); 
		push(@{$log2printAR}, sprintf("  %-*s  partition %*d fasta sequence file\n", $max_file_name_width, $target_subfile_root, $ndig, $n));
		printf SH ("%s%s%s\n", $cluster_prefix, "perl $ssualign $prep_enabled_options $abs_orig_cm_file $target_subfile_root $out_root." . $n . " $abs_params_file", $cluster_suffix);
		$target_subfile_root = $target_file . "." . (++$n);
		$target_subfile      = $out_dir . "/" . $target_subfile_root;
		if(open(SUB, ">" . $target_subfile) == 0) { printf STDERR ("ERROR, could not open $target_subfile for writing.\n"); exit(1); }
		$nseq_this_file = 0;
	    }
	}
	print SUB ($line);
    }
    close(FULL);
    close(SUB);
    push(@{$log2printAR}, sprintf("  %-*s  partition %*d fasta sequence file\n", $max_file_name_width, $target_subfile_root, $ndig, $n));
    printf SH ("%s%s%s\n", $cluster_prefix, "perl $ssualign $prep_enabled_options $abs_orig_cm_file $target_subfile_root $out_root." . $n . " $abs_params_file", $cluster_suffix);
    close(SH); 
    if($n != $prep_nproc) { printf STDERR ("ERROR, problem partitioning target fasta file $target_file into $prep_nproc files, only $n files were successfully created.\n"); exit(1); }

    my @to_mergeA;
    my @new_to_mergeA;

    # 3. print cmalign --merge calls to eventually merge resulting 
    #    alignments from ssu-align.pl calls in 2 together.
    if($do_align) { 
	if(open(MG, ">" . $merge_script) == 0) { printf STDERR ("ERROR, could not open $merge_script for writing.\n"); exit(1); }
	
	my $m;
	for($m = 1; $m <= $ncm; $m++) { 
	    $indi_cm_file_name_root = $indi_cm_file_name_AR->[($m-1)];
	    $indi_cm_file_name_root =~ s/^.+\///;
	    $cm_name = $indi_cm_name_AR->[($m-1)];
	    printf MG ("\# Merging alignments to CM %d of %d\n", $m, $ncm);
	    @to_mergeA = ();
	    for($i = 1; $i <= $prep_nproc; $i++) { push(@to_mergeA, $i); }
	    $nmerge = scalar(@to_mergeA);
	    $iter = 0;
	    while($nmerge > 1) { 
		$iter++;
		@new_to_mergeA = ();
		if (($nmerge % 2) == 0) { $nstop = $nmerge; } else { $nstop = $nmerge+1; }
		for($i = 0; $i < $nstop; $i+=2) { 
		    $lower = $to_mergeA[$i];
		    if($i == (scalar(@to_mergeA)-1)) { 
			# special case, we have a single alignment remaining, not a pair of alignments, 
			# if nec, copy it to a new name if it exists (so the merging process can march along), else we do nothing
			$upper = $lower;
			$lower =~ s/\-.+//;
			$upper =~ s/.+\-//;
			$merged_root = $lower . "-" . $upper;
			$merged_name = $out_root . "." . $merged_root. "." . $cm_name . ".merged.stk";
			if($iter > 1) { $merged_lower_name = $out_root . "." . $to_mergeA[$i] . "." . $cm_name . ".merged.stk"; }
			else          {	$merged_lower_name = $out_root . "." . $to_mergeA[$i] . "/" . $out_root . "." . $to_mergeA[$i] . "." . $cm_name . ".stk"; }
			if($merged_name ne $merged_lower_name) { 
			    printf MG ("if(-e \"$merged_lower_name\") { \n"); 
			    printf MG ("\tsystem(\"cp $merged_lower_name $merged_name\");\n");
			    printf MG ("\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"cp $merged_lower_name $merged_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
			    printf MG ("}\n");
			    #erase intermediate alignment if it exists
			    if($iter > 1) { 
				printf MG ("if(-e \"$merged_lower_name\") { \n"); 
				printf MG ("\tsystem(\"rm -f $merged_lower_name\");\n");
				printf MG ("\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"rm -f $merged_lower_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
				printf MG ("}\n");
			    }
			}
		    }
		    else { #normal case, we have a pair of alignments to merge together
			$upper = $to_mergeA[($i+1)]; 
			$lower =~ s/\-.+//;
			$upper =~ s/.+\-//;
			$merged_root = $lower . "-" . $upper;
			$indi_cm_file_name = $out_root . "." . $lower . "/" . $indi_cm_file_name_root;
			if($do_filteraln) { 
			    $merged_name     = $out_root . "." . $merged_root . "." . $cm_name . ".merged.nf.stk";
			    $fil_merged_name = $out_root . "." . $merged_root . "." . $cm_name . ".merged.stk";
			}
			else { 
			    $merged_name = $out_root . "." . $merged_root . "." . $cm_name . ".merged.stk";
			}
			if($iter > 1) { 
			    $merged_lower_name = $out_root . "." . $to_mergeA[$i] .     "." . $cm_name . ".merged.stk";
			    $merged_upper_name = $out_root . "." . $to_mergeA[($i+1)] . "." . $cm_name . ".merged.stk";
			}
			else { #iter == 1
			    $merged_lower_name = $out_root . "." . $to_mergeA[$i]     . "/" . $out_root . "." . $to_mergeA[$i] .     "." . $cm_name . ".stk";
			    $merged_upper_name = $out_root . "." . $to_mergeA[($i+1)] . "/" . $out_root . "." . $to_mergeA[($i+1)] . "." . $cm_name . ".stk";
			}
			push(@new_to_mergeA, $merged_root);
			printf MG ("if(-e \"$merged_lower_name\") { \n"); 
			printf MG ("\tif(-e \"$merged_upper_name\") { \n"); 
			#DEBUGGING printf STDERR ("cm: $m iter: $iter i: $i $merged_lower_name $merged_upper_name\n");
			printf MG ("\t\tsystem(\"$cmalign -o $merged_name --merge $indi_cm_file_name $merged_lower_name $merged_upper_name\");\n");
			printf MG ("\t\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"$cmalign -o $merged_name --merge $indi_cm_file_name $merged_lower_name $merged_upper_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
			if($do_filteraln) { 
			    printf MG ("\t\tsystem(\"$esl_weight -f --idf $filter_id $merged_name > $fil_merged_name\");\n");
			    printf MG ("\t\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"$esl_weight -f --idf $filter_id $merged_name > $fil_merged_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
			    #erase non-filtered alignment
			    printf MG ("if(-e \"$merged_name\") { \n"); 
			    printf MG ("\tsystem(\"rm -f $merged_name\");\n");
			    printf MG ("\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"rm -f $merged_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
			    printf MG ("} \n");
			}
			printf MG ("\t\t}\n");
			# else $merged_lower_name exists, but $merged_upper_name does not exist
			printf MG ("\telse { \n");
			printf MG ("\t\tsystem(\"cp $merged_lower_name $merged_name\");\n");
			printf MG ("\t\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"cp $merged_lower_name $merged_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
			printf MG ("\t}\n");
			printf MG ("}\n");
			printf MG ("elsif((-e \"$merged_upper_name\")) { \n"); 
			# else $merged_upper_name exists, but $merged_lower_name does not exist
			printf MG ("\tsystem(\"cp $merged_upper_name $merged_name\");\n");
			printf MG ("\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"cp $merged_upper_name $merged_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
			printf MG ("}\n");
			printf MG ("\n");
			# else: neither $merged_upper_name exists, nor $merged_lower_name exists, do nothing next iteration will handle this
			
			# erase the intermediate alignments if they exist 
			if($iter > 1) { 
			    printf MG ("if(-e \"$merged_lower_name\") { \n"); 
			    printf MG ("\tsystem(\"rm -f $merged_lower_name\");\n");
			    printf MG ("\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"rm -f $merged_lower_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
			    printf MG ("} \n");
			    printf MG ("if(-e \"$merged_upper_name\") { \n"); 
			    printf MG ("\tsystem(\"rm -f $merged_upper_name\");\n");
			    printf MG ("\tif((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"rm -f $merged_upper_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
			    printf MG ("} \n");
			    printf MG ("\n");
			}
		    }
		}
		if (($nmerge % 2) != 0) { 
		    if($iter == 1) { push(@new_to_mergeA, $to_mergeA[($nmerge-1)] . "-" . $to_mergeA[($nmerge-1)]); } #special case, push 9-9 (for example), only nec if first iter, otherwise we're okay
		    else           { push(@new_to_mergeA, $to_mergeA[($nmerge-1)]); }  #push 5-6 in iter 2 (for example)
		}
		@to_mergeA = @new_to_mergeA;
		$nmerge = scalar(@to_mergeA);
	    }
	}
	# remove all the local CMs we just used to merge alignments
	if($do_remove_local_cms) { 
	    for($m = 0; $m < $ncm; $m++) { 
		$indi_cm_file_name_root = $indi_cm_file_name_AR->[$m];
		$indi_cm_file_name_root =~ s/^.+\///;
		for($i = 1; $i <= $prep_nproc; $i++) { 
		    $indi_cm_file_name = $out_root . "." . $i . "/" . $indi_cm_file_name_root;
		    printf MG ("system(\"rm -f $indi_cm_file_name\");\n");
		    printf MG ("if((\$? \<\< 8) != 0) { printf STDERR (\"ERROR, system(\\\"rm -f $indi_cm_file_name\\\" returned a non-zero exit status \%d\\n\", (\$? >> 8)); exit((\$? >> 8)); }\n");
		}
		# IF we wanted to rename the merged alignment, this is where that would go
		$merged_name = $out_root . ".1-" . $prep_nproc . "." . $indi_cm_name_AR->[$m] . ".merged.stk";
		#printf ("system(\"mv $indi_cm_file_name_root\");\n");
		printf MG ("printf(\"Merged alignment for %-*s CM saved to %s\\n\"\);\n", $max_cm_name_width, $indi_cm_name_AR->[$m], $merged_name);
	    }
	}
	close(MG);
    }
    
    push(@{$log2printAR}, sprintf("  %-*s  shell script that will run ssu-align %d times\n", $max_file_name_width, $shell_script2print, $prep_nproc));
    if($do_align) { 
	push(@{$log2printAR}, sprintf("  %-*s  perl script to merge alignments when %s completes\n", $max_file_name_width, $merge_script2print, $shell_script2print));
    }
    $shell_script =~ s/$out_dir\///;
    $merge_script =~ s/$out_dir\///;
    #push(@{$log2printAR}, sprintf("To execute (doesn't work if you're going to use a cluster):\ncd $out_dir; sh $shell_script; perl $merge_script;\n"));

    for($i = $start_log_line; $i < scalar(@{$log2printAR}); $i++) { 
	printf($log2printAR->[$i]);
    }

    $$max_file_name_widthR = $max_file_name_width;
    return;
}

#####################################################################
# Subroutine: process_cm_file()
# Incept:     EPN, Tue Nov  4 08:20:47 2008
# 
# Purpose:    Validate and process the CM file. A CM file 
#             <$my_cm_file_copy> is valid if each of the <x> CM 
#             within it is has a unique name. Process the CM file 
#             by splitting it into <x> new files. 
#
# Arguments:  
# $out_root:             command-line argument, the root for output files
# $cm_file:              the CM file we'll use
# $opt_HR:               reference to the hash of command-line options
# $indi_cm_name_AR:      RETURN; array of individual CM names 
# $indi_cm_file_name_AR: RETURN; array of individual CM *file* names 
# $indi_cm_clen_AR:      RETURN; array of consensus lengths for each CM
# $indi_cm_nbif_AR:      RETURN; array of number of bifurcations for each CM
# 
# Returns:    Fills RETURN arguments as listed above.
#
# Exits:      If two CMs in <$cm_file> have the same name we exit,
#             or we can't open <$cm_file>. In both cases, program
#             exits with non-zero return status.
# 
####################################################################
sub process_cm_file { 
    my $narg_expected = 7;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, process_cm_file() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($out_root, $cm_file, $opt_HR, $indi_cm_name_AR, $indi_cm_file_name_AR, $indi_cm_clen_AR, $indi_cm_nbif_AR) = @_;
    
    my($cmi, $line, $inf_line, $cm_name, $indi_cm_file, $indi_cm_file_root);
    my %cm_name_exists_H = ();

    $indi_cm_file_root = $cm_file;
    $indi_cm_file_root =~ s/.+\///; #remove directory path

    HERE HERE HERE HERE 

    if(open(CM, $cm_file) == 0) { printf STDERR ("ERROR, could not open $cm_file for reading.\n"); exit(1); }
    $cmi = 0;
    while($line = <CM>) {
	if($line =~ /^INFERNAL/) { 
	    $inf_line = $line;
	    $cmi++;
	}
	elsif($line =~ /^NAME\s+(\S+)/) { 
	    $cm_name = $1;
	    $indi_cm_file = $indi_cm_file_root . "." . $cm_name . ".m" . $cmi . ".cm";
	    if(!$do_prep) { 
		if(open(OUT, ">" . $indi_cm_file) == 0) { printf STDERR ("ERROR, could not open $indi_cm_file for writing.\n"); exit(1); }
		print OUT $inf_line;
		print OUT $line;
	    }
	    push(@{$indi_cm_name_AR},      $cm_name);
	    push(@{$indi_cm_file_name_AR}, $indi_file);
	    if(exists($cm_name_exists_H{$cm_name})) { printf STDERR ("ERROR, two CMs in CM file $my_cm_file_copy have the name $cm_name. Each CM must have a unique name.\n"); exit(1); }
	    $cm_name_exists_H{$cm_name} = 1;
	}
	elsif($line =~ /^CLEN\s+(\S+)/) { 
	    push(@{$indi_cm_clen_AR}, $1);
	    if(!$do_prep) { print OUT $line; }
	}
	elsif($line =~ /\[\s+BIF\s+\d+\s+\]/) { 
	    $indi_cm_nbif_AR->[($cmi-1)]++;
	    if(!$do_prep) { print OUT $line; }
	}
	elsif($line =~ m/^\/\//) { 
	    if(!$do_prep) { 
		print OUT $line; 
		close(OUT);
	    }
	}
	else { if(!$do_prep) { print OUT $line; } }
    }
    close(CM);
    if(scalar(@{$indi_cm_name_AR}) != scalar(@{$indi_cm_file_name_AR})) { printf STDERR ("ERROR, CM file processed incorrectly, %d CM names read, but %d new CM files created.\n", scalar(@{$indi_cm_name_AR}), scalar(@{$indi_cm_file_name_AR})); }
    if(scalar(@{$indi_cm_name_AR}) != scalar(@{$indi_cm_clen_AR}))      { printf STDERR ("ERROR, CM file processed incorrectly, %d CM names read, but %d CLEN lines read.\n", scalar(@{$indi_cm_name_AR}), scalar(@{$indi_cm_clen_AR})); } 
    return;
}									 

#####################################################################
# subroutine: search_sequences_with_each_model()
# incept:     EPN, Mon Nov  3 15:42:17 2008
# 
# purpose:    Run cmsearch on the target sequence file <$target_file>
#             in HMM mode to define start/stops of each sequence,
#             and to verify they're likely SSU at all.
#             
# returns:    Nothing.
#
# exits:      If the cmsearch call doesn't finish with a zero status
#             code we exit. cmsearch should print an error message 
#             to standard error if this occurs.
# 
####################################################################
sub search_sequences_with_each_model() { 
    my $narg_expected = 14;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, search_sequences_with_each_model() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($cmsearch, $my_cm_file_copy, $target_file, $out_dir_root, $nseq_target_file, $do_viterbi, $do_toponly,
       $indi_cm_name_AR, $indi_cm_clen_AR, $indi_cm_nbif_AR, $log2printAR, $ret_tab_file, $ret_max_file_name_width, $ret_description_width) = @_;

    my ($cmsearch_opts, $tab_file, $tab_file2print, $file_name_width, $file_name_dashes, $search_psecs, $alg_flag, $max_file_name_width, $dashes1, $dashes2, $start_log_line);

    $start_log_line = scalar(@{$log2printAR});

    #crudely predict the number of seconds the cmsearch will take
    $search_psecs = 0;
    for($i = 0; $i < scalar(@{$indi_cm_clen_AR}); $i++) { $search_psecs += ($indi_cm_clen_AR->[$i] * $indi_cm_clen_AR->[$i]); }
    #$search_psecs is now predicted number of DP cells per sequence
    $search_psecs *= ($nseq_target_file) / 1000000.; # $search_psecs is now predicted num of million cells for all seqs
    if($opt_F) { $search_psecs /= 100. } # cmsearch --forward does about 100 million dp cells per second;
    else       { $search_psecs /= 300. } # cmsearch --viterbi does about 300 million dp cells per second;

    $tab_file = $out_dir_root . ".tab";
    $tab_file2print = $out_root . ".tab";
    if   ($do_viterbi) { $alg_flag = "--viterbi"; } 
    else               { $alg_flag = "--forward"; } 
    if   ($do_glocal)  { $alg_flag .= " -g"; }

    # print info on what we just created
    $max_file_name_width = max_length_scalar_in_array($indi_cm_name_AR); 
    $description_width   = $max_file_name_width;
    $description_width   += length("list of sequences to align with  CM");
    if($description_width < length("boundaries/scores of hits defined by HMM(s)")) { $description_width = length("boundaries/scores of hits defined by HMM(s)"); }

    $max_file_name_width += length($out_root . "." . ".hits.list");
    if($max_file_name_width < length("output file name")) { $max_file_name_width = length("output file name"); }
    $dashes1 = ""; for($i = 0; $i < $max_file_name_width; $i++) { $dashes1 .= "-"; } 
    $dashes2 = ""; for($i = 0; $i < $description_width; $i++)   { $dashes2 .= "-"; } 

    push(@{$log2printAR}, sprintf("#\n# Stage 1: Determining SSU start/end positions and best-matching models.\n"));
    push(@{$log2printAR}, sprintf("#\n"));
    push(@{$log2printAR}, sprintf("# %-*s  %-*s\n", $max_file_name_width, "output file name", $description_width, "description"));
    push(@{$log2printAR}, sprintf("# %-*s  %-*s\n", $max_file_name_width, $dashes1, $description_width, $dashes2));

    for($i = $start_log_line; $i < scalar(@{$log2printAR}); $i++) { 
	printf($log2printAR->[$i]);
    }

    $start_log_line = scalar(@{$log2printAR});
    $cmsearch_opts = " --hmm-cW 1.5 --no-null3 --noalign ";
    if($do_toponly) { $cmsearch_opts .= " --toponly"; }
    system("$cmsearch $cmsearch_opts -T $cmsearch_T --tab $tab_file $alg_flag $my_cm_file_copy $target_file > /dev/null");
    if(($? >> 8) != 0) { printf STDERR ("ERROR, system\(\"$cmsearch $cmsearch_opts -T $cmsearch_T --tab $tab_file $alg_flag $my_cm_file_copy $target_file > /dev/null\" unexpectedly returned non-zero exit status %d\n", ($? >> 8)); exit(($? >> 8)); } 

    #push(@{$log2printAR}, sprintf("\t%-*s cmsearch output file with locations/scores of hits using HMM.\n", $max_file_name_width, $out_dir_root . ".cmsearch :"));
    push(@{$log2printAR}, sprintf("  %-*s  locations/scores of hits defined by HMM(s)\n", $max_file_name_width, $tab_file2print));

    for($i = $start_log_line; $i < scalar(@{$log2printAR}); $i++) { 
	printf($log2printAR->[$i]);
    }

    $$ret_tab_file = $tab_file;
    $$ret_max_file_name_width = $max_file_name_width;
    return;
}

#####################################################################
# subroutine: classify_and_extract_subseqs()
# incept:     EPN, Mon Nov  3 17:14:33 2008
# 
# purpose:    Extract subsequences given the cmsearch tab file 
#             output. Also determine the CM c that has the highest
#             scoring hit to each sequence s and classify s as 
#             belonging to c. Then when we do alignment, for each 
#             CM we align all of that CM's seqs to it. Each sequence
#             is classified as belonging to only 1 CM. If only
#             1 CM exists in the CM file, then all sequences
#             will automatically be classified to it.
#             
# returns:    Nothing.
#
# exits:      If a system("") call doesn't finish with a 
#             zero status code we exit. 
# 
####################################################################
sub classify_and_extract_subseqs { 
    my $narg_expected = 16;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, classify_and_extract_subseqs() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($do_truncate, $min_bit, $min_len, $tab_file, $target_file, $out_dir_root, $esl_sfetch, $max_file_name_width, $max_seq_name_widthR, $max_cm_name_widthR,
	$indi_cm_name_AR, $log2printAR, $seq_orderAR, $winning_cmHR, $new_target_file_per_cm_name_HR, $hmmscores2printHR) = @_;
    my $cur_max_seq_name_width = 0;
    my $max_seq_name_width = 0;

    my %seq_exists_in_order_array_H = ();
    my @cm_name_from_tab_file_A = ();
    my($cm_name, $line);
    my($seq_name, $tstart, $tend, $qstart, $qend, $bit, $E, $gc, $tlen, $m, $i, $start_log_line, $max_cm_name_width);
    my %bit_cm_seq_HH = ();
    my %bit_seq_cm_HH = ();
    my %start_cm_seq_HH = ();
    my %end_cm_seq_HH = ();
    
    $start_log_line    = scalar(@{$log2printAR});
    $max_cm_name_width = max_length_scalar_in_array($indi_cm_name_AR); 
    if($max_cm_name_width < length("model name")) { $max_cm_name_width = length("model name"); } 

    # Parse tab file, keep track of best scoring hit above our min length and min bit score for each CM for each seq
    if(open(TAB, $tab_file) == 0) { printf STDERR ("ERROR, could not open $tab_file for reading.\n"); exit(1); }
    $cm_name = "";
    while($line = <TAB>) { 
	chomp $line;
	if($line =~ m/^\#\s+CM\:\s+(.+)$/) { 
	    $cm_name = $1;
	    push(@cm_name_from_tab_file_A, $cm_name);
	}
	elsif($line !~ m/^\#/) { 
	    $line =~ s/^\s+//;
	    ($seq_name, $tstart, $tend, $qstart, $qend, $bit, $E, $gc) = split(/\s+/, $line);
	    if($tend > $tstart) { $tlen = $tend - $tstart + 1; }
	    else                { $tlen = $tstart - $tend + 1; }
	    if((!(exists($bit_cm_seq_HH{$cm_name}{$seq_name}))) || ($bit > $bit_cm_seq_HH{$cm_name}{$seq_name})) { 
		if(($tlen >= $min_len) && ($bit >= $min_bit)) { 
		    $bit_cm_seq_HH{$cm_name}{$seq_name}   = $bit;
		    $bit_seq_cm_HH{$seq_name}{$cm_name}   = $bit;
		    $start_cm_seq_HH{$cm_name}{$seq_name} = $tstart;
		    $end_cm_seq_HH{$cm_name}{$seq_name}   = $tend;
		    if(!(exists($seq_exists_in_order_array_H{$seq_name}))) { push(@{$seq_orderAR}, $seq_name); $seq_exists_in_order_array_H{$seq_name} = 1; }
		}
	    }
	}
    }
    # Make sure our tab file contains the same CMs in the same order as our CM file did.
    if(scalar(@cm_name_from_tab_file_A) != scalar(@{$indi_cm_name_AR})) { 
	printf STDERR ("ERROR, %d CMs read in tab file != %d CMs read from CM file.\n", scalar(@cm_name_from_tab_file_A), scalar(@{$indi_cm_name_AR}));
	exit(1);
    }
    for($m = 0; $m < scalar(@cm_name_from_tab_file_A); $m++) { 
	if($cm_name_from_tab_file_A[$m] ne $indi_cm_name_AR->[$m]) { 
	    printf STDERR ("ERROR, CM number %d (%s) from the tab file output is not the same as CM %d from the CM file (%s).\n", $cm_name_from_tab_file_A[$m], $indi_cm_name_AR->[$m]);
	    exit(1);
	}
    }

    # classify each seq: determine highest scoring model for each seq
    # also keep track of second best scoring model for each seq, so 
    # we can print that to the .scores file
    my @tmp_bit_A = ();
    my @tmp_cm_A = ();
    my %by_cm_name_HA = ();
    my %by_cm_bit_HA = ();
    my %by_cm_start_HA = ();
    my %by_cm_end_HA = ();
    my ($cmsc, $cmstructsc, $dashes, $output);
    my ($winner_idx, $winner_cm, $winner_bit);
    my ($second_idx, $second_cm, $second_bit);
    foreach $seq_name (@{$seq_orderAR}) { 
	@tmp_bit_A = ();
	@tmp_cm_A  = ();
	foreach $cm_name (sort keys (%{$bit_seq_cm_HH{$seq_name}})) { 
	    push(@tmp_bit_A,$bit_seq_cm_HH{$seq_name}{$cm_name});
	    push(@tmp_cm_A, $cm_name);
	}
	$winner_idx = argmax_array(\@tmp_bit_A);
	$winner_cm  = $tmp_cm_A[$winner_idx];
	$winner_bit = $tmp_bit_A[$winner_idx];

	delete($tmp_bit_A[$winner_idx]);
	$second_idx = argmax_array(\@tmp_bit_A);
	$second_cm  = $tmp_cm_A[$second_idx];
	$second_bit = $tmp_bit_A[$second_idx];

	push(@{$by_cm_name_HA{$winner_cm}},  $seq_name);
	push(@{$by_cm_bit_HA{$winner_cm}},   $winner_bit);
	push(@{$by_cm_start_HA{$winner_cm}}, $start_cm_seq_HH{$winner_cm}{$seq_name});
	push(@{$by_cm_end_HA{$winner_cm}},   $end_cm_seq_HH{$winner_cm}{$seq_name});

	$cmsc = -1.0;
	$cmstructsc = -1.0;
	$hmmscores2printHR->{$seq_name} = sprintf("%d %d %.2f %s %.2f %.2f",
						  $start_cm_seq_HH{$winner_cm}{$seq_name}, $end_cm_seq_HH{$winner_cm}{$seq_name}, 
						  $winner_bit, $second_cm, $second_bit);
	$winning_cmHR->{$seq_name} = $winner_cm;
    }

    # For each CM c, list the target sequences that score highest to c in tabular format
    # and then fetch them with esl-sfetch
    my ($index_file, $ncm_with_at_least_one_seq, $list_file, $list_file2print, $esl_sfetch_in_file, $nwinners, $max_seq_name_width, $hits_file, $hits_file2print, $esl_sfetch_options, $line);
    $ncm_with_at_least_one_seq = 0;
    $index_file = $target_file . ".ssi";
    
    #if index file exists, remove it and remake it (wasteful, but this is the only way to know for sure that the index was created for this specific file)
    if(-e $index_file)    { system("rm -f $index_file"); } 
    if(($? >> 8) != 0)    { printf STDERR ("ERROR, system(\"rm -f $index_file\" unexpectedly returned non-zero exit status %d.\n", ($? >> 8)); exit($? >> 8); }
    system("$esl_sfetch \-\-index $target_file > /dev/null"); 
    if(($? >> 8) != 0)    { printf STDERR ("ERROR, system(\"$esl_sfetch \-\-index $target_file > /dev/null\" unexpectedly returned non-zero exit status %d.\n", ($? >> 8)); exit($? >> 8); }

    for($m = 0; $m < scalar(@{$indi_cm_name_AR}); $m++) { 
	$cm_name = $indi_cm_name_AR->[$m];
	$list_file = $out_dir_root . "." . $cm_name . ".hits.list"; 
	$list_file2print = $out_root . "." . $cm_name . ".hits.list"; 
	$esl_sfetch_in_file = $out_dir_root . "." . $cm_name . ".hits.in";
	$nwinners = scalar(@{$by_cm_name_HA{$cm_name}});

	if($nwinners > 0) { 
	    $ncm_with_at_least_one_seq++;
	    if(open(OUTLIST,  ">" . $list_file) == 0)      { printf STDERR ("ERROR, could not open $list_file for writing.\n"); exit(1); }
	    if(open(SFETCHIN, ">" . $esl_sfetch_in_file) == 0) { printf STDERR ("ERROR, could not open $esl_sfetch_in_file for writing.\n"); exit(1); }

	    # determine max seq name width 
	    $cur_max_seq_name_width = length("target name");
	    for($i = 0; $i < $nwinners; $i++) { if(length($by_cm_name_HA{$cm_name}[$i]) > $cur_max_seq_name_width) { $cur_max_seq_name_width = length($by_cm_name_HA{$cm_name}[$i]); } }
	    $dashes = "";
	    for($i = 0; $i < $cur_max_seq_name_width; $i++) { $dashes .= "-"; }
	    printf OUTLIST  ("# List of %d subsequences to align to CM: $cm_name\n", $nwinners);
	    printf OUTLIST  ("# Created by ssu-align.pl.\n#\n");
	    printf OUTLIST  ("# %-*s  %6s  %6s  %8s\n", $cur_max_seq_name_width, "target name", "start", "stop", "score");
	    printf OUTLIST  ("# %*s  %6s  %6s  %8s\n", $cur_max_seq_name_width, $dashes, "------", "------", "--------");

	    for($i = 0; $i < $nwinners; $i++) { 
		#push(@{$log2printAR}, sprintf("%4d  $cm_name  %25s  %7.2f  %8d  %8d\n", ($i+1), $by_cm_name_HA{$cm_name}[$i], $by_cm_bitHA{$cm_name}[$i], $by_cm_startHA{$cm_name}[$i], $by_cm_endHA{$cm_name}[$i]));
		printf OUTLIST ("  %-*s  %6d  %6d  %8.2f\n", $cur_max_seq_name_width, $by_cm_name_HA{$cm_name}[$i], $by_cm_start_HA{$cm_name}[$i], $by_cm_end_HA{$cm_name}[$i], $by_cm_bit_HA{$cm_name}[$i]);
		if($do_truncate) { printf SFETCHIN ("$by_cm_name_HA{$cm_name}[$i]\t$by_cm_start_HA{$cm_name}[$i]\t$by_cm_end_HA{$cm_name}[$i]\t$by_cm_name_HA{$cm_name}[$i]\n"); }
		else             { printf SFETCHIN ("$by_cm_name_HA{$cm_name}[$i]\n"); }
	    }
	    #push(@{$log2printAR}, sprintf("\n"));
	    close(OUTLIST);
	    close(SFETCHIN);
	    #push(@{$log2printAR}, sprintf("Subsequences of %d seqs (<name> <start> <end> <bit score>) for CM $cm_name printed to file $listfile.\n", scalar(@{$by_cm_name_HA{$cm_name}})));
	    push(@{$log2printAR}, sprintf("  %-*s  list of sequences to align with $cm_name CM\n", $max_file_name_width, $list_file2print));

	    $hits_file = $out_dir_root . "." . $cm_name . ".hits.fa";
	    $hits_file2print = $out_root . "." . $cm_name . ".hits.fa";
	    if(-e ($hits_file)) { system("rm -f $hits_file"); }
	    if($do_truncate) { $esl_sfetch_options = "-Cf"; }
	    else             { $esl_sfetch_options = "-f";  }
	    if($do_truncate) { system("$esl_sfetch -o $hits_file $esl_sfetch_options $target_file $esl_sfetch_in_file > /dev/null"); }
	    else             { system("$esl_sfetch -o $hits_file $esl_sfetch_options $target_file $esl_sfetch_in_file > /dev/null"); }
	    if(($? >> 8) != 0) { printf STDERR ("ERROR, system(\"$esl_sfetch $esl_sfetch_options $target_file $esl_sfetch_in_file\" unexpectedly returned non-zero exit status %d.\n", ($? >> 8)); exit($? >> 8); }

	    #push(@{$log2printAR}, sprintf("esl-sfetch -Cf $target_file $listfile > $hits_file\n"));
	    $output = `head -1 $hits_file`;
	    if($output =~ m/\W/) 
	    { 
		if($nwinners > 1) { push(@{$log2printAR}, sprintf("  %-*s  %7d sequences to align with $cm_name CM\n", $max_file_name_width, $hits_file2print, scalar(@{$by_cm_name_HA{$cm_name}}))); }
		else              { push(@{$log2printAR}, sprintf("  %-*s  %7d sequence  to align with $cm_name CM\n", $max_file_name_width, $hits_file2print, scalar(@{$by_cm_name_HA{$cm_name}}))); }
	    }
	    else 
	    { 
		push(@{$log2printAR}, sprintf("ERROR, esl-sfetch command $esl_sfetch -o $hits_file -Cf $target_file $esl_sfetch_in_file didn't work.\n"));  
		exit(1); 
	    }
	    system("rm -f $esl_sfetch_in_file");
	    $new_target_file_per_cm_name_HR->{$cm_name} = $hits_file;
	    if($cur_max_seq_name_width > $max_seq_name_width) { $max_seq_name_width = $cur_max_seq_name_width; };
	}
    }
    if($ncm_with_at_least_one_seq == 0) { 
	push(@{$log2printAR}, sprintf("ERROR, 0 seqs had cmsearch hits with bit score > $min_bit and length > $min_len to any of the %d CMs in the tab file $tab_file.\nYou can change the minimum bit score to <x> with -B <x>, and minimum length to <n> with -L <n>.\n", scalar(@{$indi_cm_name_AR})));
	exit(1);
    }

    for($i = $start_log_line; $i < scalar(@{$log2printAR}); $i++) { 
	printf($log2printAR->[$i]);
    }

    $$max_seq_name_widthR = $max_seq_name_width;
    $$max_cm_name_widthR  = $max_cm_name_width;
    return;
}

#####################################################################
# subroutine: align_subseqs()
# incept:     EPN, Mon Nov  3 17:20:42 2008
# 
# purpose:    For each CM c, align all of c's classified sequences to
#             c using cmalign. If 0 seqs are classified as belonging
#             to c, skip the alignment step for c.
#
# returns:    Nothing.
#
# exits:      If a cmalign call doesn't finish with a zero status
#             code. cmsearch should print an error message to
#             standard error if this occurs.
#  
####################################################################
sub align_subseqs { 
    my $narg_expected = 16;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, align_subseqs() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($out_dir_root, $cmalign, $max_file_name_width, $description_width, $esl_weight, $do_filteraln, $filter_id, $mxsize, $cmalign_extra_options, $max_cm_name_width, $indi_cm_name_AR, $indi_cm_file_name_AR, $indi_cm_clen_AR, $log2printAR, $new_target_file_per_cm_name_HR, $cmscores2printHR) = @_;

    my($ncm, $m, $cm_file_name, $cm_name, $cm_clen, $hits_file, $nseq_this_file, $align_psecs, $cmalign_out, $cmalign_stk);
    my($cmalign_out2print, $cmalign_stk2print, $fil_cmalign_stk, $fil_cmalign_stk2print, $dashes1, $dashes2, $start_log_line);
    my($line, $seq_name, $cmsc, $cmstructsc);
    my @elA = ();

    $start_log_line = scalar(@{$log2printAR});

    $dashes1 = ""; for($i = 0; $i < $max_file_name_width; $i++) { $dashes1 .= "-"; } 
    $dashes2 = ""; for($i = 0; $i < $description_width;   $i++) { $dashes2 .= "-"; } 
    push(@{$log2printAR}, sprintf("#\n"));
    push(@{$log2printAR}, sprintf("# Stage 2: Aligning each sequence to its best-matching model.\n"));
    push(@{$log2printAR}, sprintf("#\n"));
    push(@{$log2printAR}, sprintf("# %-*s  %s\n", $max_file_name_width, "output file name", "description"));
    push(@{$log2printAR}, sprintf("# %-*s  %-*s\n", $max_file_name_width, $dashes1, $description_width, $dashes2));

    for($i = $start_log_line; $i < scalar(@{$log2printAR}); $i++) { 
	printf($log2printAR->[$i]);
    }

    $ncm = scalar(@{$indi_cm_file_name_AR});
    for($m = 0; $m < $ncm; $m++) { 
	$cm_file_name = $indi_cm_file_name_AR->[$m];
	$cm_name = $indi_cm_name_AR->[$m];
	$cm_clen = $indi_cm_clen_AR->[$m];
	if(exists($new_target_file_per_cm_name_HR->{$cm_name})) { # >= 1 sequences in this set were classified as the current CM
	    $hits_file      = $new_target_file_per_cm_name_HR->{$cm_name};
	    $nseq_this_file = determine_num_seqs($hits_file);
	    
	    $align_psecs = ($cm_clen * $cm_clen) / (1500 * 1500); #$align_psecs is fraction of SSU alignment time this seq aln will take
	    $align_psecs *= $nseq_this_file;
	    $cmalign_out       = $out_dir_root . "." . $cm_name . ".cmalign";
	    $cmalign_out2print = $out_root     . "." . $cm_name . ".cmalign";
	    if($do_filteraln) { 
		$cmalign_stk           = $out_dir_root . "." . $cm_name . ".nf.stk";
		$cmalign_stk2print     = $out_root     . "." . $cm_name . ".nf.stk";
		$fil_cmalign_stk       = $out_dir_root . "." . $cm_name . ".stk";
		$fil_cmalign_stk2print = $out_root     . "." . $cm_name . ".stk";
	    }
	    else { 
		$cmalign_stk           = $out_dir_root . "." . $cm_name . ".stk";
		$cmalign_stk2print     = $out_root     . "." . $cm_name . ".stk";
	    }
	    
	    system("$cmalign $cmalign_extra_options --mxsize $mxsize --sub -o $cmalign_stk $cm_file_name $hits_file > $cmalign_out"); 
	    if(($? >> 8) != 0) { printf STDERR ("ERROR, system\(\"$cmalign $cmalign_extra_options --mxsize $mxsize --sub -o $cmalign_stk $cm_file_name $hits_file > $cmalign_out\"\) unexpectedly returned non-zero exit status %d\n", ($? >> 8)); exit(($? >> 8)); } 
	    
	    #open and parse the cmalign output
	    if(open(CMALIGN, $cmalign_out) == 0) { printf STDERR ("ERROR, could not open $cmalign_out for reading.\n"); exit(1); }
	    while($line = <CMALIGN>) { 
		if($line =~ s/^\s+//) { 
		    @elA = split(/\s+/, $line);
		    $seq_name = $elA[1];
		    $cmsc = $elA[3];
		    $cmstructsc = $elA[4];
		}
		$cmscores2printHR->{$seq_name} = sprintf("%.2f %.2f", $cmsc, $cmstructsc);
	    }
	    close(CMALIGN);

	    if($do_filteraln) { 
		system("$esl_weight -f --idf $filter_id $cmalign_stk > $fil_cmalign_stk"); 
	    }
	    if(($? >> 8) != 0) { printf STDERR ("ERROR, system\(\"$esl_weight -f --idf $filter_id $cmalign_stk > $fil_cmalign_stk\"\) unexpectedly returned non-zero exit status %d\n", ($? >> 8)); exit(($? >> 8)); } 

	    if($do_filteraln) { 
		push(@{$log2printAR}, sprintf("  %-*s  complete %s alignment\n", $max_file_name_width, $cmalign_stk2print, $cm_name));
		printf($log2printAR->[(scalar(@{$log2printAR})-1)]);
		push(@{$log2printAR}, sprintf("  %-*s  filtered %s alignment\n", $max_file_name_width, $fil_cmalign_stk2print, $cm_name));
		printf($log2printAR->[(scalar(@{$log2printAR})-1)]);
	    }
	    else { 
		push(@{$log2printAR}, sprintf("  %-*s  %s alignment\n", $max_file_name_width, $cmalign_stk2print, $cm_name));
		printf($log2printAR->[(scalar(@{$log2printAR})-1)]);
	    }
	    push(@{$log2printAR}, sprintf("  %-*s  %s cmalign output\n", $max_file_name_width, $cmalign_out2print, $cm_name));
	    printf($log2printAR->[(scalar(@{$log2printAR})-1)]);
	}
    }

    return;
}

#################################################################
# subroutine : argmax_arr()
# incept:      EPN, Tue Nov  4 14:33:23 2008
# 
# purpose : Return the index of the max value in an array.
#
################################################################# 
sub argmax_array
{
    my $narg_expected = 1;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, argmax_arr() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($arr_ref) = $_[0];

    my ($max, $i, $argmax);
    $max = $arr_ref->[0];
    $argmax = 0;
    for($i = 1; $i < scalar(@{$arr_ref}); $i++) { 
	if($arr_ref->[$i] > $max) { $max = $arr_ref->[$i]; $argmax = $i; }
    }
    return $argmax;
}

#################################################################
# subroutine : max_length_scalar_in_arr()
# incept:      EPN, Tue Nov  4 15:19:44 2008
# 
# purpose:     Return the maximum length of a scalar in an array
# 
################################################################# 
sub max_length_scalar_in_array {
    my $narg_expected = 1;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, max_length_scalar_in_arr() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($arr_ref) = $_[0];

    my ($max, $i);
    $max = length($arr_ref->[0]);
    for($i = 1; $i < scalar(@{$arr_ref}); $i++) { 
	if(length($arr_ref->[$i]) > $max) { $max = length($arr_ref->[$i]); }
    }
    return $max;
}

#####################################################################
# subroutine: print_timing()
# incept:     EPN, Tue Jun 16 08:52:08 2009
# 
# purpose:    Print a timing in hhhh:mm:ss format to 1 second precision.
#
# returns:    Nothing, if it returns, everything is valid.
# 
####################################################################
sub print_timing { 
    my $narg_expected = 3;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, print_timing() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($prefix, $inseconds, $log2printAR) = @_;
    my ($hours, $minutes, $seconds, $thours, $tminutes, $tseconds, $start_log_line);

    $start_log_line = scalar(@{$log2printAR});

    $hours = int($inseconds / 3600);
    $inseconds -= ($hours * 3600);
    $minutes = int($inseconds / 60);
    $inseconds -= ($minutes * 60);
    $seconds = $inseconds;
    $thours   = $hours;
    $tminutes = $minutes;
    $tseconds = $seconds;

    if($hours < 10)   { $thours   = "0" . $thours; }
    if($minutes< 10)  { $tminutes = "0" . $tminutes; }
    if($seconds< 10)  { $tseconds = "0" . $tseconds; }

    push(@{$log2printAR}, sprintf("%s %2s:%2s:%2s\n", $prefix, $thours, $tminutes, $tseconds));

    for($i = $start_log_line; $i < scalar(@{$log2printAR}); $i++) { 
	printf($log2printAR->[$i]);
    }
}

#####################################################################
# subroutine: print_log()
# incept:     EPN, Tue Jun 16 09:23:55 2009
# 
# purpose:    Print the log.
#
# returns:    Nothing, if it returns, everything is valid.
# 
####################################################################
sub print_log { 
    my $narg_expected = 2;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, print_log() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($log_file, $log2printAR) = @_;
    my ($start_log_line, $line);

    if(open(LOG,  ">" . $log_file) == 0) { printf STDERR ("ERROR, could not open $log_file for writing.\n"); exit(1); }
    foreach $line (@{$log2printAR}) { print LOG $line; }
    close(LOG);

    return;
}


#####################################################################
# subroutine: print_scores_file
# incept:     EPN, Tue Jun 16 14:39:38 2009
# 
# purpose:    Print the scores file with CM and HMM scores.
#             We want to print a line for each target sequence, since
#             we only aligned those that scored above a threshold,
#             this means we have to revisit the target database and
#             read all the seqs.
#
# returns:    Nothing, if it returns, everything is valid.
# 
####################################################################
sub print_scores_file { 
    my $narg_expected = 10;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, print_scores_file_multi_model() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($target_file, $ncm, $scores_file, $scores_file2print, $max_seq_name_width, $max_cm_name_width, $winning_cmHR, $cmscores2printHR, $hmmscores2printHR, $log2printAR) = @_;

    my ($seq_name, $cmscore2print);
    my ($start_log_line, $i, $winning_cm);
    my ($dashes_seqname, $dashes_cmname, $dashes1, $dashes2);
    my ($cmsc, $cmstructsc, $start, $end, $whmmsc, $secondhmm, $shmmsc);
    my ($best_string, $nleading_spaces, $ntrailing_spaces, $second_string, $idx, $line);

    $dashes_seqname = ""; for($i = 0; $i < $max_seq_name_width; $i++) { $dashes_seqname .= "-"; } 
    $dashes_cmname  = ""; for($i = 0; $i < $max_cm_name_width; $i++)  { $dashes_cmname .= "-"; } 

    $start_log_line = scalar(@{$log2printAR});

    if(open(SCORES,  ">" . $scores_file) == 0) { printf STDERR ("ERROR, could not open $scores_file for writing.\n"); exit(1); }
    if(open(TARGET, $target_file) == 0) { printf STDERR ("ERROR, could not open $target_file for reading.\n"); exit(1); }
    $i = 0;

    #print headers
    $dashes1 = ""; for($i = 0; $i < $max_cm_name_width + 39; $i++)  { $dashes1 .= "-"; } 
    $dashes2 = ""; for($i = 0; $i < $max_cm_name_width + 9;  $i++)  { $dashes2 .= "-"; } 

    # build column headers
    $best_string = "";
    $nleading_spaces  = int(($max_cm_name_width + 39 - length("best-matching model"))/2.);
    $ntrailing_spaces = ($max_cm_name_width + 39 - length("best-matching model")) - $nleading_spaces;
    for($i = 0; $i < $nleading_spaces;   $i++)  { $best_string .= " "; }
    $best_string .= "best-matching model";
    for($i = 0; $i < $ntrailing_spaces;  $i++)  { $best_string .= " "; }

    $second_string = "";
    $nleading_spaces  = int(($max_cm_name_width + 9 - length("second-best model"))/2.);
    $ntrailing_spaces = ($max_cm_name_width + 9 - length("second-best model")) - $nleading_spaces;
    for($i = 0; $i < $nleading_spaces;   $i++)  { $second_string .= " "; }
    $second_string .= "second-best model";
    for($i = 0; $i < $ntrailing_spaces;  $i++)  { $second_string .= " "; }

    printf SCORES ("# %7s  %-*s  %-*s", "", $max_seq_name_width, "", $max_cm_name_width + 39, $best_string);
    if($ncm > 1) { printf SCORES ("  %-*s", $max_cm_name_width + 9, $second_string); }
    printf SCORES ("\n");

    printf SCORES ("# %7s  %-*s  %-*s", "", $max_seq_name_width, "", $max_cm_name_width + 39, $dashes1);
    if($ncm > 1) { printf SCORES ("  %-*s", $max_cm_name_width + 9, $dashes2); }
    printf SCORES ("\n");

    printf SCORES ("# %7s  %-*s  %-*s  %4s  %4s  %7s  %7s  %7s", "idx", $max_seq_name_width, "sequence name", $max_cm_name_width, "model name",   "beg",  "end",  "CM sc",  "struct",  "HMM sc");
    if($ncm > 1) { printf SCORES ("  %-*s  %7s  %7s", $max_cm_name_width, "model name",   "HMM sc",  "HMMdiff"); }
    printf SCORES ("\n");

    printf SCORES ("# %7s  %-*s  %-*s  %4s  %4s  %7s  %7s  %7s", "-------", $max_seq_name_width, $dashes_seqname, $max_cm_name_width, $dashes_cmname, "----", "----", "-------", "-------", "-------");
    if($ncm > 1) { printf SCORES ("  %-*s  %7s  %7s", $max_cm_name_width, $dashes_cmname, "-------", "-------"); }
    printf SCORES ("\n");

    $idx = 1;
    while($line = <TARGET>) { 
	if($line =~ s/^\>//) { 
	    chomp $line;
	    $line =~ s/\s+.*$//;
	    $seq_name = $line;
	    if(exists($winning_cmHR->{$seq_name})) { 
		$winning_cm = $winning_cmHR->{$seq_name};
		($cmsc, $cmstructsc)                         = split(/\s+/, $cmscores2printHR->{$seq_name});
		($start, $end, $whmmsc, $secondhmm, $shmmsc) = split(/\s+/, $hmmscores2printHR->{$seq_name});

		printf SCORES ("  %7d  %-*s  %-*s  %4d  %4d  %7.2f  %7.2f  %7.2f", $idx, $max_seq_name_width, $seq_name, $max_cm_name_width, $winning_cm, $start, $end, $cmsc, $cmstructsc, $whmmsc);
		if($ncm > 1 && ($secondhmm ne $winning_cm)) { printf SCORES ("  %-*s  %7.2f  %7.2f", $max_cm_name_width, $secondhmm, $shmmsc, ($whmmsc - $shmmsc)); }
		elsif($ncm > 1)                             { printf SCORES ("  %-*s  %7s  %7s",    $max_cm_name_width, "-", "-", "-"); }
	    }
	    else {
		printf SCORES ("  %7d  %-*s  %-*s  %4s  %4s  %7s  %7s  %7s", $idx, $max_seq_name_width, $seq_name, $max_cm_name_width, "-", "-", "-", "-", "-", "-");
		if($ncm > 1) { printf SCORES ("  %-*s  %7s  %7s", $max_cm_name_width, "-", "-", "-"); }
	    }
	    printf SCORES ("\n");
	    $idx++;
	}
    }
    close(TARGET);
    close(SCORES);
}

