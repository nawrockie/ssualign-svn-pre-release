#!/usr/bin/perl
#
# ssu-merge
# Eric Nawrocki
# EPN, Tue Oct 27 14:07:30 2009
#
# Usage: ssu-merge [options] <directory created by ssu-align --prep-n or --prep-p call>
#             
# Synopsis:
# Merges alignments created by ssu-align. When ssu-align is run with the 
# --prep-n or --prep-p 'preparation mode' options it generates a script that
# performs multiple ssu-align jobs. When these are finished running, 
# ssu-merge is used to merge the alignments from the multiple jobs 
# together into a single alignment for each CM used by ssu-align.
#
# Step 1. Verify that all ssu-align jobs are complete.
# Step 2. Merge alignments from multiple ssu-align jobs. 
# Step 3. Concatenate other relevant files from multiple ssu-align jobs.
#
# See definition of $options_usage for options, below.
#
use Getopt::Long;
use Cwd 'abs_path';
use strict;
use warnings;

#Make sure the SSUALIGNDIR environmental variable is set and the directory exists
my $ssualigndir = $ENV{'SSUALIGNDIR'};
if(! exists($ENV{'SSUALIGNDIR'})) { 
    printf STDERR ("ERROR, the environment variable SSUALIGNDIR is not set, please set it to the directory where you installed SSU-ALIGN.\n"); 
    exit(1); 
}
if(! (-d $ssualigndir)) { 
    printf STDERR ("ERROR, the ssu-align directory specified by your environment variable SSUALIGNDIR does not exist, see the User's Guide Installation section.\n"); 
    exit(1); 
}    
#Make sure the SSUALIGNDIR directory includes ssu-align-0p1.subs.pm
my $subs_file = $ssualigndir . "/ssu-align-0p1.subs.pm";
if(! (-e $subs_file)) { 
    printf STDERR ("ERROR, the required perl module ssu-align-0p1.subs.pm is not in the directory specified by your SSUALIGNDIR environment variable.\n"); 
    exit(1); 
}
require $subs_file;

my $total_time     = -1 * time();
my $script_desc    = "merge SSU rRNA alignments";
my $date           = scalar localtime();
my $usage          = "Usage: ssu-merge [-options] <dir created by ssu-align --prep-n or --prep-p call>";
my $options_usage  = "where general options are:\n";
#                           1         2         3         4         5         6         7         8
#                  12345678901234567890123456789012345678901234567890123456789012345678901234567890
$options_usage .= "  -h     : show brief help on version and usage\n";
$options_usage .= "  -1     : output alignments in non-interleaved, 1 line/seq format\n";
$options_usage .= "  -m <s> : use CM file <f> instead of the default CM file\n";
$options_usage .= "  -F     : force; allow file clobbering\n" ,


###################
# Process options #
###################
my %opt_H = ();              # key: option (example "-h"); value: option argument (example ("0" or "1") if option takes no arg, actual argument if option takes arg)
my %opt_takes_arg_H  = ();   # key: option; value: "1" if option takes argument, "0" if not
my @opt_order_A  = ();       # order of options for printing in banner
my $opt;

$opt_takes_arg_H{"-h"}          = 0;  push(@opt_order_A, "-h");
$opt_takes_arg_H{"-1"}          = 0;  push(@opt_order_A, "-1");
$opt_takes_arg_H{"-m"}          = 1;  push(@opt_order_A, "-m");
$opt_takes_arg_H{"-F"}          = 0;  push(@opt_order_A, "-F");

#set default options
foreach $opt (keys %opt_takes_arg_H) { 
    if($opt_takes_arg_H{$opt}) { $opt_H{$opt} = ""; }
    else                       { $opt_H{$opt} = 0; }
}

# the only global variables, defaults and special strings
our $df_none_name = "<NONE>";

Getopt::Long::Configure ("bundling");
my $opt_return = GetOptions
    ('h'         => \$opt_H{"-h"}, 
     '1'         => \$opt_H{"-1"},
     'm=s'       => \$opt_H{"-m"},
     'F'         => \$opt_H{"-F"});

if($opt_return != 1) { exit(1); }

if ($opt_H{"-h"}) { 
    PrintBanner($0, $script_desc, $date, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, "");
    print $usage . "\n"; 
    print $options_usage; 
    exit(1); 
} 


################
# Print banner #
################
if(scalar(@ARGV) != 1) {   
    print "Incorrect number of command line arguments.\n";
    print $usage;
    print "\nTo see more help on available options, do ssu-draw -h\n\n";
    exit(1);
}
my ($dir) = @ARGV;

my $sum_file       = $dir . "/" . $dir . ".ssu-merge.sum";
my $sum_file2print = $dir . ".ssu-merge.sum";
my $log_file       = $dir . "/" . $dir . ".ssu-merge.log";
my $log_file2print = $dir . ".ssu-merge.log";

# open the summary and log files
open(OUT, ">" . $sum_file) || die "ERROR, couldn't open file $sum_file for writing";
close(OUT);
open(OUT, ">" . $log_file) || die "ERROR, couldn't open file $log_file for writing";
close(OUT);

PrintBanner($0, $script_desc, $date, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, 1, $sum_file);
PrintBanner($0, $script_desc, $date, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, 0, $log_file);


##################################
# Validate that everything is go #
##################################
my ($cmalign, $cm_file);
my @subdir_A = ();
my @score_to_merge_A = ();
my @sum_to_merge_A = ();
my @tab_to_merge_A = ();
my @cmalign_to_merge_AA = ();
my @hits_fa_to_merge_AA = ();
my @hits_list_to_merge_AA = ();
my @stk_to_merge_AA = ();
my @cm_names_A = ();
validate_and_setup_ssu_merge($ssualigndir, a\%opt_H, $dir, \@subdir_A, \@score_to_merge_A, \@sum_to_merge_A, \@tab_to_merge_A, \@cmalign_to_merge_AA, \@hits_fa_to_merge_AA, \@hits_list_to_merge_AA, \@stk_to_merge_AA, \@cm_names_A, \$cmalign, \$cm_file);


####################################
# Merge files including alignments #
####################################

my ($i, $j, $cm_idx, $nhitsfa, $nhitslist, $ncmalign, $nstk);
my ($scores_file, $ssu_align_sum_file, $tab_file, $cmalign_file, $hitsfa_file, $hitslist_file, $merged_stk_file);
my ($scores_file2print, $ssu_align_sum_file2print, $tab_file2print, $cmalign_file2print, $hitsfa_file2print, $hitslist_file2print, $merged_stk_file2print);
my ($max_file_name_width, $max_cm_name_width, $file_dashes, $cm_dashes, $nseq_merged);

if(scalar(@score_to_merge_A) == 0) { printf STDERR ("ERROR, no *.scores files found.\n"); exit(1); }
if(scalar(@sum_to_merge_A)   == 0) { printf STDERR ("ERROR, no *.sum files found.\n"); exit(1); }
if(scalar(@tab_to_merge_A)   == 0) { printf STDERR ("ERROR, no *.tab files found.\n"); exit(1); }

$max_cm_name_width = MaxLengthScalarInArray(\@cm_names_A);
if($max_cm_name_width < length("CM name")) { $max_cm_name_width = length("CM name"); }
$cm_dashes = ""; for($i = 0; $i < $max_cm_name_width; $i++) { $cm_dashes .= "-"; } 

$max_file_name_width  = MaxLengthScalarInArray(\@cm_names_A) + 1;
if($max_file_name_width < length("scores")) { $max_file_name_width = length("scores"); }
$max_file_name_width += length("hits.list");
$max_file_name_width += length($dir) + 1;
$file_dashes = ""; for($i = 0; $i < $max_file_name_width; $i++) { $file_dashes .= "-"; } 
    
PrintStringToFile($sum_file, 1, sprintf("#\n# Merging files from %d ssu-align runs...\n", scalar(@score_to_merge_A))); 
PrintStringToFile($sum_file, 1, sprintf("#\n"));
PrintStringToFile($sum_file, 1, sprintf("# %-*s  %-*s  %7s  %9s\n", $max_file_name_width, "",                 $max_cm_name_width, "",         "\# files", "\# seqs"));
PrintStringToFile($sum_file, 1, sprintf("# %-*s  %-*s  %7s  %9s\n", $max_file_name_width, "merged file name", $max_cm_name_width, "CM name",  "merged", "merged"));
PrintStringToFile($sum_file, 1, sprintf("# %-*s  %-*s  %7s  %9s\n", $max_file_name_width, $file_dashes,       $max_cm_name_width, $cm_dashes, "-------", "---------"));

$scores_file              = $dir . "/" . $dir . ".scores";
$ssu_align_sum_file       = $dir . "/" . $dir . ".ssu-align.sum";
$tab_file                 = $dir . "/" . $dir . ".tab";
$scores_file2print        = $dir . ".scores";
$ssu_align_sum_file2print = $dir . ".ssu-align.sum";
$tab_file2print           = $dir . ".tab";

concatenate_a_list_of_files(\%opt_H, $scores_file, \@score_to_merge_A);
PrintStringToFile($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9s\n", $max_file_name_width, $scores_file2print, $max_cm_name_width, "-", scalar(@score_to_merge_A), "-"));

concatenate_a_list_of_files(\%opt_H, $ssu_align_sum_file, \@sum_to_merge_A);
PrintStringToFile($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9s\n", $max_file_name_width, $ssu_align_sum_file2print, $max_cm_name_width, "-", scalar(@sum_to_merge_A), "-"));

concatenate_a_list_of_files(\%opt_H, $tab_file, \@tab_to_merge_A);
PrintStringToFile($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9s\n", $max_file_name_width, $tab_file2print, $max_cm_name_width, "-", scalar(@tab_to_merge_A), "-"));

PrintStringToFile($sum_file, 1, sprintf("#\n"));

for($i = 0; $i < scalar(@cm_names_A); $i++) { 
    $nhitsfa   = scalar(@{$hits_fa_to_merge_AA[$i]});
    $nhitslist = scalar(@{$hits_list_to_merge_AA[$i]});
    $ncmalign  = scalar(@{$cmalign_to_merge_AA[$i]});
    $nstk      = scalar(@{$stk_to_merge_AA[$i]});
    $cm_idx    = $i+1;
    if($nhitsfa != $nhitslist)  { printf STDERR ("ERROR, for cm $cm_names_A[$i], %d *.hits.fa files but %d *.hits.list files.\n", $nhitsfa, $nhitslist); exit(1); }
    if($nhitsfa != $ncmalign)   { printf STDERR ("ERROR, for cm $cm_names_A[$i], %d *.hits.fa files but %d *.cmalign files.\n", $nhitsfa, $ncmalign); exit(1); }
    if($nhitsfa != $nstk)       { printf STDERR ("ERROR, for cm $cm_names_A[$i], %d *.hits.fa files but %d *.stk files.\n", $nhitsfa, $nstk); exit(1); }
    if($nhitsfa > 0) { 
	$cmalign_file          = $dir . "/" . $dir . "." . $cm_names_A[$i] . ".cmalign";
	$hitsfa_file           = $dir . "/" . $dir . "." . $cm_names_A[$i] . ".hits.fa";
	$hitslist_file         = $dir . "/" . $dir . "." . $cm_names_A[$i] . ".hits.list";
	$merged_stk_file       = $dir . "/" . $dir . "." . $cm_names_A[$i] . ".stk";
	$cmalign_file2print    = $dir . "." . $cm_names_A[$i] . ".cmalign";
	$hitsfa_file2print     = $dir . "." . $cm_names_A[$i] . ".hits.fa";
	$hitslist_file2print   = $dir . "." . $cm_names_A[$i] . ".hits.list";
	$merged_stk_file2print = $dir . "." . $cm_names_A[$i] . ".stk";

	concatenate_a_list_of_files(\%opt_H, $hitsfa_file, \@{$hits_fa_to_merge_AA[$i]});
	#determine total number of sequences in all the hits fasta files we just merged
	$nseq_merged = 0;
	for($j = 0; $j < scalar(@{$hits_fa_to_merge_AA[$i]}); $j++) { 
	    $nseq_cur     = DetermineNumSeqsFasta($hits_fa_to_merge_AA[$i][$j]);
	    if($nseq_target_file == -1) { 
		my $errmsg = "\nERROR, sequence file $hits_fa_to_merge_AA[$i][$j] should be FASTA formatted, but non-whitespace found before first \">\" (not valid FASTA).\n"; 
		PrintStringToFile($sum_file, 0, $errmsg);
		die $errmsg; 
	    }
	    if($nseq_target_file == 0)  { 
		my $errmsg = "\nERROR, sequence file $hits_fa_to_merge_AA[$i][$j] should be FASTA formatted, but no \">\" found.\n"; 
		PrintStringToFile($sum_file, 0, $errmsg);
		die $errmsg; 
	    }
	    $nseq_merged += $nseq_cur;
	}
	PrintStringToFile($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9d\n", $max_file_name_width, $hitsfa_file2print, $max_cm_name_width, $cm_names_A[$i], $nhitsfa, $nseq_merged));

	concatenate_a_list_of_files(\%opt_H, $hitslist_file, \@{$hits_list_to_merge_AA[$i]});
	PrintStringToFile($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9d\n", $max_file_name_width, $hitslist_file2print, $max_cm_name_width, $cm_names_A[$i], $nhitslist, $nseq_merged));

	concatenate_a_list_of_files(\%opt_H, $cmalign_file,  \@{$cmalign_to_merge_AA[$i]});
	PrintStringToFile($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9d\n", $max_file_name_width, $cmalign_file2print, $max_cm_name_width, $cm_names_A[$i], $ncmalign, $nseq_merged));

	merge_alignments_for_a_cm(\%opt_H, $merged_stk_file, $dir, $cm_file, $cm_idx, $cm_names_A[$i], \@{$stk_to_merge_AA[$i]});
	PrintStringToFile($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9d\n", $max_file_name_width, $merged_stk_file2print, $max_cm_name_width, $cm_names_A[$i], $nstk, $nseq_merged));

	PrintStringToFile($sum_file, 1, sprintf("#\n"));
    }
}


############
# Conclude #
############
$total_time += time();
PrintConclusion($sum_file, $log_file2print, $sum_file2print, $total_time, $dir);

# Success! Exit normally
exit(0); 


###############
# Subroutines #
###############


#####################################################################
# Subroutine: validate_and_setup_ssu_merge()
# Incept:     EPN, Tue Oct 27 14:26:48 2009
# 
# Purpose:    Validation and setup:
#             - validate that the required executable programs exist
#             - determine which directories have alignments we will
#               merge together, and that they look as if they were
#               created with a ssu-align --prep-p or --prep-n call.
#             - verify that all ssu-align runs are done
#
# Arguments: 
# $ssualigndir:            dir defined by SSUALIGNDIR environment variable 
# $opt_HR:                 reference to hash of command line options
# $dir:                    main directory created by ssu-align --prep-* that 
#                          includes subdirectories with alignments
# $subdir_AR:              reference to the array of subdirectories created by ssu-align, filled here
# $score_to_merge_AR:      reference to array of ssu-align .scores files to merge (concatenate)
# $sum_to_merge_AR:        reference to array of ssu-align .sum files to merge (concatenate)
# $tab_to_merge_AR:        reference to array of ssu-align .tab files to merge (concatenate)
# $cmalign_to_merge_AAR:   reference to 2D array of ssu-align .cmalign output files to merge,
#                          first dimension is the corresponding CM's index in the cm file
# $hits_fa_to_merge_AAR:   reference to 2D array of ssu-align .hits.fa output file to merges,
#                          first dimension is the corresponding CM's index in the cm file
# $hits_list_to_merge_AAR: reference to 2D array of ssu-align .hits.list output files to merge,
#                          first dimension is the corresponding CM's index in the cm file
# $stk_to_merge_AAR:       reference to 2D array of ssu-align .stk alignment files to merge
#                          first dimension is the corresponding CM's index in the cm file
# $cm_names_AR:            reference to a hash of arrays of alignments to merge, hash key is CM name, 
# $cmalign_R:              RETURN; cmalign executable command
# $cm_file_R:              RETURN; the path to the CM file, either default CM file or <s> from -m <s>
# 
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If a required program does not exist, a directory
#             that we think should be there does not exist, or
#             an ssu-align job appears to not have finished, we
#             print a message to STDERR and exit with non-zero status.
#
####################################################################
sub validate_and_setup_ssu_merge { 
    my $narg_expected = 14;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, validate_and_setup_ssu_merge() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($ssualigndir, $opt_HR, $dir, $subdir_AR, $score_to_merge_AR, $sum_to_merge_AR, $tab_to_merge_AR, $cmalign_to_merge_AAR, $hits_fa_to_merge_AAR, $hits_list_to_merge_AAR, $stk_to_merge_AAR, $cm_names_AR, $cmalign_R, $cm_file_R) = @_;

    #Make sure $dir exists
    if(!(-d $dir)) { printf STDERR ("\nERROR, directory $dir does not exist.\n"); exit(1); }

    #Make sure the CM file exists
    my $cm_file = "";
    if($opt_HR->{"-m"} ne "") { 
	$cm_file = $opt_HR->{"-m"}; 
	if(!(-e $cm_file))   { printf STDERR ("ERROR, CM file $cm_file, specified with -M does not exist.\n"); exit(1); }
    }
    else { 
	$cm_file = $ssualigndir . "/ssu-align-0p1.cm";
	if(!(-e $cm_file))   { printf STDERR ("ERROR, the default CM file $cm_file does not exist.\n"); exit(1); }
    }

    # determine CM names
    my %cm_name_idx_H = ();
    my ($cm_name, $line);
    my $ncm = 0;
    if(open(CM, $cm_file) == 0) { printf STDERR ("ERROR, could not open $cm_file for reading.\n"); exit(1); }
    while($line = <CM>) {
	# the lines we're interested in look like this:
	#NAME     archaea
	if($line =~ /^NAME\s+(\S+)/) { 
	    $cm_name = $1;
	    push(@{$cm_names_AR}, $cm_name);
	    if(exists($cm_name_idx_H{$cm_name})) { printf STDERR ("ERROR, two CMs in CM file $cm_file have the name $cm_name. Each CM must have a unique name.\n"); exit(1); }
	    # initialize arrays for this cm:
	    @{$cmalign_to_merge_AAR->[$ncm]} = ();
	    @{$hits_fa_to_merge_AAR->[$ncm]} = ();
	    @{$hits_list_to_merge_AAR->[$ncm]} = ();
	    $cm_name_idx_H{$cm_name} = $ncm++;

	    if($cm_name eq $df_none_name) { printf STDERR ("ERROR, you can't use a CM with the name $df_none_name, that's reserved for indicating which sequences are not the best-match to any models.\n"); exit(1); }
	}
    }
    close(CM);

    # check that cmalign is in the PATH
    my ($tmp, $command);
    my $cmalign    = "ssu-cmalign";
    RunExecutable("$cmalign -h > /dev/null", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $cmalign is not in your PATH environment\nvariable. See the User's Guide Installation section.");;

    # determine which subdirectories in $dir were created by ssu-align
    my %subdir_H = ();
    my $max_num = 0;
    my ($subdir, $num, $file, $cm, $maybe_dir);
    foreach $maybe_dir (glob("$dir/*")) { 
	if(-d $maybe_dir) { # $maybe_dir is a dir
	    if($subdir =~ /^$dir\.(\d+)$/) { 
		$num = $1;
		if($num > 0) { #don't bother with '0' or negative numbers, they weren't created by ssu-align 
		    if($num > $max_num) { $max_num = $num; }
		    $subdir_H{$subdir} = 1;
		}
	    }
	}		
    }

    # verify we have a contiguous set of ssu-align created subdirectories, each
    # of which contains a finished sum file that indicates ssu-align is done running there.
    my @cpu_A = ();
    my ($sum_file, $seen_cpu);
    if($max_num == 0) { printf STDERR ("\nERROR, couldn't find any subdirectories created by ssu-align in $dir.\nDid you run the shell script created by your initial ssu-align --prep-* call?\n"); exit(1); }
    # Make sure we have all directories from <dir>.1 to <dir>.$max_num, and they all
    # contain ssu-align sum files in them that are finished running.
    for($i = 1; $i <= $max_num; $i++) { 
	$subdir = "$dir." . $i;
	if(! (exists $subdir_H{($subdir)})) { 
	    printf STDERR ("\nERROR, ssu-align created subdirectory " . $dir . "." . $i . " does not exist in $dir (but " . $dir . "." . $max_num . " does).\n"); exit(1); 
	}
	$sum_file = $dir . "/" . $subdir . "/" . $subdir . ".ssu-align.sum";
	if(! (-e $sum_file)) { 
	    printf STDERR ("\nERROR, ssu-align created subdirectory " . $dir . "/$subdir does not have a ssu-align summary (.sum) file in it.\nThis suggests the ssu-align job for that directory has not completed executing yet.\nPlease execute it, or if it is currently executing, wait until it is finished.\nThen run ssu-merge again.\n"); exit(1);  
	}
	# look for a line starting with  "# CPU" (reporting running time) in ssu-align summary file (it should be there if the file is finished running) 
	open(SUM, $sum_file) || die "\nERROR, unable to open file $sum_file, but it exists.\nIt is possible the ssu-align job is still running, and this file is currently being written to.\n";
	$seen_cpu = 0;
	while($line = <SUM>) { 
	    if($line =~ m/^\#\s+CPU time/) { $seen_cpu = 1; }
	}
	close(SUM);
	if(! $seen_cpu) { 
	    printf STDERR ("\nERROR, ssu-align created subdirectory " . $dir . "/$subdir has an incomplete ssu-align summary (.sum) file in it.\nThis suggests the ssu-align job for that directory did not successfully finish running yet.\nPlease rerun it or wait until it is finished.\nThen run ssu-merge again.\n"); exit(1);  
	}
	push(@{$subdir_AR}, $subdir);
    }

    # make a list of alignments to merge, by checking each subdirectory for each possible alignment (one per CM)
    foreach $subdir (@{$subdir_AR}) { 
	# each directory should have:
	# $subdir.scores
	# $subdir.ssu-align.sum
	# $subdir.tab
	#
	# and potentially for each CM $cm:
	# $subdir.$cm.cmalign
	# $subdir.$cm.hits.fa
	# $subdir.$cm.hits.list
	# $subdir.$cm.stk
	# 

	foreach $file (glob("$dir/$subdir/")) { 
	    if($file =~ /$subdir\.scores/) { 
		push(@{$score_to_merge_AR}, ($dir . "/" . $subdir . "/" . $file));
	    }
	    if($file =~ /$subdir\.ssu-align.sum/) { 
		push(@{$sum_to_merge_AR}, ($dir . "/" . $subdir . "/" . $file));
	    }
	    if($file =~ /$subdir\.tab/) { 
		push(@{$tab_to_merge_AR}, ($dir . "/" . $subdir . "/" . $file));
	    }
	    if($file =~ /$subdir\.(\S+)\.cmalign/) { 
		$cm = $1;
		if(! (exists($cm_name_idx_H{$cm}))) { printf STDERR ("\nERROR, found ssu-align output file $file in subdirectory $subdir/ created for a CM named $cm\nNo such CM exists in $cm_file.\nDid you use -m <s> when you ran ssu-align? If so pass -m <s> to ssu-merge as well.\n"); exit(1); }
		push(@{$cmalign_to_merge_AAR->[$cm_name_idx_H{$cm}]}, ($dir . "/" . $subdir . "/" . $file));
	    }
	    if($file =~ /$subdir\.(\S+)\.hits.fa/) { 
		$cm = $1;
		if(! (exists($cm_name_idx_H{$cm}))) { printf STDERR ("\nERROR, found ssu-align output file $file in subdirectory $subdir/ created for a CM named $cm\nNo such CM exists in $cm_file.\nDid you use -m <s> when you ran ssu-align? If so pass -m <s> to ssu-merge as well.\n"); exit(1); }
		push(@{$hits_fa_to_merge_AAR->[$cm_name_idx_H{$cm}]}, ($dir . "/" . $subdir . "/" . $file));
	    }
	    if($file =~ /$subdir\.(\S+)\.hits.list/) { 
		$cm = $1;
		if(! (exists($cm_name_idx_H{$cm}))) { printf STDERR ("\nERROR, found ssu-align output file $file in subdirectory $subdir/ created for a CM named $cm\nNo such CM exists in $cm_file.\nDid you use -m <s> when you ran ssu-align? If so pass -m <s> to ssu-merge as well.\n"); exit(1); }
		push(@{$hits_list_to_merge_AAR->[$cm_name_idx_H{$cm}]}, ($dir . "/" . $subdir . "/" . $file));
	    }
	    if($file =~ /$subdir\.(\S+)\.stk/) { 
		$cm = $1;
		if(! (exists($cm_name_idx_H{$cm}))) { printf STDERR ("\nERROR, found ssu-align output file $file in subdirectory $subdir/ created for a CM named $cm\nNo such CM exists in $cm_file.\nDid you use -m <s> when you ran ssu-align? If so pass -m <s> to ssu-merge as well.\n"); exit(1); }
		push(@{$stk_to_merge_AAR->[$cm_name_idx_H{$cm}]}, ($dir . "/" . $subdir . "/" . $file));
	    }
	}
    }	
    $$cmalign_R     = $cmalign;
    $$cm_file_R     = $cm_file;

    return;
}


#####################################################################
# Subroutine: merge_alignments_for_a_cm()
# Incept:     EPN, Tue Oct 27 18:05:43 2009
# 
# Purpose:    Given a list of alignments created by the same CM to merge, 
#             merge them with a single call to cmalign --list-merge.
#
# Arguments: 
# $opt_HR:           reference to hash of command line options
# $stk_name:         name for merged alignment file
# $dir:              main directory created by ssu-align --prep-* that 
#                    includes subdirectories with alignments
# $cm_file:          the CM file
# $cm_idx:           index of the relevant CM in the CM file
# $cm_name:          name of the relevant CM in the CM file
# $stk_to_merge_AR:  reference to the array of alignments to merge
# 
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If something goes wrong, this subroutine prints an
#             error and exits.
#
####################################################################
sub merge_alignments_for_a_cm { 
    my $narg_expected = 7;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, merge_alignments_for_a_cm() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($opt_HR, $stk_name, $dir, $cm_file, $cm_idx, $cm_name, $stk_to_merge_AR) = @_;

    my ($output, $stk, $command, $output);

    # create a temporary file with the stk list:
    my $list_file = $dir . "/" . $cm_name . ".merge.list";
    if(! (open(LIST, ">" . $list_file))) { printf STDERR ("ERROR, couldn't open list file $list_file for merging alignments with CM: $cm_name\n"); }
    foreach $stk (@{$stk_to_merge_AR})   { printf LIST ("$stk\n"); }
    close(LIST);

    if(-e $stk_name) { 
	if(! ($opt_HR->{"-F"})) { 
	    printf STDERR ("ERROR, alignment file $stk_name already exists. Delete it or use -F to overwrite it.\n"); exit(1); 
	}
	else {
	    UnlinkFile($stk_name, $log_file);
	}
    }

    my $extra_opts = "";
    if($opt_HR->{"-1"}) { $extra_opts = " -1"; }

    $command = "$cmalign $extra_opts --cm-idx $cm_idx --list-merge -o $stk_name $cm_file $list_file 2>&1";
    RunExecutable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");

    return;
}


#####################################################################
# Subroutine: concatenate_a_list_of_files()
# Incept:     EPN, Wed Oct 28 17:12:05 2009
# 
# Purpose:    Given a list of files to concatenate, do it.
#
# Arguments: 
# $opt_HR:              reference to hash of command line options
# $concat_file:         the name for the file we want to concatenate
# $files_to_concat_AR:  reference to the array of files to concatenate
# 
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If something goes wrong, this subroutine prints an
#             error and exits.
#
####################################################################
sub concatenate_a_list_of_files { 
    my $narg_expected = 3;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, concatenate_a_list_of_files() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($opt_HR, $concat_file, $files_to_concat_AR) = @_;

    if(scalar(@{$files_to_concat_AR}) == 0) { return; } #if array is empty, just leave

    my ($file, $command, $output, $i);

    # ensure all the files exist
    foreach $file (@{$files_to_concat_AR}) { 
	if(! (-e $file)) { printf STDERR ("ERROR, file $file does not exist, (it was to be cat'ed to $concat_file.\n"); exit(1); }
    }

    # check if concat file already exists
    if(-e $concat_file) { 
	if(! ($opt_HR->{"-F"})) { 
	    printf STDERR ("ERROR, file $concat_file already exists. Delete it or use -F to overwrite it.\n"); exit(1); 
	}
	else {
	    UnlinkFile($concat_file, $log_file);
	}
    }

    # create concat file
    $command = "cat $files_to_concat_AR->[0] > $concat_file";
    RunExecutable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");

    # add to concat file
    for($i = 1; $i < scalar(@{$files_to_concat_AR}); $i++) { 
	RunExecutable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");
    }

    return;
}

