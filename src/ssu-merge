#!/usr/bin/perl
#
# ssu-merge
# Eric Nawrocki
# EPN, Tue Oct 27 14:07:30 2009
#
# Usage: ssu-merge [options] <directory created by ssu-align --prep-n or --prep-p call>
#             
# Synopsis:
# Merges alignments created by ssu-align. When ssu-align is run with the 
# --prep-n or --prep-p 'prepare-mode' options it generates a script that
# performs multiple ssu-align jobs. When these are finished running, 
# ssu-merge is used to merge the alignments from the multiple jobs 
# together into a single alignment for each CM used by ssu-align.
#
# Step 1. Verify that all ssu-align jobs are complete.
# Step 2. Merge alignments from multiple ssu-align jobs. 
# Step 3. Concatenate other relevant files from multiple ssu-align jobs.
#
# See definition of $options_usage for options, below.
#
use Getopt::Long;
use Cwd 'abs_path';
use strict;

my $total_time = -1 * time();
my $usage = "Usage: ssu-merge [-options] <directory created by ssu-align --prep-n or --prep-p call>";
my $options_usage  = "where general options are:\n";
#                           1         2         3         4         5         6         7         8
#                  12345678901234567890123456789012345678901234567890123456789012345678901234567890
$options_usage .= "  -h     : show brief help on version and usage\n";
$options_usage .= "  -1     : output alignments in non-interleaved, 1 line/seq format\n";
$options_usage .= "  -m <s> : use CM file <f> instead of the default CM file\n";
$options_usage .= "  -F     : force; allow file clobbering\n" ,

###################
# Process options #
###################
my %opt_H = ();              # key: option (example "-h"); value: option argument (example ("0" or "1") if option takes no arg, actual argument if option takes arg)
my %opt_takes_arg_H  = ();   # key: option; value: "1" if option takes argument, "0" if not
my @opt_order_A  = ();       # order of options for printing in banner
my $opt;

$opt_takes_arg_H{"-h"}          = 0;  push(@opt_order_A, "-h");
$opt_takes_arg_H{"-1"}          = 0;  push(@opt_order_A, "-1");
$opt_takes_arg_H{"-m"}          = 1;  push(@opt_order_A, "-m");
$opt_takes_arg_H{"-F"}          = 0;  push(@opt_order_A, "-F");

#set default options
foreach $opt (keys %opt_takes_arg_H) { 
    if($opt_takes_arg_H{$opt}) { $opt_H{$opt} = ""; }
    else                       { $opt_H{$opt} = 0; }
}

# the only global variables, defaults and special strings
our $df_none_name = "<NONE>";

Getopt::Long::Configure ("bundling");
my $opt_return = GetOptions
    ('h'         => \$opt_H{"-h"}, 
     '1'         => \$opt_H{"-1"},
     'm=s'       => \$opt_H{"-m"},
     'F'         => \$opt_H{"-F"});

if($opt_return != 1) { exit(1); }

if ($opt_H{"-h"}) { 
    print_banner($0, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, "");
    print $usage . "\n"; 
    print $options_usage; 
    exit(1); 
} 

################
# Print banner #
################
if(scalar(@ARGV) != 1) {   
    print "Incorrect number of command line arguments.\n";
    print $usage;
    print "\nTo see more help on available options, do ssu-draw -h\n\n";
    exit(1);
}
my ($dir) = @ARGV;

my $sum_file = $dir . "/" . $dir . ".ssu-merge.sum";
my $sum_file2print = $dir . ".ssu-merge.sum";
print_banner($0, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, $sum_file);


##################################
# Validate that everything is go #
##################################
my ($cmalign, $cm_file);
my @subdir_A = ();
my @score_to_merge_A = ();
my @sum_to_merge_A = ();
my @tab_to_merge_A = ();
my @cmalign_to_merge_AA = ();
my @hits_fa_to_merge_AA = ();
my @hits_list_to_merge_AA = ();
my @stk_to_merge_AA = ();
my @cm_names_A = ();
validate_and_setup(\%opt_H, $dir, \@subdir_A, \@score_to_merge_A, \@sum_to_merge_A, \@tab_to_merge_A, \@cmalign_to_merge_AA, \@hits_fa_to_merge_AA, \@hits_list_to_merge_AA, \@stk_to_merge_AA, \@cm_names_A, \$cmalign, \$cm_file);


####################################
# Merge files including alignments #
####################################

my ($i, $j, $cm_idx, $nhitsfa, $nhitslist, $ncmalign, $nstk);
my ($scores_file, $sum_file, $tab_file, $cmalign_file, $hitsfa_file, $hitslist_file, $merged_stk_file);
my ($scores_file2print, $sum_file2print, $tab_file2print, $cmalign_file2print, $hitsfa_file2print, $hitslist_file2print, $merged_stk_file2print);
my ($max_file_name_width, $max_cm_name_width, $file_dashes, $cm_dashes, $nseq_merged);

if(scalar(@score_to_merge_A) == 0) { printf STDERR ("ERROR, no *.scores files found.\n"); exit(1); }
if(scalar(@sum_to_merge_A)   == 0) { printf STDERR ("ERROR, no *.sum files found.\n"); exit(1); }
if(scalar(@tab_to_merge_A)   == 0) { printf STDERR ("ERROR, no *.tab files found.\n"); exit(1); }

$max_cm_name_width = max_length_scalar_in_array(\@cm_names_A);
if($max_cm_name_width < length("CM name")) { $max_cm_name_width = length("CM name"); }
$cm_dashes = ""; for($i = 0; $i < $max_cm_name_width; $i++) { $cm_dashes .= "-"; } 

$max_file_name_width  = max_length_scalar_in_array(\@cm_names_A) + 1;
if($max_file_name_width < length("scores")) { $max_file_name_width = length("scores"); }
$max_file_name_width += length("hits.list");
$max_file_name_width += length($dir) + 1;
$file_dashes = ""; for($i = 0; $i < $max_file_name_width; $i++) { $file_dashes .= "-"; } 
    
print_string_to_file($sum_file, 1, sprintf("#\n# Merging files from %d ssu-align runs...\n", scalar(@score_to_merge_A))); 
print_string_to_file($sum_file, 1, sprintf("#\n"));
print_string_to_file($sum_file, 1, sprintf("# %-*s  %-*s  %7s  %9s\n", $max_file_name_width, "",                 $max_cm_name_width, "",         "\# files", "\# seqs"));
print_string_to_file($sum_file, 1, sprintf("# %-*s  %-*s  %7s  %9s\n", $max_file_name_width, "merged file name", $max_cm_name_width, "CM name",  "merged", "merged"));
print_string_to_file($sum_file, 1, sprintf("# %-*s  %-*s  %7s  %9s\n", $max_file_name_width, $file_dashes,       $max_cm_name_width, $cm_dashes, "-------", "---------"));

$scores_file       = $dir . "/" . $dir . ".scores";
$sum_file          = $dir . "/" . $dir . ".ssu-align.sum";
$tab_file          = $dir . "/" . $dir . ".tab";
$scores_file2print = $dir . ".scores";
$sum_file2print    = $dir . ".ssu-align.sum";
$tab_file2print    = $dir . ".tab";

concatenate_a_list_of_files(\%opt_H, $scores_file, \@score_to_merge_A);
print_string_to_file($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9s\n", $max_file_name_width, $scores_file2print, $max_cm_name_width, "-", scalar(@score_to_merge_A), "-"));

concatenate_a_list_of_files(\%opt_H, $sum_file, \@sum_to_merge_A);
print_string_to_file($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9s\n", $max_file_name_width, $sum_file2print, $max_cm_name_width, "-", scalar(@sum_to_merge_A), "-"));

concatenate_a_list_of_files(\%opt_H, $tab_file, \@tab_to_merge_A);
print_string_to_file($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9s\n", $max_file_name_width, $tab_file2print, $max_cm_name_width, "-", scalar(@tab_to_merge_A), "-"));

print_string_to_file($sum_file, 1, sprintf("#\n"));

for($i = 0; $i < scalar(@cm_names_A); $i++) { 
    $nhitsfa   = scalar(@{$hits_fa_to_merge_AA[$i]});
    $nhitslist = scalar(@{$hits_list_to_merge_AA[$i]});
    $ncmalign  = scalar(@{$cmalign_to_merge_AA[$i]});
    $nstk      = scalar(@{$stk_to_merge_AA[$i]});
    $cm_idx    = $i+1;
    if($nhitsfa != $nhitslist)  { printf STDERR ("ERROR, for cm $cm_names_A[$i], %d *.hits.fa files but %d *.hits.list files.\n", $nhitsfa, $nhitslist); exit(1); }
    if($nhitsfa != $ncmalign)   { printf STDERR ("ERROR, for cm $cm_names_A[$i], %d *.hits.fa files but %d *.cmalign files.\n", $nhitsfa, $ncmalign); exit(1); }
    if($nhitsfa != $nstk)       { printf STDERR ("ERROR, for cm $cm_names_A[$i], %d *.hits.fa files but %d *.stk files.\n", $nhitsfa, $nstk); exit(1); }
    if($nhitsfa > 0) { 
	$cmalign_file          = $dir . "/" . $dir . "." . $cm_names_A[$i] . ".cmalign";
	$hitsfa_file           = $dir . "/" . $dir . "." . $cm_names_A[$i] . ".hits.fa";
	$hitslist_file         = $dir . "/" . $dir . "." . $cm_names_A[$i] . ".hits.list";
	$merged_stk_file       = $dir . "/" . $dir . "." . $cm_names_A[$i] . ".stk";
	$cmalign_file2print    = $dir . "." . $cm_names_A[$i] . ".cmalign";
	$hitsfa_file2print     = $dir . "." . $cm_names_A[$i] . ".hits.fa";
	$hitslist_file2print   = $dir . "." . $cm_names_A[$i] . ".hits.list";
	$merged_stk_file2print = $dir . "." . $cm_names_A[$i] . ".stk";

	concatenate_a_list_of_files(\%opt_H, $hitsfa_file, \@{$hits_fa_to_merge_AA[$i]});
	#determine total number of sequences in all the hits fasta files we just merged
	$nseq_merged = 0;
	for($j = 0; $j < scalar(@{$hits_fa_to_merge_AA[$i]}); $j++) { 
	    $nseq_merged += determine_num_seqs($hits_fa_to_merge_AA[$i][$j]);
	}
	print_string_to_file($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9d\n", $max_file_name_width, $hitsfa_file2print, $max_cm_name_width, $cm_names_A[$i], $nhitsfa, $nseq_merged));

	concatenate_a_list_of_files(\%opt_H, $hitslist_file, \@{$hits_list_to_merge_AA[$i]});
	print_string_to_file($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9d\n", $max_file_name_width, $hitslist_file2print, $max_cm_name_width, $cm_names_A[$i], $nhitslist, $nseq_merged));

	concatenate_a_list_of_files(\%opt_H, $cmalign_file,  \@{$cmalign_to_merge_AA[$i]});
	print_string_to_file($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9d\n", $max_file_name_width, $cmalign_file2print, $max_cm_name_width, $cm_names_A[$i], $ncmalign, $nseq_merged));

	merge_alignments_for_a_cm(\%opt_H, $merged_stk_file, $dir, $cm_file, $cm_idx, $cm_names_A[$i], \@{$stk_to_merge_AA[$i]});
	print_string_to_file($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9d\n", $max_file_name_width, $merged_stk_file2print, $max_cm_name_width, $cm_names_A[$i], $nstk, $nseq_merged));

	print_string_to_file($sum_file, 1, sprintf("#\n"));
    }
}


#################
# Print timings #
#################
$total_time += time();

my $ssu_merge_sum_file = $dir . "/" . $dir . ".ssu-merge.sum";
my $ssu_merge_sum_file2print = $dir . ".ssu-merge.sum";
print_string_to_file($sum_file, 1, sprintf("# Summary file (*this* text printed to stdout) saved to %.\n", $ssu_merge_sum_file2print));

print_string_to_file($sum_file, 1, sprintf("#\n# All output files created in directory \.\/%s\/\n", $dir));
print_string_to_file($sum_file, 1, sprintf("#\n"));

print_timing("# CPU time: ", $total_time, $sum_file);
print_string_to_file($sum_file, 1, sprintf("\/\/\n"));

# success, exit normally
exit(0); 


###############
# Subroutines #
###############

#####################################################################
# Subroutine: print_banner()
# Incept:     EPN, Tue Jun 16 07:26:13 2009
# 
# Purpose:    Print the ssu-align banner and determine prep options
#             that will be passed to subsequent ssu-align calls if
#             we're in prep mode.
#
# Arguments: 
#    $script_call:            call used to invoke this (ssu-align) script
#    $opt_HR:                 REFERENCE to hash of command-line options
#    $opt_takes_arg_HR:       REFERENCE to hash telling if each option takes an argument (1) or not (0)
#    $opt_order_AR:           REFERENCE to array specifying order of options
#    $argv_R:                 REFERENCE to @ARGV, command-line arguments
#    $sum_file:               summary file to print to 
#
# Returns:    Nothing, if it returns, everything is valid.
# 
####################################################################
sub print_banner { 
    my $narg_expected = 6;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, print_banner() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($script_call, $opt_HR, $opt_takes_arg_HR, $opt_order_AR, $argv_R, $sum2print_AR) = @_;

    $script_call =~ s/^\.+\///;
    my $script_name = $script_call;
    $script_name =~ s/.+\///;

    my $enabled_options = "";
    foreach $opt (@{$opt_order_AR}) { 
	if($opt_takes_arg_HR->{$opt}) { if($opt_HR->{$opt} ne "") { $enabled_options .= " " . $opt . " " . $opt_HR->{$opt}; } }
	else                  	      { if($opt_HR->{$opt})       { $enabled_options .= " " . $opt; } }
    }

    print_string_to_file($sum_file, 1, sprintf("\# $script_name :: merge SSU rRNA alignments\n"));
    print_string_to_file($sum_file, 1, sprintf("\# SSU-ALIGN 0.1 (October 2009)\n"));
    print_string_to_file($sum_file, 1, sprintf("\# Copyright (C) 2009 HHMI Janelia Farm Research Campus\n"));
    print_string_to_file($sum_file, 1, sprintf("\# Freely distributed under the GNU General Public License (GPLv3)\n"));
    print_string_to_file($sum_file, 1, sprintf("\# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n"));
    print_string_to_file($sum_file, 1, sprintf("%-10s %s ", "# command:", $script_call . $enabled_options));
    for($i = 0; $i < scalar(@{$argv_R}) - 1; $i++) { 
	print_string_to_file($sum_file, 1, sprintf("$argv_R->[$i] "));
    }
    print_string_to_file($sum_file, 1, sprintf("$argv_R->[$i]\n"));
    print_string_to_file($sum_file, 1, sprintf("%-10s ", "# date:"));
    print_string_to_file($sum_file, 1, sprintf(scalar localtime()));
    print_string_to_file($sum_file, 1, sprintf("\n"));

    return;
}


#####################################################################
# Subroutine: validate_and_setup()
# Incept:     EPN, Tue Oct 27 14:26:48 2009
# 
# Purpose:    Validation and setup:
#             - validate that the required executable programs exist
#             - determine which directories have alignments we will
#               merge together, and that they look as if they were
#               created with a ssu-align --prep-p or --prep-n call.
#             - verify that all ssu-align runs are done
#
# Arguments: 
# $opt_HR:                 reference to hash of command line options
# $dir:                    main directory created by ssu-align --prep-* that 
#                          includes subdirectories with alignments
# $subdir_AR:              reference to the array of subdirectories created by ssu-align, filled here
# $score_to_merge_AR:      reference to array of ssu-align .scores files to merge (concatenate)
# $sum_to_merge_AR:        reference to array of ssu-align .sum files to merge (concatenate)
# $tab_to_merge_AR:        reference to array of ssu-align .tab files to merge (concatenate)
# $cmalign_to_merge_AAR:   reference to 2D array of ssu-align .cmalign output files to merge,
#                          first dimension is the corresponding CM's index in the cm file
# $hits_fa_to_merge_AAR:   reference to 2D array of ssu-align .hits.fa output file to merges,
#                          first dimension is the corresponding CM's index in the cm file
# $hits_list_to_merge_AAR: reference to 2D array of ssu-align .hits.list output files to merge,
#                          first dimension is the corresponding CM's index in the cm file
# $stk_to_merge_AAR:       reference to 2D array of ssu-align .stk alignment files to merge
#                          first dimension is the corresponding CM's index in the cm file
# $cm_names_AR:            reference to a hash of arrays of alignments to merge, hash key is CM name, 
# $cmalign_R:              RETURN; cmalign executable command
# $cm_file_R:              RETURN; the path to the CM file, either default CM file or <s> from -m <s>
# 
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If a required program does not exist, a directory
#             that we think should be there does not exist, or
#             an ssu-align job appears to not have finished, we
#             print a message to STDERR and exit with non-zero status.
#
####################################################################
sub validate_and_setup { 
    my $narg_expected = 13;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, validate_and_setup() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($opt_HR, $dir, $subdir_AR, $score_to_merge_AR, $sum_to_merge_AR, $tab_to_merge_AR, $cmalign_to_merge_AAR, $hits_fa_to_merge_AAR, $hits_list_to_merge_AAR, $stk_to_merge_AAR, $cm_names_AR, $cmalign_R, $cm_file_R) = @_;

    #Make sure $dir exists
    if(!(-d $dir)) { printf STDERR ("\nERROR, directory $dir does not exist.\n"); exit(1); }

    #Make sure the SSUALIGNDIR environmental variable is set.
    my $ssualigndir = $ENV{'SSUALIGNDIR'};
    if(! exists($ENV{'SSUALIGNDIR'})) { 
	printf STDERR ("ERROR, the environment variable SSUALIGNDIR is not set, please set it to the directory where you installed SSU-ALIGN.\n"); 
	exit(1); 
    }

    #Make sure the CM file exists
    my $cm_file = "";
    if($opt_HR->{"-m"} ne "") { 
	$cm_file = $opt_HR->{"-m"}; 
	if(!(-e $cm_file))   { printf STDERR ("ERROR, CM file $cm_file, specified with -M does not exist.\n"); exit(1); }
    }
    else { 
	$cm_file = $ssualigndir . "/ssu-align-0p1.cm";
	if(!(-e $cm_file))   { printf STDERR ("ERROR, the default CM file $cm_file does not exist.\n"); exit(1); }
    }

    # determine CM names
    my %cm_name_idx_H = ();
    my ($cm_name, $line);
    my $ncm = 0;
    if(open(CM, $cm_file) == 0) { printf STDERR ("ERROR, could not open $cm_file for reading.\n"); exit(1); }
    while($line = <CM>) {
	# the lines we're interested in look like this:
	#NAME     archaea
	if($line =~ /^NAME\s+(\S+)/) { 
	    $cm_name = $1;
	    push(@{$cm_names_AR}, $cm_name);
	    if(exists($cm_name_idx_H{$cm_name})) { printf STDERR ("ERROR, two CMs in CM file $cm_file have the name $cm_name. Each CM must have a unique name.\n"); exit(1); }
	    # initialize arrays for this cm:
	    @{$cmalign_to_merge_AAR->[$ncm]} = ();
	    @{$hits_fa_to_merge_AAR->[$ncm]} = ();
	    @{$hits_list_to_merge_AAR->[$ncm]} = ();
	    $cm_name_idx_H{$cm_name} = $ncm++;

	    if($cm_name eq $df_none_name) { printf STDERR ("ERROR, you can't use a CM with the name $df_none_name, that's reserved for indicating which sequences are not the best-match to any models.\n"); exit(1); }
	}
    }
    close(CM);

    # check that cmalign is in the PATH
    my ($tmp, $command);
    my $cmalign    = "ssu-cmalign";
    run_executable("$cmalign -h > /dev/null", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $cmalign is not in your PATH environment\nvariable. See the User's Guide Installation section.");;

    # determine which subdirectories in $dir were created by ssu-align
    my %subdir_H = ();
    my $max_num = 0;
    my ($subdir, $num, $file, $cm, $maybe_dir);
    foreach $maybe_dir (glob("$dir/*")) { 
	if(-d $maybe_dir) { # $maybe_dir is a dir
	    if($subdir =~ /^$dir\.(\d+)$/) { 
		$num = $1;
		if($num > 0) { #don't bother with '0' or negative numbers, they weren't created by ssu-align 
		    if($num > $max_num) { $max_num = $num; }
		    $subdir_H{$subdir} = 1;
		}
	    }
	}		
    }

    # verify we have a contiguous set of ssu-align created subdirectories, each
    # of which contains a finished sum file that indicates ssu-align is done running there.
    my @cpu_A = ();
    my ($sum_file);
    if($max_num == 0) { printf STDERR ("\nERROR, couldn't find any subdirectories created by ssu-align in $dir.\nDid you run the shell script created by your initial ssu-align --prep-* call?\n"); exit(1); }
    # Make sure we have all directories from <dir>.1 to <dir>.$max_num, and they all
    # contain ssu-align sum files in them that are finished running.
    for($i = 1; $i <= $max_num; $i++) { 
	$subdir = "$dir." . $i;
	if(! (exists $subdir_H{($subdir)})) { 
	    printf STDERR ("\nERROR, ssu-align created subdirectory " . $dir . "." . $i . " does not exist in $dir (but " . $dir . "." . $max_num . " does).\n"); exit(1); 
	}
	$sum_file = $dir . "/" . $subdir . "/" . $subdir . ".ssu-align.sum";
	if(! (-e $sum_file)) { 
	    printf STDERR ("\nERROR, ssu-align created subdirectory " . $dir . "/$subdir does not have a ssu-align summary (.sum) file in it.\nThis suggests the ssu-align job for that directory has not completed executing yet.\nPlease execute it, or if it is currently executing, wait until it is finished.\nThen run ssu-merge again.\n"); exit(1);  
	}
	$command = "grep \"^\# CPU time \(\" $sum_file 2>&1";
	$tmp = `$command`;
	if(($? >> 8) != 0) { printf STDERR ("\nERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status %d\nand output:\n$tmp\n", ($? >> 8)); exit($? >> 8); }
	@cpu_A = split(/\n/, $tmp); 
	if(scalar(@cpu_A) != 3) { 
	    printf STDERR ("\nERROR, ssu-align created subdirectory " . $dir . "/$subdir has an incomplete ssu-align summary (.sum) file in it.\nThis suggests the ssu-align job for that directory did not successfully finish running yet.\nPlease rerun it or wait until it is finished.\nThen run ssu-merge again.\n"); exit(1);  
	}
	push(@{$subdir_AR}, $subdir);
    }

    # make a list of alignments to merge, by checking each subdirectory for each possible alignment (one per CM)
    foreach $subdir (@{$subdir_AR}) { 
	# each directory should have:
	# $subdir.scores
	# $subdir.ssu-align.sum
	# $subdir.tab
	#
	# and potentially for each CM $cm:
	# $subdir.$cm.cmalign
	# $subdir.$cm.hits.fa
	# $subdir.$cm.hits.list
	# $subdir.$cm.stk
	# 

	foreach $file (glob("$dir/$subdir/")) { 
	    if($file =~ /$subdir\.scores/) { 
		push(@{$score_to_merge_AR}, ($dir . "/" . $subdir . "/" . $file));
	    }
	    if($file =~ /$subdir\.ssu-align.sum/) { 
		push(@{$sum_to_merge_AR}, ($dir . "/" . $subdir . "/" . $file));
	    }
	    if($file =~ /$subdir\.tab/) { 
		push(@{$tab_to_merge_AR}, ($dir . "/" . $subdir . "/" . $file));
	    }
	    if($file =~ /$subdir\.(\S+)\.cmalign/) { 
		$cm = $1;
		if(! (exists($cm_name_idx_H{$cm}))) { printf STDERR ("\nERROR, found ssu-align output file $file in subdirectory $subdir/ created for a CM named $cm\nNo such CM exists in $cm_file.\nDid you use -m <s> when you ran ssu-align? If so pass -m <s> to ssu-merge as well.\n"); exit(1); }
		push(@{$cmalign_to_merge_AAR->[$cm_name_idx_H{$cm}]}, ($dir . "/" . $subdir . "/" . $file));
	    }
	    if($file =~ /$subdir\.(\S+)\.hits.fa/) { 
		$cm = $1;
		if(! (exists($cm_name_idx_H{$cm}))) { printf STDERR ("\nERROR, found ssu-align output file $file in subdirectory $subdir/ created for a CM named $cm\nNo such CM exists in $cm_file.\nDid you use -m <s> when you ran ssu-align? If so pass -m <s> to ssu-merge as well.\n"); exit(1); }
		push(@{$hits_fa_to_merge_AAR->[$cm_name_idx_H{$cm}]}, ($dir . "/" . $subdir . "/" . $file));
	    }
	    if($file =~ /$subdir\.(\S+)\.hits.list/) { 
		$cm = $1;
		if(! (exists($cm_name_idx_H{$cm}))) { printf STDERR ("\nERROR, found ssu-align output file $file in subdirectory $subdir/ created for a CM named $cm\nNo such CM exists in $cm_file.\nDid you use -m <s> when you ran ssu-align? If so pass -m <s> to ssu-merge as well.\n"); exit(1); }
		push(@{$hits_list_to_merge_AAR->[$cm_name_idx_H{$cm}]}, ($dir . "/" . $subdir . "/" . $file));
	    }
	    if($file =~ /$subdir\.(\S+)\.stk/) { 
		$cm = $1;
		if(! (exists($cm_name_idx_H{$cm}))) { printf STDERR ("\nERROR, found ssu-align output file $file in subdirectory $subdir/ created for a CM named $cm\nNo such CM exists in $cm_file.\nDid you use -m <s> when you ran ssu-align? If so pass -m <s> to ssu-merge as well.\n"); exit(1); }
		push(@{$stk_to_merge_AAR->[$cm_name_idx_H{$cm}]}, ($dir . "/" . $subdir . "/" . $file));
	    }
	}
    }	
    $$cmalign_R     = $cmalign;
    $$cm_file_R     = $cm_file;

    return;
}


#####################################################################
# Subroutine: merge_alignments_for_a_cm()
# Incept:     EPN, Tue Oct 27 18:05:43 2009
# 
# Purpose:    Given a list of alignments created by the same CM to merge, 
#             merge them with a single call to cmalign --list-merge.
#
# Arguments: 
# $opt_HR:           reference to hash of command line options
# $stk_name:         name for merged alignment file
# $dir:              main directory created by ssu-align --prep-* that 
#                    includes subdirectories with alignments
# $cm_file:          the CM file
# $cm_idx:           index of the relevant CM in the CM file
# $cm_name:          name of the relevant CM in the CM file
# $stk_to_merge_AR:  reference to the array of alignments to merge
# 
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If something goes wrong, this subroutine prints an
#             error and exits.
#
####################################################################
sub merge_alignments_for_a_cm { 
    my $narg_expected = 7;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, merge_alignments_for_a_cm() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($opt_HR, $stk_name, $dir, $cm_file, $cm_idx, $cm_name, $stk_to_merge_AR) = @_;

    my ($output, $stk, $command, $output);

    # create a temporary file with the stk list:
    my $list_file = $dir . "/" . $cm_name . ".merge.list";
    if(! (open(LIST, ">" . $list_file))) { printf STDERR ("ERROR, couldn't open list file $list_file for merging alignments with CM: $cm_name\n"); }
    foreach $stk (@{$stk_to_merge_AR})   { printf LIST ("$stk\n"); }
    close(LIST);

    if(-e $stk_name) { 
	if(! ($opt_HR->{"-F"})) { 
	    printf STDERR ("ERROR, alignment file $stk_name already exists. Delete it or use -F to overwrite it.\n"); exit(1); 
	}
	else {
	    unlink $stk_name || die "\nERROR, unable to remove file $stk_name.\n";
	}
    }

    my $extra_opts = "";
    if($opt_HR->{"-1"}) { $extra_opts = " -1"; }

    $command = "$cmalign $extra_opts --cm-idx $cm_idx --list-merge -o $stk_name $cm_file $list_file 2>&1";
    run_executable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");

    return;
}


#####################################################################
# Subroutine: concatenate_a_list_of_files()
# Incept:     EPN, Wed Oct 28 17:12:05 2009
# 
# Purpose:    Given a list of files to concatenate, do it.
#
# Arguments: 
# $opt_HR:              reference to hash of command line options
# $concat_file:         the name for the file we want to concatenate
# $files_to_concat_AR:  reference to the array of files to concatenate
# 
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If something goes wrong, this subroutine prints an
#             error and exits.
#
####################################################################
sub concatenate_a_list_of_files { 
    my $narg_expected = 3;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, concatenate_a_list_of_files() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($opt_HR, $concat_file, $files_to_concat_AR) = @_;

    if(scalar(@{$files_to_concat_AR}) == 0) { return; } #if array is empty, just leave

    my ($file, $command, $output, $i);

    # ensure all the files exist
    foreach $file (@{$files_to_concat_AR}) { 
	if(! (-e $file)) { printf STDERR ("ERROR, file $file does not exist, (it was to be cat'ed to $concat_file.\n"); exit(1); }
    }

    # check if concat file already exists
    if(-e $concat_file) { 
	if(! ($opt_HR->{"-F"})) { 
	    printf STDERR ("ERROR, file $concat_file already exists. Delete it or use -F to overwrite it.\n"); exit(1); 
	}
	else {
	    unlink $concat_file || die "\nERROR, unable to remove $concat_file.\n";
	}
    }

    # create concat file
    $command = "cat $files_to_concat_AR->[0] > $concat_file";
    run_executable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");

    # add to concat file
    for($i = 1; $i < scalar(@{$files_to_concat_AR}); $i++) { 
	run_executable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");
    }

    return;
}


#####################################################################
# Subroutine: determine_num_seqs()
# Incept:     EPN, Mon Nov  3 15:18:52 2008
# 
# Purpose:    Count the number of sequences in the fasta file 
#             <$target_file>.
#
# Arguments: 
# $target_file: the target sequence file 
#
# 
# Returns:    <$nseq_target_file>: number of sequences in 
#             <$target_file>.
# 
####################################################################
sub determine_num_seqs { 
    my $narg_expected = 1;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, determine_num_seqs() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($file) = $_[0];

    if(!(-e $file)) { printf STDERR ("ERROR, determine_num_seqs(), file $file does not exist.\n"); exit(1); }
    my $command = "grep \"\^\>\" $file | nl | tail -1 2>&1";
    my $output = `$command`;
    if(($? >> 8) != 0) { printf STDERR ("\nERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status %d\nand output:\n$output\n", ($? >> 8)); exit($? >> 8); }
    chomp $output;
    $output =~ s/^\s+//;
    $output =~ s/\s+.*$//;
    return $output;
}


#################################################################
# Subroutine : max_length_scalar_in_arr()
# Incept:      EPN, Tue Nov  4 15:19:44 2008
# 
# Purpose:     Return the maximum length of a scalar in an array
#
# Arguments: 
# $arr_R: reference to the array
# 
################################################################# 
sub max_length_scalar_in_array {
    my $narg_expected = 1;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, max_length_scalar_in_arr() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($arr_R) = $_[0];

    my ($max, $i);
    $max = length($arr_R->[0]);
    for($i = 1; $i < scalar(@{$arr_R}); $i++) { 
	if(length($arr_R->[$i]) > $max) { $max = length($arr_R->[$i]); }
    }
    return $max;
}


#####################################################################
# Subroutine: print_timing()
# Incept:     EPN, Tue Jun 16 08:52:08 2009
# 
# Purpose:    Print a timing in hhhh:mm:ss format to 1 second precision.
# 
# Arguments:
# $prefix:       string to print before the hhhh:mm:ss time info.
# $inseconds:    number of seconds
# $sum_file:     file to print output file notices to
#
# Returns:    Nothing, if it returns, everything is valid.
# 
####################################################################
sub print_timing { 
    my $narg_expected = 3;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, print_timing() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($prefix, $inseconds, $sum_file) = @_;
    my ($i, $hours, $minutes, $seconds, $thours, $tminutes, $tseconds);

    $hours = int($inseconds / 3600);
    $inseconds -= ($hours * 3600);
    $minutes = int($inseconds / 60);
    $inseconds -= ($minutes * 60);
    $seconds = $inseconds;
    $thours   = $hours;
    $tminutes = $minutes;
    $tseconds = $seconds;

    if($hours < 10)   { $thours   = "0" . $thours; }
    if($minutes< 10)  { $tminutes = "0" . $tminutes; }
    if($seconds< 10)  { $tseconds = "0" . $tseconds; }

    print_string_to_file($sum_file, 1, sprintf("%s %2s:%2s:%2s\n", $prefix, $thours, $tminutes, $tseconds));
}


###########################################################
# Subroutine: print_string_to_file()
# Incept: EPN, Thu Oct 29 10:47:25 2009
#
# Purpose: Given a string and a file name, append the 
#          string to the file, and potentially to stdout
#          as well. If $filename is the empty string,
#          don't print to a file. 
#
# Returns: Nothing. If the file can't be written to 
#          an error message is printed and the program
#          exits.
#
###########################################################
sub print_string_to_file {
    my $narg_expected = 3;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, print_string_to_file() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($filename, $print_to_stdout, $string) = @_;

    if($filename ne "") { 
	open(OUT, ">>" . $filename) || die "ERROR, couldn't open $filename for appending.\n";
	printf OUT $string;
	close(OUT);
    }

    if($print_to_stdout) { 
	printf($string);
    }
    return;
}


###########################################################
# Subroutine: run_executable
# Incept: EPN, Fri Oct 30 06:05:37 2009
#
# Purpose: Run a command with backticks, capturing its standard
#          output and standard error. Print command execution
#          and its output to $log_file. If command returns 
#          non-zero status, print error message $errmsg to 
#          STDERR, and exit if $die_if_fails is TRUE. 
#
# Arguments:
#   $command:                   command to execute
#   $die_if_fails:              '1' to die if command returns non-zero status
#   $print_output_upon_failure: '1' to print command output to STDERR if it fails
#   $log_file:                  file to print command and output to
#   $command_worked_ref:        set to '1' if command works (returns 0), else set to '0'         
#   $errmsg:                    message to print if command returns non-0 exit status
# 
# Returns: Output (stdout and stderr) of the command.
#
###########################################################
sub run_executable {
    my $narg_expected = 6;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, run_executable() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($command, $die_if_fails, $print_output_upon_failure, $log_file, $command_worked_ref, $errmsg) = @_;

    #contract check
    if(($die_if_fails) && ($errmsg eq "")) { die "ERROR, misuse of run_executable: errmsg is the empty string and die_if_fails is TRUE."; }
    my $output = "";
    my $command_worked = 1;

    if ($command !~ m/2\>\&1$/) { $command .= " 2>&1"; }

    print_string_to_file($log_file, 0, ("Executing: \(" . $command . "\)\n"));
    $output = `$command`;

    if(($? != 0) && ($errmsg ne "")) { 
	print_string_to_file($log_file, 0, ("Output:\n\(" . $output . "\)\n\n"));
	printf STDERR ("\n$errmsg\n");
	if($print_output_upon_failure) { printf STDERR ("Command output: $output\n"); }
	print_string_to_file($log_file, 0, ("\n$errmsg\n"));
	if($die_if_fails) { exit(1); }
	$command_worked = 0;
    }
    else { 
	print_string_to_file($log_file, 0, ("Output:\n\(" . $output . "\)\n\n"));
    }

    $$command_worked_ref = $command_worked;
    return $output;
}
