#!/usr/bin/perl
#
# ssu-merge
# Eric Nawrocki
# EPN, Tue Oct 27 14:07:30 2009
#
# Usage: ssu-merge [options] <directory created by ssu-align --prep-n or --prep-p call>
#             
# Synopsis:
# Merges alignments created by ssu-align. When ssu-align is run with the 
# --prep-n or --prep-p 'preparation mode' options it generates a script that
# performs multiple ssu-align jobs. When these are finished running, 
# ssu-merge is used to merge the alignments from the multiple jobs 
# together into a single alignment for each CM used by ssu-align.
#
# Step 1. Verify that all ssu-align jobs are complete.
# Step 2. Merge alignments from multiple ssu-align jobs. 
# Step 3. Concatenate other relevant files from multiple ssu-align jobs.
#
# See definition of $options_usage for options, below.
#
use Getopt::Long;
use strict;
use warnings;

#Make sure the SSUALIGNDIR environmental variable is set and the directory exists
my $ssualigndir = $ENV{'SSUALIGNDIR'};
if(! exists($ENV{'SSUALIGNDIR'})) { 
    printf STDERR ("ERROR, the environment variable SSUALIGNDIR is not set, please set it to the directory where you installed SSU-ALIGN.\n"); 
    exit(1); 
}
if(! (-d $ssualigndir)) { 
    printf STDERR ("ERROR, the ssu-align directory specified by your environment variable SSUALIGNDIR does not exist, see the User's Guide Installation section.\n"); 
    exit(1); 
}    
#Make sure the SSUALIGNDIR directory includes ssu.pm
my $subs_file = $ssualigndir . "/ssu.pm";
if(! (-e $subs_file)) { 
    printf STDERR ("ERROR, the required perl module ssu.pm is not in the directory specified by your SSUALIGNDIR environment variable.\n"); 
    exit(1); 
}
require $subs_file;

# get global variables
our %globals_H = ();
GetGlobals(\%globals_H, $ssualigndir);

# Start timing, this is done different depending on if Time::HiRes is installed or not
my $time_hires_installed = UseModuleIfItExists("Time::HiRes qw(gettimeofday)");
my $total_seconds = -1 * SecondsSinceEpoch($time_hires_installed);

my $script_desc    = "merge SSU rRNA alignments";
my $date           = scalar localtime();
my $usage          = "Usage: ssu-merge [-options] <dir created by ssu-align --prep-n or --prep-p call>";
my $options_usage  = "where general options are:\n";
#                           1         2         3         4         5         6         7         8
#                  12345678901234567890123456789012345678901234567890123456789012345678901234567890
$options_usage .= "  -h          : show brief help on version and usage\n";
$options_usage .= "  -1          : output alignments in non-interleaved, 1 line/seq format\n";
$options_usage .= "  -m <s>      : use CM file <f> instead of the default CM file\n";
$options_usage .= "  -F          : force; allow file clobbering\n";


###################
# Process options #
###################
my %opt_H = ();              # key: option (example "-h"); value: option argument (example ("0" or "1") if option takes no arg, actual argument if option takes arg)
my %opt_takes_arg_H  = ();   # key: option; value: "1" if option takes argument, "0" if not
my @opt_order_A  = ();       # order of options for printing in banner
my $opt;

$opt_takes_arg_H{"-h"}          = 0;  push(@opt_order_A, "-h");
$opt_takes_arg_H{"-1"}          = 0;  push(@opt_order_A, "-1");
$opt_takes_arg_H{"-m"}          = 1;  push(@opt_order_A, "-m");
$opt_takes_arg_H{"-F"}          = 0;  push(@opt_order_A, "-F");

#set default options
foreach $opt (keys %opt_takes_arg_H) { 
    if($opt_takes_arg_H{$opt}) { $opt_H{$opt} = ""; }
    else                       { $opt_H{$opt} = 0; }
}

Getopt::Long::Configure ("bundling");
my $opt_return = GetOptions
    ('h'         => \$opt_H{"-h"}, 
     '1'         => \$opt_H{"-1"},
     'm=s'       => \$opt_H{"-m"},
     'F'         => \$opt_H{"-F"});

if($opt_return != 1) { print STDERR "\nERROR, GetOptions() did not return 1.\n"; exit(1); }

if ($opt_H{"-h"}) { 
    PrintBanner($0, $script_desc, $date, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, "");
    print $usage . "\n"; 
    print $options_usage; 
    exit(0); 
} 


################
# Print banner #
################
if(scalar(@ARGV) != 1) {   
    print "Incorrect number of command line arguments.\n";
    print $usage;
    print "\nTo see more help on available options, do ssu-draw -h\n\n";
    exit(1);
}
my ($dir) = @ARGV;
$dir =~ s/\/$//; # remove trailing slash if it exists

my $sum_file       = $dir . "/" . $dir . ".ssu-merge.sum";
my $sum_file2print = $dir . ".ssu-merge.sum";
my $log_file       = $dir . "/" . $dir . ".ssu-merge.log";
my $log_file2print = $dir . ".ssu-merge.log";

# open the summary and log files
open(OUT, ">" . $sum_file) || die "ERROR, couldn't open file $sum_file for writing";
close(OUT);
open(OUT, ">" . $log_file) || die "ERROR, couldn't open file $log_file for writing";
close(OUT);

PrintBanner($0, $script_desc, $date, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, 1, $sum_file);
PrintBanner($0, $script_desc, $date, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, 0, $log_file);
PrintGlobalsToFile(\%globals_H, $log_file);


##################################
# Validate that everything is go #
##################################
my ($cmalign, $alistat, $cm_file, $no_search_enabled, $no_align_enabled, $ssu_align_prep_sum_read, $aln_one_cm);
my @subdir_A = ();
my @score_to_merge_A = ();
my @sum_to_merge_A = ();
my @log_to_merge_A = ();
my @tab_to_merge_A = ();
my @nomatch_to_merge_A = ();
my @cmalign_to_merge_AA = ();
my @hits_fa_to_merge_AA = ();
my @hits_list_to_merge_AA = ();
my @stk_to_merge_AA = ();
my @cm_names_A = ();

validate_and_setup_ssu_merge($ssualigndir, \%opt_H, $dir, \@subdir_A, \@score_to_merge_A, \@sum_to_merge_A, \@log_to_merge_A, \@tab_to_merge_A, \@nomatch_to_merge_A, 
			     \@cmalign_to_merge_AA, \@hits_fa_to_merge_AA, \@hits_list_to_merge_AA, \@stk_to_merge_AA, \@cm_names_A, 
			     \$cmalign, \$alistat, \$cm_file, \$no_search_enabled, \$no_align_enabled, \$aln_one_cm, $sum_file);

####################################
# Merge files including alignments #
####################################

my ($i, $j, $cm_idx, $nhitsfa, $nhitslist, $ncmalign, $nstk);
my ($scores_file, $nomatch_file, $ssu_align_sum_file, $ssu_align_log_file, $tab_file, $cmalign_file, $hitsfa_file, $hitslist_file, $merged_stk_file);
my ($scores_file2print, $nomatch_file2print, $ssu_align_sum_file2print, $ssu_align_log_file2print, $tab_file2print, $cmalign_file2print, $hitsfa_file2print, $hitslist_file2print, $merged_stk_file2print);
my ($max_file_name_width, $max_cm_name_width, $file_dashes, $cm_dashes, $nseq_merged);

# merge one-per-run files:
# *.sum, *.log in all cases
# *.tab, *.scores and possibly *.nomatch unless --no-search enabled
$max_file_name_width  = MaxLengthScalarInArray(\@cm_names_A) + 1 + length($dir) + 1;
if(scalar(@sum_to_merge_A)   == 0)   { PrintErrorAndExit("ERROR, no *.sum files found.", $sum_file, 1); }
if(scalar(@log_to_merge_A)   == 0)   { PrintErrorAndExit("ERROR, no *.log files found.", $sum_file, 1); }
if(scalar(@nomatch_to_merge_A) == 0) { ; } # this is okay, .nomatch files are only generated if at least one sequence did not match a CM 
if(! $no_search_enabled) { # we determine --no-search was enabled in validate_and_setup_ssu_merge, by parsing the ssu-align prep summary file
    if(scalar(@tab_to_merge_A)   == 0) { 
	PrintErrorAndExit("ERROR, unexpectedly unable to locate any *.tab files even though \"--no-search\" was not enabled in the ssu_align runs.", $sum_file, 1); 
    }
    if(scalar(@score_to_merge_A) == 0) { 
	PrintErrorAndExit("ERROR, unexpectedly unable to locate any *.score files even though \"--no-search\" was not enabled in the ssu_align runs.", $sum_file, 1); 
    }
    $max_file_name_width += length("hits.list");
}
else { # --no-search was enabled
    $max_file_name_width += length(".cmalign");
}

if($max_file_name_width < (length($dir) + 1 + length("ssu-align.log"))) { 
    $max_file_name_width = length($dir) + 1 + length("ssu-align.log");
}
if($max_file_name_width < (length("merged file name"))) { 
    $max_file_name_width = length("merged file name"); 
}
$file_dashes = ""; for($i = 0; $i < $max_file_name_width; $i++) { $file_dashes .= "-"; } 

$max_cm_name_width = MaxLengthScalarInArray(\@cm_names_A);
if($max_cm_name_width < length("CM name")) { $max_cm_name_width = length("CM name"); }
$cm_dashes = ""; for($i = 0; $i < $max_cm_name_width; $i++) { $cm_dashes .= "-"; } 

PrintStringToFile($sum_file, 1, sprintf("#\n# Merging files from %d ssu-align runs...\n", scalar(@sum_to_merge_A))); 
PrintStringToFile($sum_file, 1, sprintf("#\n"));
PrintStringToFile($sum_file, 1, sprintf("# %-*s  %-*s  %7s  %9s\n", $max_file_name_width, "",                 $max_cm_name_width, "",         "\# files", "\# seqs"));
PrintStringToFile($sum_file, 1, sprintf("# %-*s  %-*s  %7s  %9s\n", $max_file_name_width, "merged file name", $max_cm_name_width, "CM name",  "merged", "merged"));
PrintStringToFile($sum_file, 1, sprintf("# %-*s  %-*s  %7s  %9s\n", $max_file_name_width, $file_dashes,       $max_cm_name_width, $cm_dashes, "-------", "---------"));

$scores_file              = $dir . "/" . $dir . ".scores";
$nomatch_file             = $dir . "/" . $dir . ".nomatch";
$ssu_align_sum_file       = $dir . "/" . $dir . ".ssu-align.sum";
$ssu_align_log_file       = $dir . "/" . $dir . ".ssu-align.log";
$tab_file                 = $dir . "/" . $dir . ".tab";
$scores_file2print        = $dir . ".scores";
$nomatch_file2print       = $dir . ".nomatch";
$ssu_align_sum_file2print = $dir . ".ssu-align.sum";
$ssu_align_log_file2print = $dir . ".ssu-align.log";
$tab_file2print           = $dir . ".tab";

if(scalar(@tab_to_merge_A) > 0) { 
    concatenate_a_list_of_files(\%opt_H, $tab_file, \@tab_to_merge_A);
    PrintStringToFile($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9s\n", $max_file_name_width, $tab_file2print, $max_cm_name_width, "-", scalar(@tab_to_merge_A), "-"));
}
if(scalar(@score_to_merge_A) > 0) { 
    concatenate_a_list_of_files(\%opt_H, $scores_file, \@score_to_merge_A);
    PrintStringToFile($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9s\n", $max_file_name_width, $scores_file2print, $max_cm_name_width, "-", scalar(@score_to_merge_A), "-"));
}
if(scalar(@nomatch_to_merge_A) > 0) { 
    concatenate_a_list_of_files(\%opt_H, $nomatch_file, \@nomatch_to_merge_A);
    PrintStringToFile($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9s\n", $max_file_name_width, $nomatch_file2print, $max_cm_name_width, "-", scalar(@score_to_merge_A), "-"));
}

my ($summed_search_seconds, $summed_align_seconds, $summed_total_seconds);
my ($summed_target_nseq, $summed_target_nres, $summed_nseq_all_cms, $summed_nres_total_all_cms, $summed_nres_aligned_all_cms);
my %summed_nseq_cm_H = ();
my %summed_nres_total_cm_H = ();
my %summed_nres_aligned_cm_H = ();
concatenate_sum_files_and_merge_statistics(\%opt_H, $ssu_align_sum_file, \@sum_to_merge_A, \@cm_names_A, \$summed_search_seconds, \$summed_align_seconds, \$summed_total_seconds, 
					   \$summed_target_nseq, \$summed_target_nres, \$summed_nseq_all_cms, \$summed_nres_total_all_cms, \$summed_nres_aligned_all_cms,
					   \%summed_nseq_cm_H, \%summed_nres_total_cm_H, \%summed_nres_aligned_cm_H, $sum_file);

PrintStringToFile($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9s\n", $max_file_name_width, $ssu_align_sum_file2print, $max_cm_name_width, "-", scalar(@sum_to_merge_A), "-"));

concatenate_a_list_of_files(\%opt_H, $ssu_align_log_file, \@log_to_merge_A);
PrintStringToFile($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9s\n", $max_file_name_width, $ssu_align_log_file2print, $max_cm_name_width, "-", scalar(@log_to_merge_A), "-"));

PrintStringToFile($sum_file, 1, sprintf("#\n"));

# merge per-CM files
my ($nseq_cur, $cur_cm, $nali);
my @nseq_cur_A = ();
for($i = 0; $i < scalar(@cm_names_A); $i++) { 
    $nhitsfa   = scalar(@{$hits_fa_to_merge_AA[$i]});
    $nhitslist = scalar(@{$hits_list_to_merge_AA[$i]});
    $ncmalign  = scalar(@{$cmalign_to_merge_AA[$i]});
    $nstk      = scalar(@{$stk_to_merge_AA[$i]});
    $cm_idx    = $i+1;
    $cur_cm    = $cm_names_A[$i];

    $cmalign_file          = $dir . "/" . $dir . "." . $cm_names_A[$i] . ".cmalign";
    $hitsfa_file           = $dir . "/" . $dir . "." . $cm_names_A[$i] . ".hits.fa";
    $hitslist_file         = $dir . "/" . $dir . "." . $cm_names_A[$i] . ".hits.list";
    $merged_stk_file       = $dir . "/" . $dir . "." . $cm_names_A[$i] . ".stk";
    $cmalign_file2print    = $dir . "." . $cm_names_A[$i] . ".cmalign";
    $hitsfa_file2print     = $dir . "." . $cm_names_A[$i] . ".hits.fa";
    $hitslist_file2print   = $dir . "." . $cm_names_A[$i] . ".hits.list";
    $merged_stk_file2print = $dir . "." . $cm_names_A[$i] . ".stk";

    # check we have all the files we expect, and determine number of sequences we'll merge for this CM
    if((! $no_search_enabled) && (! $no_align_enabled)) { # neither --no-search nor --no-align enabled
	if($nhitsfa != $nhitslist)  { PrintErrorAndExit(sprintf("ERROR, neither --no-search nor --no-align used by ssu-align, yet for cm $cm_names_A[$i], %d *.hits.fa files but %d *.hits.list files.", $nhitsfa, $nhitslist), $sum_file, 1); }
	if(($aln_one_cm eq "") || ($aln_one_cm eq $cur_cm)) { 
	    if($nhitsfa != $ncmalign)   { PrintErrorAndExit(sprintf("ERROR, --no-search nor --no-align used by ssu-align, yet for cm $cm_names_A[$i], %d *.hits.fa files but %d *.cmalign files.", $nhitsfa, $ncmalign), $sum_file, 1); }
	    if($nhitsfa != $nstk)       { PrintErrorAndExit(sprintf("ERROR, --no-search nor --no-align used by ssu-align, yet for cm $cm_names_A[$i], %d *.hits.fa files but %d *.stk files.", $nhitsfa, $nstk), $sum_file, 1); }
	}
    }
    elsif($no_search_enabled) { # --no-search enabled, we expect no hits.fa nor hits.list files
	if($nstk != $ncmalign) { PrintErrorAndExit(sprintf("ERROR, --no-search used by ssu-align runs, but for cm $cm_names_A[$i], %d *.cmalign files and %d *.stk files. There should be the same number", $nstk, $ncmalign), $sum_file, 1); }
    }
    elsif($no_align_enabled) { # --no-align enabled, only *hits.fa and *hits.list files may exist
	if($nhitsfa != $nhitslist)  { PrintErrorAndExit(sprintf("ERROR, --no-align used by ssu-align, yet for cm $cm_names_A[$i], %d *.hits.fa files but %d *.hits.list files.", $nhitsfa, $nhitslist), $sum_file, 1); }
    }	

    if($nhitsfa > 0) { 
	concatenate_a_list_of_files(\%opt_H, $hitsfa_file, \@{$hits_fa_to_merge_AA[$i]}); 
        #determine total number of sequences in all of the fasta files, 
	#we do each individually in case there's an error, we can give a more informative error message
	$nseq_merged = 0;
	for($j = 0; $j < scalar(@{$hits_fa_to_merge_AA[$i]}); $j++) { 
	    $nseq_cur     = DetermineNumSeqsFasta($hits_fa_to_merge_AA[$i][$j]);
	    if($nseq_cur == -1) { PrintErrorAndExit("ERROR, sequence file $hits_fa_to_merge_AA[$i][$j] should be FASTA formatted, but non-whitespace found before first \">\" (not valid FASTA).", $sum_file, 1); }
	    if($nseq_cur == 0)  { PrintErrorAndExit("ERROR, sequence file $hits_fa_to_merge_AA[$i][$j] should be FASTA formatted, but no \">\" found.", $sum_file, 1); }
	    $nseq_merged += $nseq_cur;
	}
	if($nseq_merged != $summed_nseq_cm_H{$cur_cm}) { 
	    PrintErrorAndExit(sprintf("ERROR, merged ssu-align summary stats report %d aligned sequences, but we just merged %d sequences in *hits.fa files.", $summed_nseq_cm_H{$cur_cm}, $nseq_merged), $sum_file, 1); 
	}
	PrintStringToFile($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9d\n", $max_file_name_width, $hitsfa_file2print, $max_cm_name_width, $cm_names_A[$i], $nhitsfa, $nseq_merged));

	# if $nhitsfa != 0, $nhitslist != 0 as well (we checked above)
	concatenate_a_list_of_files(\%opt_H, $hitslist_file, \@{$hits_list_to_merge_AA[$i]});
	PrintStringToFile($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9d\n", $max_file_name_width, $hitslist_file2print, $max_cm_name_width, $cm_names_A[$i], $nhitslist, $nseq_merged));
    }
    if($ncmalign != 0) { # make sure the total num seqs in all the alignments is what we expect based on the ssu-align summary files we merged
	# we made sure $ncmalign == $nstk above (unless --no-align enabled, in which case they're both 0)
	$nseq_merged = 0;
	for($j = 0; $j < scalar(@{$stk_to_merge_AA[$i]}); $j++) { 
	    DetermineNumSeqsStockholm($alistat, $stk_to_merge_AA[$i][$j], $sum_file, $log_file, \@nseq_cur_A, \$nali);
	    if($nali != 1) { PrintErrorAndExit(sprintf("ERROR, stockholm alignment file %s, unexpectedly contains $nali alignments (should be only 1).", $stk_to_merge_AA[$i][$j]), $sum_file, 1); }
	    $nseq_cur = $nseq_cur_A[0];
	    if($nseq_cur == 0) { PrintErrorAndExit(sprintf("ERROR, stockholm alignment file %s contains 0 sequences.", $stk_to_merge_AA[$i][$j]), $sum_file, 1); }
	    $nseq_merged += $nseq_cur;
	}
	if($nseq_merged != $summed_nseq_cm_H{$cur_cm}) { 
	    PrintErrorAndExit(sprintf("ERROR, merged ssu-align summary stats report %d aligned sequences, but %d sequences in all the *stk alignment files.", $summed_nseq_cm_H{$cur_cm}, $nseq_merged), $sum_file, 1); 
	}
	concatenate_a_list_of_files(\%opt_H, $cmalign_file,  \@{$cmalign_to_merge_AA[$i]});
	PrintStringToFile($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9d\n", $max_file_name_width, $cmalign_file2print, $max_cm_name_width, $cm_names_A[$i], $ncmalign, $nseq_merged));

	merge_alignments_for_a_cm(\%opt_H, $merged_stk_file, $dir, $cm_file, $cm_idx, $cm_names_A[$i], \@{$stk_to_merge_AA[$i]}, $sum_file, $log_file);
	PrintStringToFile($sum_file, 1, sprintf("  %-*s  %-*s  %7d  %9d\n", $max_file_name_width, $merged_stk_file2print, $max_cm_name_width, $cm_names_A[$i], $nstk, $nseq_merged));
    }
    PrintStringToFile($sum_file, 1, sprintf("#\n"));
}


############
# Conclude #
############
my $cm_name;
my %cm_used_for_align_H = ();
foreach $cm_name (@cm_names_A) { 
    if(($aln_one_cm eq "") || ($cm_name eq $aln_one_cm)) { 
	$cm_used_for_align_H{$cm_name} = 1;
    }
    else { 
	$cm_used_for_align_H{$cm_name} = 0;
    }
}
PrintSearchAndAlignStatistics($summed_search_seconds, $summed_align_seconds, $summed_target_nseq, $summed_target_nres, $summed_nseq_all_cms, $summed_nres_total_all_cms, $summed_nres_aligned_all_cms,
			      \@cm_names_A, \%cm_used_for_align_H, \%summed_nseq_cm_H, \%summed_nres_total_cm_H, \%summed_nres_aligned_cm_H, 1, $sum_file);
PrintSearchAndAlignStatistics($summed_search_seconds, $summed_align_seconds, $summed_target_nseq, $summed_target_nres, $summed_nseq_all_cms, $summed_nres_total_all_cms, $summed_nres_aligned_all_cms,
			      \@cm_names_A, \%cm_used_for_align_H, \%summed_nseq_cm_H, \%summed_nres_total_cm_H, \%summed_nres_aligned_cm_H, 0, $ssu_align_sum_file);

if($summed_search_seconds ne "NA") { 
    PrintTiming("# Summed ssu-align CPU time (search):    ", $summed_search_seconds, $time_hires_installed, 1, $sum_file); 
    PrintTiming("# Summed ssu-align CPU time (search):    ", $summed_search_seconds, $time_hires_installed, 0, $ssu_align_sum_file); 
}
if($summed_align_seconds ne "NA") { 
    PrintTiming("# Summed ssu-align CPU time (align):     ", $summed_align_seconds, $time_hires_installed, 1, $sum_file); 
    PrintTiming("# Summed ssu-align CPU time (align):     ", $summed_align_seconds, $time_hires_installed, 0, $ssu_align_sum_file); 
}
PrintTiming("# Summed ssu-align CPU time (total):     ", $summed_total_seconds, $time_hires_installed, 1, $sum_file); 
PrintTiming("# Summed ssu-align CPU time (total):     ", $summed_total_seconds, $time_hires_installed, 0, $ssu_align_sum_file); 

$total_seconds += SecondsSinceEpoch($time_hires_installed);
PrintConclusion($sum_file, $log_file, $sum_file2print, $log_file2print, $total_seconds, $time_hires_installed, $dir);

# Success! Exit normally
exit(0); 


###############
# Subroutines #
###############


#####################################################################
# Subroutine: validate_and_setup_ssu_merge()
# Incept:     EPN, Tue Oct 27 14:26:48 2009
# 
# Purpose:    Validation and setup:
#             - validate that the required executable programs exist
#             - determine which directories have alignments we will
#               merge together, and that they look as if they were
#               created with a ssu-align --prep-p or --prep-n call.
#             - verify that all ssu-align runs are done
#
# Arguments: 
# $ssualigndir:               dir defined by SSUALIGNDIR environment variable 
# $opt_HR:                    reference to hash of command line options
# $dir:                       main directory created by ssu-align --prep-* that 
#                             includes subdirectories with alignments
# $subdir_AR:                 reference to the array of subdirectories created by ssu-align, filled here
# $score_to_merge_AR:         reference to array of ssu-align .scores files to merge (concatenate)
# $sum_to_merge_AR:           reference to array of ssu-align .sum files to merge (concatenate)
# $log_to_merge_AR:           reference to array of ssu-align .log files to merge (concatenate)
# $tab_to_merge_AR:           reference to array of ssu-align .tab files to merge (concatenate)
# $nomatch_to_merge_AR:       reference to array of ssu-align .nomatch files to merge (concatenate)
# $cmalign_to_merge_AAR:      reference to 2D array of ssu-align .cmalign output files to merge,
#                             first dimension is the corresponding CM's index in the cm file
# $hits_fa_to_merge_AAR:      reference to 2D array of ssu-align .hits.fa output file to merges,
#                             first dimension is the corresponding CM's index in the cm file
# $hits_list_to_merge_AAR:    reference to 2D array of ssu-align .hits.list output files to merge,
#                             first dimension is the corresponding CM's index in the cm file
# $stk_to_merge_AAR:          reference to 2D array of ssu-align .stk alignment files to merge
#                             first dimension is the corresponding CM's index in the cm file
# $cm_names_AR:               reference to a hash of arrays of alignments to merge, hash key is CM name, 
# $cmalign_R:                 RETURN; cmalign executable command
# $alistat_R:                 RETURN; esl-alistat executable command
# $cm_file_R:                 RETURN; the path to the CM file, either default CM file or <s> from -m <s>
# $no_search_enabled_R:       RETURN; '1' if we examine the ssu-align prep summary file and find that --no-search was used
# $no_align_enabled_R:        RETURN; '1' if we examine the ssu-align prep summary file and find that --no-align was used
# $aln_one_cm_R:              RETURN; <s> if --aln-one <s> used in ssu-align runs, or "" if --aln-one not used
# $sum_file:                  ssu-merge summary file
# 
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If a required program does not exist, a directory
#             that we think should be there does not exist, or
#             an ssu-align job appears to not have finished, we
#             print a message to STDERR and exit with non-zero status.
#
####################################################################
sub validate_and_setup_ssu_merge { 
    my $narg_expected = 21;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, validate_and_setup_ssu_merge() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($ssualigndir, $opt_HR, $dir, $subdir_AR, $score_to_merge_AR, $sum_to_merge_AR, $log_to_merge_AR, $tab_to_merge_AR, $nomatch_to_merge_AR, $cmalign_to_merge_AAR, $hits_fa_to_merge_AAR, 
       $hits_list_to_merge_AAR, $stk_to_merge_AAR, $cm_names_AR, $cmalign_R, $alistat_R, $cm_file_R, $no_search_enabled_R, $no_align_enabled_R, $aln_one_cm_R, $sum_file) = @_;

    #Make sure $dir exists
    if(!(-d $dir)) { PrintErrorAndExit("ERROR, directory $dir does not exist.", $sum_file, 1); }

    # Read the ssu-align-prep.sum file to determine what options were used, including -m, --no-search, and --no-align
    my $cm_file = "";
    my $ssu_align_prep_sum = $dir . "/" . $dir . ".ssu-align.prep.sum";
    my $no_search_enabled = 0;
    my $no_align_enabled = 0;
    my $read_command_line = 0;
    my $aln_one_cm = "";
    my $only_cm = "";
    if(! (-e $ssu_align_prep_sum)) { 
	PrintErrorAndExit("ERROR, unable to locate summary file created by ssu-align in prep mode: $ssu_align_prep_sum.", $sum_file, 1);
    }
    else { 
	open(SUM, $ssu_align_prep_sum) || FileOpenFailure($ssu_align_prep_sum, $sum_file, $!, "reading");
	my $line;
	while($line = <SUM>) { 
	    if($line =~ s/^\#\s+command\:\s+//) { 
		$read_command_line = 1;
		chomp $line;
		my @prep_argv = split(/\s+/, $line);
		my $trash_out_dir = pop(@prep_argv);
		my $trash_fa_file = pop(@prep_argv);
		my $nels = scalar(@prep_argv);
		for($a = 1; $a < scalar(@prep_argv); $a++) { 
		    if($prep_argv[$a] eq "-m") { 
			if($a == ($nels-1)) { PrintErrorAndExit("ERROR, processing ssu-align prep summary file, -m was read as final command line arg to ssu-align. This shouldn't happen.", $sum_file, 1); }
			$cm_file = $prep_argv[$a+1];
		    }
		    if($prep_argv[$a] eq "--aln-one")   { 
			if($a == ($nels-1)) { PrintErrorAndExit("ERROR, processing ssu-align prep summary file, --aln-one was read as final command line arg to ssu-align. This shouldn't happen.", $sum_file, 1); }
			$aln_one_cm = $prep_argv[$a+1];
		    }
		    if($prep_argv[$a] eq "--only")   { 
			if($a == ($nels-1)) { PrintErrorAndExit("ERROR, processing ssu-align prep summary file, --only was read as final command line arg to ssu-align. This shouldn't happen.", $sum_file, 1); }
			$only_cm = $prep_argv[$a+1];
		    }
		    if($prep_argv[$a] eq "--no-search") { $no_search_enabled = 1; }
		    if($prep_argv[$a] eq "--no-align")  { $no_align_enabled = 1; }
		}
	    }
	}
    }
    if(! $read_command_line) { 
	PrintErrorAndExit("ERROR, unable to read line beginning \"\# command\:\" in ssu-align prep mode summary file: $ssu_align_prep_sum.", $sum_file, 1);
    }

    #Make sure the CM file exists (we may have read it as the argument to -m in the ssu-align.prep file)
    if($opt_HR->{"-m"} ne "") { # overwrite whatever we read in the ssu-align.prep file
	$cm_file = $opt_HR->{"-m"}; 
	if(!(-e $cm_file))   { PrintErrorAndExit("ERROR, CM file $cm_file, specified with -m does not exist.", $sum_file, 1); }
    }
    elsif($cm_file eq "")  { # -m not enabled and -m not read from the ssu-align prep file, try default
	$cm_file = $ssualigndir . "/ssu-align-0p1.cm";
	if(!(-e $cm_file))   { PrintErrorAndExit("ERROR, the default CM file $cm_file does not exist.", $sum_file, 1); }
    }
    else { # cm file read from ssu-align prep summary file
	if(!(-e $cm_file))   { PrintErrorAndExit("ERROR, the CM file $cm_file read as the -m argument in ssu-align prep summary\nfile $ssu_align_prep_sum does not exist.\nUse -m <s> to specify that CM file <s> was used.", $sum_file, 1); }	
    }

    # determine CM names
    my %cm_name_idx_H = ();
    my ($cm_name, $line);
    my $ncm = 0;
    my $errmsg;
    open(CM, $cm_file) || FileOpenFailure($cm_file, $sum_file, $!, "reading");
    while($line = <CM>) {
	# the lines we're interested in look like this:
	#NAME     archaea
	if($line =~ /^NAME\s+(\S+)/) { 
	    $cm_name = $1;
	    if(exists($cm_name_idx_H{$cm_name})) { PrintErrorAndExit("ERROR, two CMs in CM file $cm_file have the name $cm_name. Each CM must have a unique name.", $sum_file, 1); }
	    if(($only_cm eq "") || ($only_cm eq $cm_name)) { # if --only <s> was enabled to ssu-align, we'll only use this cm if it is named <s>
		push(@{$cm_names_AR}, $cm_name);
		# initialize arrays for this cm:
		@{$cmalign_to_merge_AAR->[$ncm]} = ();
		@{$hits_fa_to_merge_AAR->[$ncm]} = ();
		@{$hits_list_to_merge_AAR->[$ncm]} = ();
		@{$stk_to_merge_AAR->[$ncm]} = ();
		$cm_name_idx_H{$cm_name} = $ncm++;
		
		if($cm_name eq $globals_H{"DF_NO_NAME"}) { PrintErrorAndExit("ERROR, you can't use a CM with the name " . $globals_H{"DF_NO_NAME"} . " that's reserved for indicating which sequences are not the best-match to any models.", $sum_file, 1); }
	    }
	}
    }
    close(CM);

    # check that cmalign is in the PATH
    my ($command, $command_worked);
    my $cmalign    = $globals_H{"cmalign"};
    RunExecutable("$cmalign -h > /dev/null", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $cmalign is not in your PATH environment\nvariable. See the User's Guide Installation section.");;

    # check that esl-alistat in the PATH
    my $alistat = $globals_H{"esl-alistat"};
    RunExecutable("$alistat -h > /dev/null", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $alistat is not in your PATH environment\nvariable. See the User's Guide Installation section.");;

    # determine which subdirectories in $dir were created by ssu-align
    my %subdir_H = ();
    my $max_num = 0;
    my ($subdir, $num, $file, $cm, $maybe_dir);
    foreach $maybe_dir (glob("$dir/*")) { 
	if(-d $maybe_dir) { # $maybe_dir is a dir
	    $maybe_dir =~ s/^$dir\///;
	    if($maybe_dir =~ /^$dir\.(\d+)$/) { 
		$num = $1;
		if($num > 0) { #don't bother with '0' or negative numbers, they weren't created by ssu-align 
		    if($num > $max_num) { $max_num = $num; }
		    $subdir_H{$maybe_dir} = 1;
		}
	    }
	}		
    }

    # verify we have a contiguous set of ssu-align created subdirectories, each
    # of which contains a finished sum file that indicates ssu-align is done running there.
    my @cpu_A = ();
    my ($child_sum_file, $seen_cpu);
    if($max_num == 0) { PrintErrorAndExit("ERROR, couldn't find any subdirectories created by ssu-align in $dir.\nDid you run the shell script created by your initial ssu-align --prep-* call?", $sum_file, 1); }
    # Make sure we have all directories from <dir>.1 to <dir>.$max_num, and they all
    # contain ssu-align sum files in them that are finished running.
    for($i = 1; $i <= $max_num; $i++) { 
	$subdir = "$dir." . $i;
	if(! (exists $subdir_H{($subdir)})) { 
	    PrintErrorAndExit("ERROR, ssu-align created subdirectory " . $dir . "." . $i . " does not exist in $dir (but " . $dir . "." . $max_num . " does).", $sum_file, 1); 
	}
	$child_sum_file = $dir . "/" . $subdir . "/" . $subdir . ".ssu-align.sum";
	if(! (-e $child_sum_file)) { 
	    PrintErrorAndExit("ERROR, ssu-align created subdirectory " . $dir . "/$subdir does not have a ssu-align summary (.sum) file in it.\nThis suggests the ssu-align job for that directory has not completed executing yet.\nPlease execute it, or if it is currently executing, wait until it is finished.\nThen run ssu-merge again.", $sum_file, 1);  
	}
	# look for a line starting with  "# CPU" (reporting running time) in ssu-align summary file (it should be there if the file is finished running) 
	open(SUM, $child_sum_file) || FileOpenFailure($child_sum_file, $sum_file, $!, "reading");
	$seen_cpu = 0;
	while($line = <SUM>) { 
	    if($line =~ m/^\#\s+CPU time/) { $seen_cpu = 1; }
	}
	close(SUM);
	if(! $seen_cpu) { 
	    PrintErrorAndExit("ERROR, ssu-align created subdirectory " . $dir . "/$subdir has an incomplete ssu-align summary (.sum) file in it.\nThis suggests the ssu-align job for that directory did not successfully finish running yet.\nPlease rerun it or wait until it is finished.\nThen run ssu-merge again.", $sum_file, 1);  
	}
	push(@{$subdir_AR}, $subdir);
    }

    # make a list of files to merge, by checking each subdirectory for each possible file, either 0 or 1 alignment per CM should exist,
    foreach $subdir (@{$subdir_AR}) { 
	# each directory should have:
	# $subdir.ssu-align.sum:  
	# $subdir.scores:         unless --no-search enabled
	# $subdir.tab:            unless --no-search enabled
	# $subdir.nomatch:        will not exist if --no-search enabled, or if all seqs matched a CM
	#
	# and potentially for each CM $cm:
	# $subdir.$cm.cmalign
	# $subdir.$cm.hits.fa
	# $subdir.$cm.hits.list
	# $subdir.$cm.stk
	# 

	foreach $file (glob("$dir/$subdir/*")) { 
	    if($file =~ m/$subdir\.scores$/) { 
		push(@{$score_to_merge_AR}, $file);
	    }
	    if($file =~ m/$subdir\.ssu-align.sum/) { 
		push(@{$sum_to_merge_AR}, $file);
	    }
	    if($file =~ m/$subdir\.ssu-align.log/) { 
		push(@{$log_to_merge_AR}, $file);
	    }
	    if($file =~ m/$subdir\.tab/) { 
		push(@{$tab_to_merge_AR}, $file);
	    }
	    if($file =~ m/$subdir\.nomatch/) { 
		push(@{$nomatch_to_merge_AR}, $file);
	    }
	    if($file =~ m/$subdir\.(\S+)\.cmalign/) { 
		$cm = $1;
		if(! (exists($cm_name_idx_H{$cm}))) { PrintErrorAndExit("ERROR, found ssu-align output file $file in subdirectory $subdir/ created for a CM named $cm\nNo such CM exists in $cm_file.\nDid you use -m <s> when you ran ssu-align? If so pass -m <s> to ssu-merge as well.", $sum_file, 1); }
		push(@{$cmalign_to_merge_AAR->[$cm_name_idx_H{$cm}]}, $file);
	    }
	    if($file =~ m/$subdir\.(\S+)\.hits.fa/) { 
		$cm = $1;
		if(! (exists($cm_name_idx_H{$cm}))) { PrintErrorAndExit("ERROR, found ssu-align output file $file in subdirectory $subdir/ created for a CM named $cm\nNo such CM exists in $cm_file.\nDid you use -m <s> when you ran ssu-align? If so pass -m <s> to ssu-merge as well.", $sum_file, 1); }
		push(@{$hits_fa_to_merge_AAR->[$cm_name_idx_H{$cm}]}, $file);
	    }
	    if($file =~ m/$subdir\.(\S+)\.hits.list/) { 
		$cm = $1;
		if(! (exists($cm_name_idx_H{$cm}))) { PrintErrorAndExit("ERROR, found ssu-align output file $file in subdirectory $subdir/ created for a CM named $cm\nNo such CM exists in $cm_file.\nDid you use -m <s> when you ran ssu-align? If so pass -m <s> to ssu-merge as well.", $sum_file, 1); }
		push(@{$hits_list_to_merge_AAR->[$cm_name_idx_H{$cm}]}, $file);
	    }
	    if($file =~ m/$subdir\.(\S+)\.stk/) { 
		$cm = $1;
		if(! (exists($cm_name_idx_H{$cm}))) { PrintErrorAndExit("ERROR, found ssu-align output file $file in subdirectory $subdir/ created for a CM named $cm\nNo such CM exists in $cm_file.\nDid you use -m <s> when you ran ssu-align? If so pass -m <s> to ssu-merge as well.", $sum_file, 1); }
		push(@{$stk_to_merge_AAR->[$cm_name_idx_H{$cm}]}, $file);
	    }
	}
    }	
    $$cmalign_R                 = $cmalign;
    $$alistat_R                 = $alistat;
    $$cm_file_R                 = $cm_file;
    $$no_search_enabled_R       = $no_search_enabled;
    $$no_align_enabled_R        = $no_align_enabled;
    $$aln_one_cm_R              = $aln_one_cm;

    return;
}


#####################################################################
# Subroutine: merge_alignments_for_a_cm()
# Incept:     EPN, Tue Oct 27 18:05:43 2009
# 
# Purpose:    Given a list of alignments created by the same CM to merge, 
#             merge them with a single call to cmalign --list-merge.
#
# Arguments: 
# $opt_HR:             reference to hash of command line options
# $stk_name:           name for merged alignment file
# $dir:                main directory created by ssu-align --prep-* that 
#                      includes subdirectories with alignments
# $cm_file:            the CM file
# $cm_idx:             index of the relevant CM in the CM file
# $cm_name:            name of the relevant CM in the CM file
# $stk_to_merge_AR:    reference to the array of alignments to merge
# $sum_file:           ssu-merge summary file
# $log_file:           log file
# 
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If something goes wrong, this subroutine prints an
#             error and exits.
#
####################################################################
sub merge_alignments_for_a_cm { 
    my $narg_expected = 9;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, merge_alignments_for_a_cm() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($opt_HR, $stk_name, $dir, $cm_file, $cm_idx, $cm_name, $stk_to_merge_AR, $sum_file, $log_file) = @_;

    my ($output, $stk, $command, $command_worked);

    # create a temporary file with the stk list:
    my $list_file = $dir . "/" . $cm_name . ".merge.list";
    open(LIST, ">" . $list_file) || FileOpenFailure($list_file, $sum_file, $!, "writing");
    foreach $stk (@{$stk_to_merge_AR})   { printf LIST ("$stk\n"); }
    close(LIST);

    if(-e $stk_name) { 
	if(! ($opt_HR->{"-F"})) { 
	    PrintErrorAndExit("ERROR, alignment file $stk_name already exists. Delete it or use -F to overwrite it.", $sum_file, 1); 
	}
	else {
	    UnlinkFile($stk_name, $log_file);
	}
    }

    my $extra_opts = "";
    if($opt_HR->{"-1"}) { $extra_opts = " -1"; }

    $command = "$cmalign $extra_opts --cm-name $cm_name --list-merge -o $stk_name $cm_file $list_file 2>&1";
    RunExecutable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");

    UnlinkFile($list_file, $log_file);
    return;
}


#####################################################################
# Subroutine: concatenate_a_list_of_files()
# Incept:     EPN, Wed Oct 28 17:12:05 2009
# 
# Purpose:    Given a list of files to concatenate, do it.
#
# Arguments: 
# $opt_HR:              reference to hash of command line options
# $concat_file:         the name for the file we want to create
# $files_to_concat_AR:  reference to the array of files to concatenate
# 
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If something goes wrong, this subroutine prints an
#             error and exits.
#
####################################################################
sub concatenate_a_list_of_files { 
    my $narg_expected = 3;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, concatenate_a_list_of_files() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($opt_HR, $concat_file, $files_to_concat_AR) = @_;

    if(scalar(@{$files_to_concat_AR}) == 0) { return; } #if array is empty, just leave

    my ($file, $command, $output, $i, $command_worked);

    # ensure all the files exist
    foreach $file (@{$files_to_concat_AR}) { 
	if(! (-e $file)) { PrintErrorAndExit("ERROR, file $file does not exist, (it was to be cat'ed to $concat_file).", $sum_file, 1); }
    }

    # check if concat file already exists
    if(-e $concat_file) { 
	if(! ($opt_HR->{"-F"})) { 
	    PrintErrorAndExit("ERROR, file $concat_file already exists. Delete it or use -F to overwrite it.", $sum_file, 1); 
	}
	else {
	    UnlinkFile($concat_file, $log_file);
	}
    }

    # create concat file
    $command = "cat $files_to_concat_AR->[0] > $concat_file";
    RunExecutable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");

    # add to concat file
    for($i = 1; $i < scalar(@{$files_to_concat_AR}); $i++) { 
	$command = "cat " . $files_to_concat_AR->[$i] . " >> $concat_file";
	RunExecutable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");
    }

    return;
}


#####################################################################
# Subroutine: concatenate_sum_files_and_merge_statistis()
# Incept:     EPN, Wed Oct 28 17:12:05 2009
# 
# Purpose:    Given a list of ssu-align summary files to concatenate,
#             concatenate them and merge (by summing) the statistics
#             within them.
#
# Arguments: 
# $opt_HR:                  reference to hash of command line options
# $concat_file:             the name for the file we want to create
# $sum_files_to_concat_AR:  reference to the array of files to concatenate
# $cm_names_AR:             reference to array of CM names
# $summed_search_seconds_R: RETURN: summed search seconds
# $summed_align_seconds_R:  RETURN: summed align seconds
# $summed_total_seconds_R:  RETURN: summed total seconds
# $target_nseq_R:           RETURN: reference to number of sequences in all input target files, filled here
# $target_nres_R:           RETURN: number of residues in all input target files, filled here
# $nseq_all_cms_R:          RETURN: number of sequences that were best match to any CM in all child run, filled here
# $nres_total_all_cms_R:    RETURN: summed length of all target seqs that were best 
#                           match to any CM in all child run, filled here
# $nres_aligned_all_cms_R : RETURN: summed length of extracted and aligned target seqs 
#                           that were best match to any CM in all child run, filled here
# $nseq_cm_HR:              RETURN: number of sequences that were best match to each CM in all child runs, filled here
# $nres_total_cm_HR:        RETURN: summed length of target seqs that were best match to each CM in all child runs, filled here
# $nres_aligned_cm_HR:      RETURN: summed length of extracted and aligned target seqs that 
#                           were best match to each CM in all child runs, filled here
# $sum_file:                ssu-merge sum_file
#
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If something goes wrong, this subroutine prints an
#             error and exits.
#
####################################################################
sub concatenate_sum_files_and_merge_statistics {
    my $narg_expected = 16;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, concatenate_sum_files_and_add_up_timings() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($opt_HR, $concat_file, $sum_files_to_concat_AR, $cm_names_AR, $summed_search_seconds_R, $summed_align_seconds_R, $summed_total_seconds_R,
	$target_nseq_R, $target_nres_R, $nseq_all_cms_R, $nres_total_all_cms_R, $nres_aligned_all_cms_R, $nseq_cm_HR, $nres_total_cm_HR, $nres_aligned_cm_HR, $sum_file) = @_;

    if(scalar(@{$sum_files_to_concat_AR}) == 0) { return; } #if array is empty, just leave

    # initialize stats
    my $cm_name;
    my %cm_name_exists_H = ();
    foreach $cm_name (@{$cm_names_AR}) { $cm_name_exists_H{$cm_name} = 1; }
    my $target_nseq = 0;
    my $target_nres = 0;
    my $nseq_all_cms = 0;
    my $nres_total_all_cms = 0;
    my $nres_aligned_all_cms = 0;

    my ($child_sum_file, $command, $output, $i, $command_worked, $line);

    # ensure all the files exist
    foreach $child_sum_file (@{$sum_files_to_concat_AR}) { 
	if(! (-e $child_sum_file)) { PrintErrorAndExit("ERROR, file $child_sum_file does not exist, (it was to be cat'ed to $concat_file).", $sum_file, 1); }
    }

    # check if concat file already exists
    if(-e $concat_file) { 
	if(! ($opt_HR->{"-F"})) { 
	    PrintErrorAndExit("ERROR, file $concat_file already exists. Delete it or use -F to overwrite it.", $sum_file, 1); 
	}
	else {
	    UnlinkFile($concat_file, $log_file);
	}
    }

    # Create concat file by printing one line at a time, we do it this way only for *.sum files so we can
    # total up the running times within them.

    open(NEW, ">" . $concat_file) || FileOpenFailure($concat_file, $sum_file, $!, "writing");
    if(! (open(NEW, ">" . $concat_file))) { PrintErrorAndExit("ERROR, couldn't open $concat_file for merging *.sum files.", $sum_file, 1); }
    
    my $summed_search_seconds = 0.;
    my $summed_align_seconds = 0.;
    my $summed_total_seconds = 0.;
    my $nstat_lines_expected = 3 + scalar(@{$cm_names_AR}); # 3 is for *input* line, *all models* line, and *no models*, then 1 for each CM
    my $nsearch_stats_seen = 0;
    my $nalign_stats_seen = 0;
    my $nchildren_files = scalar(@{$sum_files_to_concat_AR});

    my ($action, $hours, $minutes, $seconds, $cur_seconds, $errmsg, $nseq, $fract, $avglen, $cov, $nstat_lines_seen, $aligned_nres, $total_nres, $nt);
    foreach $child_sum_file (@{$sum_files_to_concat_AR}) { 
	open(CHILD, $child_sum_file) || FileOpenFailure($child_sum_file, $sum_file, $!, "reading");
	$nstat_lines_seen = 0;
	while($line = <CHILD>) { 
	    if($line =~ /^\#\s+CPU\stime\s+\((\S+)\)\:\s+(\S+)\s*$/) { 
		$action = $1;
		($hours, $minutes, $seconds) = split(":", $2);
		$cur_seconds = (3600. * $hours) + (60. * $minutes) + $seconds;
		if   ($action eq "search")     { $summed_search_seconds += $cur_seconds; }
		elsif($action eq "alignment")  { $summed_align_seconds  += $cur_seconds; }
		elsif($action eq "total")      { $summed_total_seconds  += $cur_seconds; }
		else { PrintErrorAndExit("ERROR, unable to parse the following \"CPU time\" line from $child_sum_file:\n$line", $sum_file, 1); }
	    }
	    if($line =~ m/^\s+search\s+(\d+)\s+\S+\s+\S+\s+(\d+)\s+\S+\s*$/) { 
		; # no need to store anything
		($nseq, $nt) = ($1, $2);
		$nsearch_stats_seen++;
	    }
	    elsif($line =~ m/^\s+alignment\s+(\d+)\s+\S+\s+\S+\s+(\d+)\s+\S+\s*$/) { 
		; # no need to store anything
		$nalign_stats_seen++;
	    }
	    elsif($line =~ m/^\s+(\S+)\s+(\d+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s*$/) { 
		($cm_name, $nseq, $fract, $avglen, $cov, $nt) = ($1, $2, $3, $4, $5, $6);
		$nstat_lines_seen++;
		if($cm_name eq "*input*") { 
		    $target_nseq += $nseq;
		    $target_nres += $nt;
		}
		elsif(($cm_name eq "*all-models*") || ($cm_name eq "*no-models*")) { 
		    ; # nothing to parse here
		}
		else { # a CM line 
		    if(! exists($cm_name_exists_H{$cm_name})) { close(CHILD); close(NEW); PrintErrorAndExit("ERROR, found unexpected CM named \"$cm_name\" listed in ssu-align summary output file: $child_sum_file.", $sum_file, 1); }
		    $nseq_all_cms           += $nseq;
		    $nseq_cm_HR->{$cm_name} += $nseq;
		    if($nseq > 0) { 
			$aligned_nres                    = $nt;
			$total_nres                      = $aligned_nres / $cov;
			$nres_total_all_cms             += $total_nres;
			$nres_total_cm_HR->{$cm_name}   += $total_nres;
			$nres_aligned_all_cms           += $aligned_nres;
			$nres_aligned_cm_HR->{$cm_name} += $aligned_nres;
		    }
		}
	    }
	    printf NEW $line;
	}
	close(CHILD);
	if($nstat_lines_seen != $nstat_lines_expected) { 
	    close(NEW);
	    PrintErrorAndExit("ERROR, failed to parse statistics section of ssu-align summary file $child_sum_file.\nExpected $nstat_lines_expected summary lines, read $nstat_lines_seen.", $sum_file, 1); 
	}
    }
    close(NEW);

    if(($nsearch_stats_seen != 0) && ($nsearch_stats_seen != $nchildren_files)) {
	PrintErrorAndExit("ERROR, read search timing stats from some but not all ssu-align summary files.\nEither all or none should have search timinig stats.", $sum_file, 1); 
    }
    if(($nalign_stats_seen != 0) && ($nalign_stats_seen != $nchildren_files)) {
	PrintErrorAndExit("ERROR, read alignment timing stats from some but not all ssu-align summary files.\nEither all or none should have alignment timing stats.", $sum_file, 1); 
    }
    if($nalign_stats_seen == 0)  { $summed_align_seconds = "NA"; }
    if($nsearch_stats_seen == 0) { $summed_search_seconds = "NA"; }

    $$summed_search_seconds_R = $summed_search_seconds;
    $$summed_align_seconds_R  = $summed_align_seconds;
    $$summed_total_seconds_R  = $summed_total_seconds;
    $$target_nseq_R           = $target_nseq;
    $$target_nres_R           = $target_nres;
    $$nseq_all_cms_R          = $nseq_all_cms;
    $$nres_total_all_cms_R    = $nres_total_all_cms;
    $$nres_aligned_all_cms_R  = $nres_aligned_all_cms;
    return;
}

