#!/usr/bin/perl
#
# ssu-draw
# Eric Nawrocki
# EPN, Wed Oct  7 11:47:02 2009
#
# Usage: ssu-draw [options] <directory created by ssu-align (includes alignment file(s))>
# Usage: ssu-draw [options] -a <Stockholm alignment file (must have .stk suffix)>
#             
# Synopsis:
# Draws secondary structure diagrams of alignment files created by ssu-align.
#
# See definition of $options_usage for options, below.
#
use Getopt::Long;
use Cwd 'abs_path';
use strict;

my $total_time = -1 * time();
my $usage =  "Usage: ssu-draw [options] <directory created by ssu-align (includes >= 1 alignment file(s))>\n";
   $usage .= "Usage: ssu-draw [options] -a <Stockholm alignment file (must have .stk suffix)>\n";
my $options_usage  = "where general options are:\n";
#                           1         2         3         4         5         6         7         8
#                  12345678901234567890123456789012345678901234567890123456789012345678901234567890
$options_usage .= "  -h            : show brief help on version and usage\n";
$options_usage .= "  -m <f>        : CM file <f> created the alignment(s) (with ssu-align -m <f>)\n";
$options_usage .= "  -t <f>        : use template file <f>, not the default template file\n";
$options_usage .= "  --key-in <s>  : assume <s> is part of input file names, before the suffix\n";
$options_usage .= "  --key-out <s> : add <s> to all output file names, before the suffix\n";
$options_usage .= "  --use-masks   : draw masks from ssu-mask created '.mask' files in the aln dir\n";
$options_usage .= "  --in-mask <s> : mask alignment given 1/0s in 1-line mask file <f>, requires -a\n";
$options_usage .= "  --pdf <s>     : <s> (!= \"ps2pdf\") is the command for converting ps to pdf\n";
$options_usage .= "  --rm-ps       : if --pdf or ps2pdf is installed, do not save postscript files\n";
$options_usage .= "\noptions for 1-page alignment summary diagrams (by default, all are drawn):\n";
$options_usage .= "  --no-aln : do not create multi-page pdf with all alignment stats\n";
$options_usage .= "  --prob   : draw average posterior probability per column (save as *.prob.pdf)\n";
$options_usage .= "  --ins    : draw frequency of insertions per column (save as *.ins.pdf)\n";
$options_usage .= "  --dall   : draw frequency of deletions per column (save as *.dall.pdf)\n";
$options_usage .= "  --dint   : draw frequency of internal deletions per column (save as *.dint.pdf)\n";
$options_usage .= "  --info   : draw sequence information content per position (save as *.info.pdf)\n";
$options_usage .= "  --struct : draw structural information content per position (save as *.struct.pdf)\n";
$options_usage .= "\noptions for structure diagrams for individual sequences:\n";
$options_usage .= "  --indi    : draw sequence and probability diagrams for all aligned sequences\n";
$options_usage .= "  --no-prob : with --indi, omit probability diagrams\n";
$options_usage .= "  --cons    : draw consensus sequence/structure only (save as *.cons.pdf)\n";
$options_usage .= "\noptions for omitting parts of the diagrams:\n";
$options_usage .= "  --no-leg  : do not draw legends\n";
$options_usage .= "  --no-head : do not draw headers\n";
$options_usage .= "  --no-foot : do not draw footers\n";

###################
# Process options #
###################
my %opt_H = ();              # key: option (example "-h"); value: option argument (example ("0" or "1") if option takes no arg, actual argument if option takes arg)
my %opt_takes_arg_H  = ();   # key: option; value: "1" if option takes argument, "0" if not
my @opt_order_A  = ();       # order of options for printing in banner
my $opt;

$opt_takes_arg_H{"-a"}          = 0;  push(@opt_order_A, "-a");           
$opt_takes_arg_H{"-h"}          = 0;  push(@opt_order_A, "-h");           
$opt_takes_arg_H{"-m"}          = 1;  push(@opt_order_A, "-m");           
$opt_takes_arg_H{"-t"}          = 1;  push(@opt_order_A, "-t");           
$opt_takes_arg_H{"--key-in"}    = 1;  push(@opt_order_A, "--key-in");     
$opt_takes_arg_H{"--key-out"}   = 1;  push(@opt_order_A, "--key-out");    
$opt_takes_arg_H{"--use-masks"} = 0;  push(@opt_order_A, "--use-masks");  
$opt_takes_arg_H{"--in-mask"}   = 1;  push(@opt_order_A, "--in-mask");    
$opt_takes_arg_H{"--pdf"}       = 1;  push(@opt_order_A, "--pdf");      
$opt_takes_arg_H{"--rm-ps"}     = 0;  push(@opt_order_A, "--rm-ps");      
$opt_takes_arg_H{"--no-aln"}    = 0;  push(@opt_order_A, "--no-aln");     
$opt_takes_arg_H{"--prob"}      = 0;  push(@opt_order_A, "--prob");       
$opt_takes_arg_H{"--ins"}       = 0;  push(@opt_order_A, "--ins");        
$opt_takes_arg_H{"--dall"}      = 0;  push(@opt_order_A, "--dall");       
$opt_takes_arg_H{"--dint"}      = 0;  push(@opt_order_A, "--dint");       
$opt_takes_arg_H{"--info"}      = 0;  push(@opt_order_A, "--info");       
$opt_takes_arg_H{"--struct"}    = 0;  push(@opt_order_A, "--struct");     
$opt_takes_arg_H{"--indi"}      = 0;  push(@opt_order_A, "--indi");       
$opt_takes_arg_H{"--no-prob"}   = 0;  push(@opt_order_A, "--no-prob");    
$opt_takes_arg_H{"--cons"}      = 0;  push(@opt_order_A, "--cons");       
$opt_takes_arg_H{"--no-leg"}    = 0;  push(@opt_order_A, "--no-leg");     
$opt_takes_arg_H{"--no-head"}   = 0;  push(@opt_order_A, "--no-head");    
$opt_takes_arg_H{"--no-foot"}   = 0;  push(@opt_order_A, "--no-foot");    

#set default options
foreach $opt (keys %opt_takes_arg_H) { 
    if($opt_takes_arg_H{$opt}) { $opt_H{$opt} = ""; }
    else                       { $opt_H{$opt} = 0; }
}

Getopt::Long::Configure ("bundling");
my $opt_return = GetOptions
    ('a'         => \$opt_H{"-a"},
     'h'         => \$opt_H{"-h"}, 
     'm=s'       => \$opt_H{"-m"},
     't=s'       => \$opt_H{"-t"},
     'key-in=s'  => \$opt_H{"key-in"},
     'key-out=s' => \$opt_H{"key-out"},
     'use-masks' => \$opt_H{"--use-masks"},
     'in-mask=s' => \$opt_H{"in-mask"},
     'rm-ps'     => \$opt_H{"--rm-ps"},
     'no-aln'    => \$opt_H{"--no-aln"},
     'prob'      => \$opt_H{"--prob"},
     'ins'       => \$opt_H{"--ins"},
     'dall'      => \$opt_H{"--dall"},
     'dint'      => \$opt_H{"--dint"},
     'info'      => \$opt_H{"--info"},
     'struct'    => \$opt_H{"--struct"},
     'indi'      => \$opt_H{"--indi"},
     'no-prob'   => \$opt_H{"--no-prob"},
     'cons'      => \$opt_H{"--cons"},
     'no-leg'    => \$opt_H{"--no-leg"},
     'no-head'   => \$opt_H{"--no-head"},
     'no-foot'   => \$opt_H{"--no-foot"});

if($opt_return != 1) { exit(1); }

if ($opt_H{"-h"}) { print $usage . "\n"; print $options_usage; exit(1); } 

my $key_in = "";
if($opt_H{"--key-in"}  ne '') { $key_in   = "." . opt_H{"--key-in"};  }
my $key_out = "";
if($opt_H{"--key-out"}  ne '') { $key_out   = "." . opt_H{"--key-out"};  }

# Check for incompatible options combinations.
if($opt_H{"--use-masks"} && ($opt_H{"--in-mask"} ne '')) { 
    printf STDERR ("\nERROR, --in-mask is incompatible with --use-masks.\n"); exit(1); 
}
if(($opt_H{"--in-mask"} ne '') && ($opt_H{"-a"} == 0)) { 
    printf STDERR ("\nERROR, --in-mask requires the -a option.\n"); exit(1);
}    
if(($opt_H{"--no-prob"}) && (!($opt_H{"--indi"}))) {
    printf STDERR ("\nERROR, --no-prob only makes sense in combination with --indi.\n"); exit(1);
}    


################
# Print banner #
################
my @log2print_A = ();
print_banner($0, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, \@log2print_A);

if(scalar(@ARGV) != 1) {   
    print "Incorrect number of command line arguments.\n";
    print $usage;
    print "\nTo see more help on available options, do ssu-draw -h\n\n";
    exit(1);
}
my ($dir) = $ARGV[0];
$dir =~ s/\/$//;


##################################
# Validate that everything is go #
##################################

my @stk_list_A = ();
my @mask_list_A = ();
my ($cm_file, $template_file, $ssdraw, $ps2pdf);
validate_and_setup($dir, $key_in, \%opt_H, \$cm_file, \$template_file, \$ssdraw, \$ps2pdf, \@stk_list_A, \@mask_list_A);
my $naln = scalar(@stk_list_A);
my $aln_file;


#################
# Format output #
#################

# determine max file name width
my $max_width_aln = length("alignment file name");
my ($nec_width, $i, $max_width_draw, $aln_root, $aln_root2print);
my $extra_draw_chars = 0;
if($opt_H{"--ins"}) { $extra_draw_chars = 3+1; } # +1 is for the '.'
if($opt_H{"--prob"} || $opt_H{"--dall"} || $opt_H{"--dint"} || $opt_H{"--info"} || $opt_H{"--indi"} || $opt_H{"--cons"}) { 
    $extra_draw_chars = 4+1; 
}
if($opt_H{"--struct"}) { $extra_draw_chars = 5+1; }

for($i = 0; $i < $naln; $i++) { 
    $aln_file         = $stk_list_A[$i];
    ($aln_root)       = ($aln_file =~ /(.+)\.stk/);
    if($opt_H{"-a"}) { #print directory as well as aln name
	($aln_root2print) = ($aln_file =~ /(.+)\.stk/);
    }
    else {
	($aln_root2print) = ($aln_file =~ /.+\/(.+)\.stk/);
    }
    $nec_width = length($aln_root2print) + length($key_out) + length(".stk");
    if($max_width_aln < $nec_width) { $max_width_aln = $nec_width; }
}					     
my $max_width_draw = $max_width_aln - 1 + $extra_draw_chars; # (-1 is diff between .stk and .ps) ($extra_draw_chars is for adding keys, such as 'struct.' to names )
if($ps2pdf ne "") { $max_width_draw++; }    # diff between .ps .pdf
if($max_width_draw < length("structure diagram file")) { $max_width_draw = length("structure diagram file"); }
my $dashes_aln = "";  for($i = 0; $i < $max_width_aln; $i++)  { $dashes_aln .= "-"; }
my $dashes_draw = ""; for($i = 0; $i < $max_width_draw; $i++) { $dashes_draw .= "-"; }

push  (@log2print_A, sprintf("#\n# Drawing secondary structures...\n"));
printf($log2print_A[(scalar(@log2print_A)-1)]);
push  (@log2print_A, sprintf("#\n"));
printf($log2print_A[(scalar(@log2print_A)-1)]);

push  (@log2print_A, sprintf("# %-*s  %-*s\n", $max_width_aln, "alignment file name", $max_width_draw, "structure diagram file"));
printf($log2print_A[(scalar(@log2print_A)-1)]);
push  (@log2print_A, sprintf("# %-*s  %-*s\n", $max_width_aln, $dashes_aln, $max_width_draw, $dashes_draw));
printf($log2print_A[(scalar(@log2print_A)-1)]);


#######################
# Create the drawings #
#######################

my ($aln_file, $mask_file, $aln_file2print);
for($i = 0; $i < $naln; $i++) { 
    $aln_file  = $stk_list_A[$i];
    $mask_file = $mask_list_A[$i]; 
    if($opt_H{"-a"}) { #print directory as well as aln name
	$aln_file2print = $aln_file;
    }
    else { 
	($aln_file2print) = ($aln_file =~ /.+\/(.+)$/);
    }

    draw_alignment($ssdraw, $ps2pdf, $template_file, $aln_file, $aln_file2print, $mask_file,
		   $max_width_aln, $max_width_draw, $key_out, \%opt_H, \@log2print_A);
}

my ($log_file, $log_file2print);
push(@log2print_A, sprintf("#\n"));
printf($log2print_A[(scalar(@log2print_A)-1)]);

if(!($opt_H{"-a"})) { 
    $log_file       = $dir . "/" . $dir . $key_out . ".ssu-draw.log";
    $log_file2print = $dir . $key_out . ".ssu-draw.log";
    push  (@log2print_A, sprintf("# This output saved to log file: $log_file2print.\n"));
    printf($log2print_A[(scalar(@log2print_A)-1)]);
    push  (@log2print_A, sprintf("# \n"));
    printf($log2print_A[(scalar(@log2print_A)-1)]);
    push  (@log2print_A, sprintf("# All files saved in directory: \.\/$dir\/\n"));
    printf($log2print_A[(scalar(@log2print_A)-1)]);
}
else { 
    $dir =~ s/\.stk$//;
    $log_file       = $dir . $key_out . ".ssu-draw.log";
    $log_file2print = $log_file;
    push  (@log2print_A, sprintf("# This output saved to log file:\n#  $log_file2print.\n"));
    printf($log2print_A[(scalar(@log2print_A)-1)]);
}
push  (@log2print_A, sprintf("# \n"));
printf($log2print_A[(scalar(@log2print_A)-1)]);
print_log($log_file, \@log2print_A);

exit(0);


###############
# Subroutines #
###############

#####################################################################
# Subroutine: print_banner()
# Incept:     EPN, Thu Sep 24 14:40:39 2009
# 
# Purpose:    Print the ssu-draw banner.
#
# Arguments: 
#    $script_call:      call used to invoke this (ssu-draw) script
#    $opt_HR:           REFERENCE to hash of command-line options
#    $opt_takes_arg_HR: REFERENCE to hash telling if each option takes an argument (1) or not (0)
#    $opt_order_AR:     REFERENCE to array specifying order of options
#    $argv_ref:         REFERENCE to @ARGV, command-line arguments
#    $log2print_AR:     REFERENCE to log2print array with log file text
#
# Returns:    Nothing, if it returns, everything is valid.
# 
####################################################################
sub print_banner { 
    my $narg_expected = 6;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, print_banner() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($script_call, $opt_HR, $opt_takes_arg_HR, $opt_order_AR, $argv_ref, $log2print_AR) = @_;

    my ($i, $script_name, $start_log_line);
    $script_call =~ s/^\.+\///;
    $script_name = $script_call;
    $script_name =~ s/.+\///;
    my $enabled_options = "";
    foreach $opt (@{$opt_order_AR}) { 
	if($opt_takes_arg_HR->{$opt}) { if($opt_HR->{$opt} ne "") { $enabled_options .= " " . $opt . " " . $opt_HR->{$opt}; } }
	else                  	      { if($opt_HR->{$opt})       { $enabled_options .= " " . $opt; } }
    }

    $script_call =~ s/^\.+\///;
    $script_name = $script_call;
    $script_name =~ s/.+\///;

    $start_log_line = scalar(@{$log2print_AR});

    push(@{$log2print_AR}, sprintf("\# $script_name :: draw SSU rRNA secondary structure diagrams\n"));
    push(@{$log2print_AR}, sprintf("\# SSU-ALIGN 0.1 (October 2009)\n"));
    push(@{$log2print_AR}, sprintf("\# Copyright (C) 2009 HHMI Janelia Farm Research Campus\n"));
    push(@{$log2print_AR}, sprintf("\# Freely distributed under the GNU General Public License (GPLv3)\n"));
    push(@{$log2print_AR}, sprintf("\# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n"));
    push(@{$log2print_AR}, sprintf("%-10s %s ", "# command:", $script_call . $enabled_options));
    for($i = 0; $i < scalar(@{$argv_ref}) - 1; $i++) { 
	push(@{$log2print_AR}, sprintf("$argv_ref->[$i] "));
    }
    push(@{$log2print_AR}, sprintf("$argv_ref->[$i]\n"));
    push(@{$log2print_AR}, sprintf("%-10s ", "# date:"));
    push(@{$log2print_AR}, sprintf(scalar localtime()));
    push(@{$log2print_AR}, sprintf("\n"));

    for($i = $start_log_line; $i < scalar(@{$log2print_AR}); $i++) { 
	printf($log2print_AR->[$i]);
    }
    return;
}

#####################################################################
# Subroutine: validate_and_setup()
# Incept:     EPN, Mon Nov  3 15:05:56 2008
# 
# Purpose:    Validate that: 
#             - the CM file exists. 
#             - the postscript template file exists. 
#             - the required executable programs exist.
#             - there is at least 1 alignment in $dir directory
#               to operate on
#
# Arguments: 
# $dir:               the directory we will create files in
# $key_in:            '' or a key that is included in input file names, just prior to the suffix
#                     e.g. $key_in = "fookey", $dir = "foodir", aln file is foodir/foodir.archaea.fookey.stk
# $opt_HR:            reference to the hash of command-line options
# $cm_file_ref:       RETURN; the path to the CM file, either default CM file or $alt_cm_file
# $template_file_ref: RETURN; the path to the template file, either default template file or $alt_template_file
# $ssdraw_ref:        RETURN; the esl-ssdraw command
# $ps2pdf_ref:        RETURN; the ps2pdf command, or "" if system does not have ps2pdf and --pdf not enabled
# $stk_list_arr_ref:  RETURN; ref to array of alignment files to operate on
# $mask_list_arr_ref: RETURN; ref to array of alignment files to operate on
#
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If any of the above validations do not occur, we
#             print a message to STDERR explaining why it's
#             exiting early and then exit with non-zero status.
#
####################################################################
sub validate_and_setup { 
    my $narg_expected = 9;
    if(scalar(@_) != $narg_expected) { printf STDERR ("\nERROR, validate_and_setup() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($dir, $key_in, $opt_HR, $cm_file_ref, $template_file_ref, $ssdraw_ref, $ps2pdf_ref, $stk_list_arr_ref, $mask_list_arr_ref) = @_;

    #Validate that $dir exists
    if(!(-d $dir)) { printf STDERR ("\nERROR, directory $dir does not exist.\n"); exit(1); }
    #Validate that we can read the CM file
    my $ssualigndir;
    my $cm_file = "";
    if($opt_HR->{"-m"} ne '') {
	$cm_file = $opt_HR->{"-m"};
	if(!(-e $cm_file)) { printf STDERR ("\nERROR, CM file $cm_file, specified with -m does not exist.\n"); exit(1); }
    }
    else { # -m not enabled, assume the user used the default CM file:
	$ssualigndir = $ENV{'SSUALIGNDIR'};
	if(! exists($ENV{'SSUALIGNDIR'})) { 
	    printf STDERR ("\nERROR, the SSUALIGNDIR environment variable should be set but it's not.\nFor help, see the User's Guide Installation section.\n"); exit(1);
	    exit(1); 
	}
	$cm_file = $ssualigndir . "/ssu-align-0p1.cm";
	if(!(-e $cm_file)) { printf STDERR ("\nERROR, the default CM file $cm_file does not exist.\nIf you used a different CM file to create the alignments in $dir, use the -m option.\n"); exit(1); }
    }

    #Validate that we can read the template postscript diagram file
    if($opt_HR->{"-t"} ne '') {
	$template_file = $opt_HR->{"-t"};
	if(!(-e $template_file)) { printf STDERR ("\nERROR, template postscript file $template_file, specified with -t does not exist.\n"); exit(1); }
    }
    else { # -t not enabled, assume the user used the default CM file:
	$ssualigndir = $ENV{'SSUALIGNDIR'};
	if(! exists($ENV{'SSUALIGNDIR'})) { 
	    printf STDERR ("\nERROR, the SSUALIGNDIR environment variable should be set but it's not.\nFor help, see the User's Guide Installation section.\n"); exit(1);
	    exit(1); 
	}
	$template_file = $ssualigndir . "/ssu-align-0p1.ps";
	if(!(-e $template_file)) { printf STDERR ("\nERROR, the default template file $template_file does not exist.\nIf you want to use a different postscript template file to create the structure diagrams, use the -t option.\n"); exit(1); }
    }

    #Validate that esl-ssdraw exist
    my $ssdraw = "ssu-esl-ssdraw";
    my $trash = `$ssdraw -h 2>&1`;
    if($? == -1) { printf STDERR ("\nERROR, the required executable $ssdraw is not in your PATH environment\nvariable. See the User's Guide Installation section.\n"); exit(1); } 

    #determine if 'ps2pdf' exists, or that <s> from --pdf <s> exists if that was enabled
    my $ps2pdf = "ps2pdf";
    if($opt_HR->{"--pdf"} ne "") { $ps2pdf = $opt_HR->{"--pdf"}; }
    $trash = `$ps2pdf 2>&1`;
    if($? == -1) { #$ps2pdf did not work
	if($opt_HR->{"--pdf"} ne "") { 	#if --pdf <s> enabled but <s> is not a valid program name, we die
	    printf STDERR ("\nERROR, --pdf " . $opt_HR->{"--pdf"} . " was enabled, but $ps2pdf is not in your PATH environment variable.\n"); 
	    exit(1);
	}
	else { #if --pdf not enabled and ps2pdf does not exist, we can deal with this, unless --rm-ps enabled
	    if($opt_HR->{"--rm-ps"}) { 
		printf STDERR ("\nERROR, ps2pdf is not in your path, you can't use --rm-ps to remove postscripts in this case.\nIf you have another program that converts ps to pdf supply it as <s> with --pdf <s>.\n");
		exit(1);
	    }
	    $ps2pdf = ""; # default if ps2pdf does not exist
	}
    }

    if($opt_HR->{"--in-mask"} ne "") { 
	if(!(-e $opt_HR->{"--in-mask"})) { 
	    printf STDERR ("\nERROR, the --in-mask file %s does not exist.\n", $opt_HR->{"--in-mask"}); exit(1); 
	}
    }

    my $naln = 0;
    my $aln_name = '';
    my $mask_name = '';
    if($opt_HR->{"-a"}) { # special mode, single command line argument is not a directory, it's an alignment
	$aln_name = $dir;
	if(! (-e $aln_name)) { 
	    printf STDERR ("\nERROR, the alignment file $aln_name does not exist.\n"); exit(1); 
	}
	my $aln_root = $aln_name;
	if($aln_root !~ s/\.stk$//) { 
	    printf STDERR ("\nERROR, the alignment file must end with \".stk\", $aln_name does not.\n"); exit(1); 
	}
	push(@{$stk_list_arr_ref}, $aln_name);
	$naln++; 

	if($opt_HR->{"--use-masks"}) { #ensure that the mask for this alignment exists
	    $mask_name = $aln_root . ".mask";
	    if(! (-e $mask_name)) { 
		printf STDERR ("\nERROR, --use-masks enabled, but the mask file $mask_name does not exist.\n"); exit(1); 
	    }
	    push(@{$mask_list_arr_ref}, $mask_name);
	}
    }
    else { 
	# Validate there is at least 1 alignment in the input dir
	if(! (-d $dir)) { 
	    if(-e $dir) { 
		printf STDERR ("\nERROR, the command-line argument $dir is a file, not a directory.\nIt should be the directory that includes the input alignment files,\nor if you want to operate on a single alignment, use the -a option.\n"); exit(1); 
	    }
	    else { 
		printf STDERR ("\nERROR, the directory $dir with input alignment files does not exist.\n"); exit(1); 
	    }
	}
	my ($name);
	my $names = `grep NAME $cm_file 2>&1`;
	$names =~ s/NAME\s+//g;
	my @names_A = split(/\n/, $names);
	foreach $name (@names_A) { 
	    $aln_name = $dir . "/" . $dir . "." . $name . $key_in . ".stk";
	    if(-e $aln_name) { 
		push(@{$stk_list_arr_ref}, $aln_name);
		$naln++; 
		if($opt_HR->{"--use-masks"}) { 
		    $mask_name = $dir . "/" . $dir . "." . $name . $key_in . ".mask";
		    if(!(-e $mask_name)) { 
			printf STDERR ("\nERROR, --use-masks enabled, but the mask file $mask_name for aln $aln_name does not exist.\n"); exit(1); 
		    }
		    push(@{$mask_list_arr_ref}, $mask_name);
		}
	    }
	}
	if($naln == 0) { 
	    printf STDERR ("\nERROR, found 0 alignments created by ssu-align using the CM file $cm_file\nin directory $dir.\n\n");
	    printf STDERR ("The following alignments were searched for, but none were found:\n");
	    foreach $name (@names_A) { 
		$aln_name = $dir . "/" . $dir . "." . $name . $key_in . ".stk";
		printf STDERR ("\t$aln_name\n");
	    }
	    exit(1);
	}
    }

    $$cm_file_ref  = $cm_file;
    $$template_file_ref  = $template_file;
    $$ssdraw_ref  = $ssdraw;
    $$ps2pdf_ref  = $ps2pdf;
    
    return;
}


#####################################################################
# Subroutine: print_timing()
# Incept:     EPN, Tue Jun 16 08:52:08 2009
# 
# Purpose:    Print a timing in hhhh:mm:ss format to 1 second precision.
#
# Arguments: 
#   $prefix:      string that will precede timing output
#   $inseconds:   number of seconds the script required
#   $log2print_AR: reference to log2print array with log file text
#
# Returns:    Nothing, if it returns, everything is valid.
# 
####################################################################
sub print_timing { 
    my $narg_expected = 3;
    if(scalar(@_) != $narg_expected) { printf STDERR ("\nERROR, print_timing() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($prefix, $inseconds, $log2print_AR) = @_;
    my ($hours, $minutes, $seconds, $thours, $tminutes, $tseconds, $start_log_line, $i);

    $start_log_line = scalar(@{$log2print_AR});

    $hours = int($inseconds / 3600);
    $inseconds -= ($hours * 3600);
    $minutes = int($inseconds / 60);
    $inseconds -= ($minutes * 60);
    $seconds = $inseconds;
    $thours   = $hours;
    $tminutes = $minutes;
    $tseconds = $seconds;

    if($hours < 10)   { $thours   = "0" . $thours; }
    if($minutes< 10)  { $tminutes = "0" . $tminutes; }
    if($seconds< 10)  { $tseconds = "0" . $tseconds; }

    push(@{$log2print_AR}, sprintf("%s %2s:%2s:%2s\n", $prefix, $thours, $tminutes, $tseconds));

    for($i = $start_log_line; $i < scalar(@{$log2print_AR}); $i++) { 
	printf($log2print_AR->[$i]);
    }
}


#####################################################################
# subroutine: draw_alignment()
# incept:     EPN, Wed Oct  7 13:55:56 2009
# 
# Purpose:    Draw an alignment using the easel miniapp esl-ssdraw.
#
# Arguments:  
#   $ssdraw:            path and name of esl-alimanip/ssu-esl-alimanip executable
#   $ps2pdf:            command for converting ps to pdf, if "" we don't convert
#   $template_file:     template file for esl-ssdraw
#   $aln_file:          alignment file with path to draw
#   $aln_file2print:    name of alignment file, minus the directory
#   $mask_file2use:     mask file to use with --mask, or don't use --mask if ''
#   $max_width_aln:     width of output string for printing aln file names
#   $max_width_draw:    width of output string for printing draw file names
#   $key_out:           <s> from --key-out ("" if --key-out not enabled)
#   $opt_HR:            REFERENCE to hash of command-line options
#   $log2print_AR:       reference to log2print array with log file text
# 
# Returns:  Nothing, if it returns, everything is valid.
# 
####################################################################
sub draw_alignment { 
    my $narg_expected = 11;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, draw_alignment() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($ssdraw, $ps2pdf, $template_file, $aln_file, $aln_file2print, $mask_file2use, $max_width_aln, $max_width_draw, $key_out, $opt_HR, $log2print_AR) = @_;

    my ($all_aln_opts, $mask_opts, $draw_opts, $draw_key);
    if($mask_file2use ne '')  { $mask_opts = "--mask $mask_file2use"; }
    else                      { $mask_opts = ""; }

    # Default multi-page align call, or not if --no-aln enabled
    if(! ($opt_HR->{"--no-aln"})) { 
	$draw_opts = "--prob --ins --dall --dint --struct"; 
	$draw_key = $key_out; #this will be "" unless --key-out was enabled
	run_ssdraw($ssdraw, $ps2pdf, ($draw_opts . $mask_opts), $aln_file, $aln_file2print, $template_file, 
		   $draw_key, $max_width_aln, $max_width_draw, $opt_HR, $log2print_AR);
    }
    if($opt_HR->{"--prob"}) { 
	$draw_opts = "-q --prob"; 
	$draw_key = $key_out . "prob.";
	run_ssdraw($ssdraw, $ps2pdf, ($draw_opts . $mask_opts), $aln_file, $aln_file2print, $template_file, 
		   $draw_key, $max_width_aln, $max_width_draw, $opt_HR, $log2print_AR);
    }
    if($opt_HR->{"--ins"}) { 
	$draw_opts = "-q --ins"; 
	$draw_key = $key_out . "ins.";
	run_ssdraw($ssdraw, $ps2pdf, ($draw_opts . $mask_opts), $aln_file, $aln_file2print, $template_file, 
		   $draw_key, $max_width_aln, $max_width_draw, $opt_HR, $log2print_AR);
    }
    if($opt_HR->{"--dall"}) { 
	$draw_opts = "-q --dall"; 
	$draw_key = $key_out . "dall.";
	run_ssdraw($ssdraw, $ps2pdf, ($draw_opts . $mask_opts), $aln_file, $aln_file2print, $template_file, 
		   $draw_key, $max_width_aln, $max_width_draw, $opt_HR, $log2print_AR);
    }
    if($opt_HR->{"--dint"}) { 
	$draw_opts = "-q --dint"; 
	$draw_key = $key_out . "dint.";
	run_ssdraw($ssdraw, $ps2pdf, ($draw_opts . $mask_opts), $aln_file, $aln_file2print, $template_file, 
		   $draw_key, $max_width_aln, $max_width_draw, $opt_HR, $log2print_AR);
    }
    if($opt_HR->{"--info"}) { 
	$draw_opts = ""; 
	$draw_key = $key_out . "info.";
	run_ssdraw($ssdraw, $ps2pdf, ($draw_opts . $mask_opts), $aln_file, $aln_file2print, $template_file, 
		   $draw_key, $max_width_aln, $max_width_draw, $opt_HR, $log2print_AR);
    }
    if($opt_HR->{"--struct"}) { 
	$draw_opts = "--struct"; 
	$draw_key = $key_out . "struct.";
	run_ssdraw($ssdraw, $ps2pdf, ($draw_opts . $mask_opts), $aln_file, $aln_file2print, $template_file, 
		   $draw_key, $max_width_aln, $max_width_draw, $opt_HR, $log2print_AR);
    }
    if($opt_HR->{"--indi"}) { 
	if($opt_HR->{"--no-prob"}) { 
	    $draw_opts = "--indi --all"; 
	}
	else { 
	    $draw_opts = "--indi --all --prob"; 
	}
	$draw_key = $key_out . "indi.";
	run_ssdraw($ssdraw, $ps2pdf, ($draw_opts . $mask_opts), $aln_file, $aln_file2print, $template_file, 
		   $draw_key, $max_width_aln, $max_width_draw, $opt_HR, $log2print_AR);
    }
    if($opt_HR->{"--cons"}) { 
	$draw_opts = "--indi"; 
	$draw_key = $key_out . "cons.";
	run_ssdraw($ssdraw, $ps2pdf, ($draw_opts . $mask_opts), $aln_file, $aln_file2print, $template_file, 
		   $draw_key, $max_width_aln, $max_width_draw, $opt_HR, $log2print_AR);
    }
    return 1;
}    


#####################################################################
# Subroutine: run_ssdraw
# Incept:     EPN, Sat Oct 10 15:34:33 2009
# 
# Purpose:    Call esl-ssdraw for a given alignment and template file.
#             Convert the postscript to pdf if $ps2pdf is not ""
#             (this is true if 'ps2pdf' is in our path or --pdf <s> enabled).
#
# Arguments:
#   $ssdraw:            path and name of esl-alimanip/ssu-esl-alimanip executable
#   $ps2pdf:            command for converting ps to pdf, if "" we don't convert
#   $ssdraw_opts:       string defining options for esl-ssdraw call
#   $aln_file           name of alignment file 
#   $aln_file2print:    name of alignment file, minus the directory
#   $template_file:     name of template file to use
#   $draw_key:          string to use for naming ps and pdf files
#   $max_width_aln:     width of output string for printing align file names
#   $max_width_draw:    width of output string for printing draw file names
#   $opt_HR:            REFERENCE to hash of command-line options
#   $log2print_AR:       reference to log2print array with log file text
#
# Returns:    Nothing, if it returns, everything is valid.
# 
####################################################################
sub run_ssdraw { 
    my $narg_expected = 11;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, run_ssdraw() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($ssdraw, $ps2pdf, $ssdraw_opts, $aln_file, $aln_file2print, $template_file, $draw_key, $max_width_aln,
	$max_width_draw, $opt_HR, $log2print_AR) = @_;

    my($draw_ps, $draw_pdf, $draw_ps2print, $draw_pdf2print);

    $draw_ps  = $aln_file;
    $draw_ps  =~ s/\.stk$/\.$draw_key/; # we've ensured all alignments end with .stk in validate_input
    $draw_ps .= "ps";
    $draw_pdf = $aln_file;
    $draw_pdf =~ s/\.stk$/\.$draw_key/; # we've ensured all alignments end with .stk in validate_input
    $draw_pdf.= "pdf";

    $draw_ps2print  = $aln_file2print;
    $draw_ps2print  =~ s/\.stk$/\.$draw_key/;
    $draw_ps2print .= "ps";
    $draw_pdf2print = $aln_file2print;
    $draw_pdf2print =~ s/\.stk$/\.$draw_key/;
    $draw_pdf2print.= "pdf";

    my $command = "$ssdraw $ssdraw_opts $aln_file $template_file $draw_ps 2>&1";
    #printf("command: $command\n");
    my $tmp = `$command`;
    if(($? >> 8) != 0) { 
	printf STDERR ("\nERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status %d\nand output:\n$tmp\n", ($? >> 8)); exit($? >> 8); 
    }
    

    if($ps2pdf ne "") { # this means we have ps2pdf (or <s> from --pdf <s>) on the system, use it
	$command = "$ps2pdf $draw_ps $draw_pdf 2>&1";
	$tmp = `$command`;
	if(($? >> 8) != 0) { printf STDERR ("\nERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status %d\nand output:\n$tmp\n", ($? >> 8)); exit($? >> 8); } 
	push(@{$log2print_AR}, sprintf("  %-*s  %-*s\n", $max_width_aln, $aln_file2print, $max_width_draw, $draw_pdf2print));
	printf($log2print_AR->[(scalar(@{$log2print_AR})-1)]);
	
	# if we --rm-ps is enabled, remove the ps 
	if($opt_HR->{"--rm-ps"}) { 
	    $command = "rm $draw_ps 2>&1";
	    $tmp = `$command`;
	    if(($? >> 8) != 0) { printf STDERR ("\nERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status %d\nand output:\n$tmp\n", ($? >> 8)); exit($? >> 8); } 
	}
    }
    if(($ps2pdf eq "") || (! $opt_HR->{"--rm-ps"})) { 
	push(@{$log2print_AR}, sprintf("  %-*s  %-*s\n", $max_width_aln, $aln_file2print, $max_width_draw, $draw_ps2print));
	printf($log2print_AR->[(scalar(@{$log2print_AR})-1)]);
    }
}


#####################################################################
# Subroutine: print_log()
# Incept:     EPN, Tue Jun 16 09:23:55 2009
# 
# Purpose:    Print the log.
#
# Arguments:
#   $log_file:    file to print log to.
#   $log2print_AR: reference to array, each element is line of text in log.
#
# Returns:    Nothing, if it returns, everything is valid.
# 
####################################################################
sub print_log { 
    my $narg_expected = 2;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, print_log() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($log_file, $log2print_AR) = @_;
    my ($start_log_line, $line);

    if(open(LOG,  ">" . $log_file) == 0) { printf STDERR ("ERROR, could not open $log_file for writing.\n"); exit(1); }
    foreach $line (@{$log2print_AR}) { print LOG $line; }
    close(LOG);

    return;
}

