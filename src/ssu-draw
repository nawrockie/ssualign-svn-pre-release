#!/usr/bin/perl
#
# ssu-draw
# Eric Nawrocki
# EPN, Wed Oct  7 11:47:02 2009
#
# Usage: ssu-draw [options] <directory created by ssu-align (includes alignment file(s))>
# Usage: ssu-draw [options] -a <Stockholm alignment file (must have .stk suffix)>
#             
# Synopsis:
# Draws secondary structure diagrams of alignment files created by ssu-align.
#
# See definition of $options_usage for options, below.
#
use Getopt::Long;
use Cwd 'abs_path';
use strict;
use warnings;

#Make sure the SSUALIGNDIR environmental variable is set and the directory exists
my $ssualigndir = $ENV{'SSUALIGNDIR'};
if(! exists($ENV{'SSUALIGNDIR'})) { 
    printf STDERR ("ERROR, the environment variable SSUALIGNDIR is not set, please set it to the directory where you installed SSU-ALIGN.\n"); 
    exit(1); 
}
if(! (-d $ssualigndir)) { 
    printf STDERR ("ERROR, the ssu-align directory specified by your environment variable SSUALIGNDIR does not exist, see the User's Guide Installation section.\n"); 
    exit(1); 
}    
#Make sure the SSUALIGNDIR directory includes ssu-align-0p1.subs.pm
my $subs_file = $ssualigndir . "/ssu-align-0p1.subs.pm";
if(! (-e $subs_file)) { 
    printf STDERR ("ERROR, the required perl module ssu-align-0p1.subs.pm is not in the directory specified by your SSUALIGNDIR environment variable.\n"); 
    exit(1); 
}
require $subs_file;

my $total_time     = -1 * time();
my $script_desc    = "draw SSU rRNA secondary structure diagrams";
my $date           = scalar localtime();
my $usage          =  "Usage: ssu-draw [options] <directory created by ssu-align (includes >= 1 alignment file(s))>\n";
   $usage         .= "Usage: ssu-draw [options] -a <Stockholm alignment file (must have .stk suffix)>\n";
my $options_usage  = "where general options are:\n";
#                           1         2         3         4         5         6         7         8
#                  12345678901234567890123456789012345678901234567890123456789012345678901234567890
$options_usage .= "  -h            : show brief help on version and usage\n";
$options_usage .= "  -m <f>        : CM file <f> created the alignment(s) (with ssu-align -m <f>)\n";
$options_usage .= "  -t <f>        : use template file <f>, not the default template file\n";
$options_usage .= "  --key-in <s>  : assume <s> is part of input file names, before the suffix\n";
$options_usage .= "  --key-out <s> : add <s> to all output file names, before the suffix\n";
$options_usage .= "  --use-masks   : draw masks from ssu-mask created '.mask' files in the aln dir\n";
$options_usage .= "  --in-mask <s> : mask alignment given 1/0s in 1-line mask file <f>, requires -a\n";
$options_usage .= "  --pdf <s>     : <s> (!= \"ps2pdf\") is the command for converting ps to pdf\n";
$options_usage .= "  --ps-keep     : if --pdf or ps2pdf is installed, save postscript (& pdf) files\n";
$options_usage .= "\noptions for 1-page alignment summary diagrams (by default, all are drawn):\n";
$options_usage .= "  --no-aln : do not create multi-page pdf with all alignment stats\n";
$options_usage .= "  --prob   : draw average posterior probability per column (save as *.prob.pdf)\n";
$options_usage .= "  --ins    : draw frequency of insertions per column (save as *.ins.pdf)\n";
$options_usage .= "  --dall   : draw frequency of deletions per column (save as *.dall.pdf)\n";
$options_usage .= "  --dint   : draw frequency of internal deletions per column (save as *.dint.pdf)\n";
$options_usage .= "  --info   : draw sequence information content per position (save as *.info.pdf)\n";
$options_usage .= "  --struct : draw structural information content per position (save as *.struct.pdf)\n";
$options_usage .= "\noptions for structure diagrams for individual sequences:\n";
$options_usage .= "  --indi    : draw sequence and probability diagrams for all aligned sequences\n";
$options_usage .= "  --no-prob : with --indi, omit probability diagrams\n";
$options_usage .= "  --cons    : draw consensus sequence/structure only (save as *.cons.pdf)\n";
$options_usage .= "\noptions for omitting parts of the diagrams:\n";
$options_usage .= "  --no-leg  : do not draw legends\n";
$options_usage .= "  --no-head : do not draw headers\n";
$options_usage .= "  --no-foot : do not draw footers\n";

###################
# Process options #
###################
my %opt_H = ();              # key: option (example "-h"); value: option argument (example ("0" or "1") if option takes no arg, actual argument if option takes arg)
my %opt_takes_arg_H  = ();   # key: option; value: "1" if option takes argument, "0" if not
my @opt_order_A  = ();       # order of options for printing in banner
my $opt;

$opt_takes_arg_H{"-a"}          = 0;  push(@opt_order_A, "-a");           
$opt_takes_arg_H{"-h"}          = 0;  push(@opt_order_A, "-h");           
$opt_takes_arg_H{"-m"}          = 1;  push(@opt_order_A, "-m");           
$opt_takes_arg_H{"-t"}          = 1;  push(@opt_order_A, "-t");           
$opt_takes_arg_H{"--key-in"}    = 1;  push(@opt_order_A, "--key-in");     
$opt_takes_arg_H{"--key-out"}   = 1;  push(@opt_order_A, "--key-out");    
$opt_takes_arg_H{"--use-masks"} = 0;  push(@opt_order_A, "--use-masks");  
$opt_takes_arg_H{"--in-mask"}   = 1;  push(@opt_order_A, "--in-mask");    
$opt_takes_arg_H{"--pdf"}       = 1;  push(@opt_order_A, "--pdf");      
$opt_takes_arg_H{"--ps-keep"}   = 0;  push(@opt_order_A, "--ps-keep");      
$opt_takes_arg_H{"--no-aln"}    = 0;  push(@opt_order_A, "--no-aln");     
$opt_takes_arg_H{"--prob"}      = 0;  push(@opt_order_A, "--prob");       
$opt_takes_arg_H{"--ins"}       = 0;  push(@opt_order_A, "--ins");        
$opt_takes_arg_H{"--dall"}      = 0;  push(@opt_order_A, "--dall");       
$opt_takes_arg_H{"--dint"}      = 0;  push(@opt_order_A, "--dint");       
$opt_takes_arg_H{"--info"}      = 0;  push(@opt_order_A, "--info");       
$opt_takes_arg_H{"--struct"}    = 0;  push(@opt_order_A, "--struct");     
$opt_takes_arg_H{"--indi"}      = 0;  push(@opt_order_A, "--indi");       
$opt_takes_arg_H{"--no-prob"}   = 0;  push(@opt_order_A, "--no-prob");    
$opt_takes_arg_H{"--cons"}      = 0;  push(@opt_order_A, "--cons");       
$opt_takes_arg_H{"--no-leg"}    = 0;  push(@opt_order_A, "--no-leg");     
$opt_takes_arg_H{"--no-head"}   = 0;  push(@opt_order_A, "--no-head");    
$opt_takes_arg_H{"--no-foot"}   = 0;  push(@opt_order_A, "--no-foot");    

#set default options
foreach $opt (keys %opt_takes_arg_H) { 
    if($opt_takes_arg_H{$opt}) { $opt_H{$opt} = ""; }
    else                       { $opt_H{$opt} = 0; }
}

Getopt::Long::Configure ("bundling");
my $opt_return = GetOptions
    ('a'         => \$opt_H{"-a"},
     'h'         => \$opt_H{"-h"}, 
     'm=s'       => \$opt_H{"-m"},
     't=s'       => \$opt_H{"-t"},
     'key-in=s'  => \$opt_H{"key-in"},
     'key-out=s' => \$opt_H{"key-out"},
     'use-masks' => \$opt_H{"--use-masks"},
     'in-mask=s' => \$opt_H{"in-mask"},
     'ps-keep'   => \$opt_H{"--ps-keep"},
     'no-aln'    => \$opt_H{"--no-aln"},
     'prob'      => \$opt_H{"--prob"},
     'ins'       => \$opt_H{"--ins"},
     'dall'      => \$opt_H{"--dall"},
     'dint'      => \$opt_H{"--dint"},
     'info'      => \$opt_H{"--info"},
     'struct'    => \$opt_H{"--struct"},
     'indi'      => \$opt_H{"--indi"},
     'no-prob'   => \$opt_H{"--no-prob"},
     'cons'      => \$opt_H{"--cons"},
     'no-leg'    => \$opt_H{"--no-leg"},
     'no-head'   => \$opt_H{"--no-head"},
     'no-foot'   => \$opt_H{"--no-foot"});

if($opt_return != 1) { exit(1); }

if ($opt_H{"-h"}) { 
    PrintBanner($0, $script_desc, $date, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, 1, ""); 
    print $usage . "\n"; 
    print $options_usage; exit(1); 
} 

my $key_in = "";
if($opt_H{"--key-in"}  ne '') { $key_in   = "." . opt_H{"--key-in"};  }
my $key_out = "";
if($opt_H{"--key-out"}  ne '') { $key_out   = "." . opt_H{"--key-out"};  }

# Check for incompatible options combinations.
if($opt_H{"--use-masks"} && ($opt_H{"--in-mask"} ne '')) { 
    printf STDERR ("\nERROR, --in-mask is incompatible with --use-masks.\n"); exit(1); 
}
if(($opt_H{"--in-mask"} ne '') && ($opt_H{"-a"} == 0)) { 
    printf STDERR ("\nERROR, --in-mask requires the -a option.\n"); exit(1);
}    
if(($opt_H{"--no-prob"}) && (!($opt_H{"--indi"}))) {
    printf STDERR ("\nERROR, --no-prob only makes sense in combination with --indi.\n"); exit(1);
}    


###################################################
# Process command-line arguments and print banner #
###################################################
if(scalar(@ARGV) != 1) {   
    print "Incorrect number of command line arguments.\n";
    print $usage;
    print "\nTo see more help on available options, do ssu-draw -h\n\n";
    exit(1);
}

my ($dir) = $ARGV[0];
$dir =~ s/\/$//;

my ($sum_file, $sum_file2print, $log_file, $log_file2print);
if(!($opt_H{"-a"})) { 
    #validate that $dir exists
    if(!(-d $dir)) { printf STDERR ("\nERROR, directory $dir does not exist.\n"); exit(1); }
    $sum_file       = $dir . "/" . $dir . $key_out . ".ssu-draw.sum";
    $sum_file2print = $dir . $key_out . ".ssu-draw.sum";
    $log_file       = $dir . "/" . $dir . $key_out . ".ssu-draw.log";
    $log_file2print = $dir . $key_out . ".ssu-draw.log";
}
else { 
    my $file_root;
    $file_root       = $dir;
    $file_root       =~ s/\.stk$//;
    $sum_file        = $file_root . $key_out . ".ssu-draw.sum";
    $sum_file2print  = $sum_file;
    $log_file        = $file_root . $key_out . ".ssu-draw.log";
    $log_file2print  = $log_file;
}
# open the summary and log files
open(OUT, ">" . $sum_file) || die "\nERROR, couldn't open file $sum_file for writing.\n";
close(OUT);
open(OUT, ">" . $log_file) || die "\nERROR, couldn't open file $log_file for writing.\n";
close(OUT);

PrintBanner($0, $script_desc, $date, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, 1, $sum_file);
PrintBanner($0, $script_desc, $date, \%opt_H, \%opt_takes_arg_H, \@opt_order_A, \@ARGV, 0, $log_file);


##################################
# Validate that everything is go #
##################################
my @stk_list_A = ();
my @mask_list_A = ();
my ($cm_file, $template_file, $ssdraw);
validate_and_setup_ssu_draw($ssualigndir, $dir, $key_in, \%opt_H, \$cm_file, \$template_file, \$ssdraw, \@stk_list_A, \@mask_list_A, $log_file, $sum_file);
my $naln = scalar(@stk_list_A);
my $aln_file;


#################
# Format output #
#################
# determine max file name width
my $max_width_aln = length("alignment file name");
my ($nec_width, $i, $max_width_draw, $aln_root, $aln_root2print);
my $extra_draw_chars = 0;
if($opt_H{"--ins"}) { $extra_draw_chars = 3+1; } # +1 is for the '.'
if($opt_H{"--prob"} || $opt_H{"--dall"} || $opt_H{"--dint"} || $opt_H{"--info"} || $opt_H{"--indi"} || $opt_H{"--cons"}) { 
    $extra_draw_chars = 4+1; 
}
if($opt_H{"--struct"}) { $extra_draw_chars = 5+1; }

for($i = 0; $i < $naln; $i++) { 
    $aln_file         = $stk_list_A[$i];
    ($aln_root)       = ($aln_file =~ /(.+)\.stk/);
    if($opt_H{"-a"}) { #print directory as well as aln name
	($aln_root2print) = ($aln_file =~ /(.+)\.stk/);
    }
    else {
	($aln_root2print) = ($aln_file =~ /.+\/(.+)\.stk/);
    }
    $nec_width = length($aln_root2print) + length($key_out) + length(".stk");
    if($max_width_aln < $nec_width) { $max_width_aln = $nec_width; }
}					     
$max_width_draw = $max_width_aln + $extra_draw_chars; # ('.stk' and '.pdf' are same len) ($extra_draw_chars is for adding keys, such as 'struct.' to names )
if($max_width_draw < length("structure diagram file")) { $max_width_draw = length("structure diagram file"); }
my $dashes_aln = "";  for($i = 0; $i < $max_width_aln; $i++)  { $dashes_aln .= "-"; }
my $dashes_draw = ""; for($i = 0; $i < $max_width_draw; $i++) { $dashes_draw .= "-"; }

PrintStringToFile($sum_file, 1, sprintf("#\n# Drawing secondary structure diagrams...\n"));
PrintStringToFile($sum_file, 1, sprintf("#\n"));
PrintStringToFile($sum_file, 1, sprintf("# %-*s  %-*s\n", $max_width_aln, "alignment file name", $max_width_draw, "structure diagram file"));
PrintStringToFile($sum_file, 1, sprintf("# %-*s  %-*s\n", $max_width_aln, $dashes_aln, $max_width_draw, $dashes_draw));


#######################
# Create the drawings #
#######################
my ($mask_file, $aln_file2print);
for($i = 0; $i < $naln; $i++) { 
    $aln_file  = $stk_list_A[$i];
    $mask_file = $mask_list_A[$i]; 
    if($opt_H{"-a"}) { #print directory as well as aln name
	$aln_file2print = $aln_file;
    }
    else { 
	($aln_file2print) = ($aln_file =~ /.+\/(.+)$/);
    }

    draw_alignment($ssdraw, $template_file, $aln_file, $aln_file2print, $mask_file,
		   $max_width_aln, $max_width_draw, $key_out, \%opt_H, $sum_file);
}

############
# Conclude #
############
$total_time += time();
if(!($opt_H{"-a"})) { 
    PrintConclusion($sum_file, $log_file2print, $sum_file2print, $total_time, $dir);
}
else { 
    PrintConclusion($sum_file, $log_file2print, $sum_file2print, $total_time, "");
}

# Success! Exit normally
exit(0);


###############
# Subroutines #
###############


#####################################################################
# Subroutine: validate_and_setup_ssu_draw()
# Incept:     EPN, Mon Nov  3 15:05:56 2008
# 
# Purpose:    Validate that: 
#             - the CM file exists. 
#             - the postscript template file exists. 
#             - the required executable programs exist.
#             - there is at least 1 alignment in $dir directory
#               to operate on
#             Also, create the summary and log files (by opening them)
#
# Arguments: 
# $ssualigndir:       dir defined by SSUALIGNDIR environment variable 
# $dir:               the directory we will create files in
# $key_in:            '' or a key that is included in input file names, just prior to the suffix
#                     e.g. $key_in = "fookey", $dir = "foodir", aln file is foodir/foodir.archaea.fookey.stk
# $opt_HR:            reference to the hash of command-line options
# $cm_file_ref:       RETURN; the path to the CM file, either default CM file or $alt_cm_file
# $template_file_ref: RETURN; the path to the template file, either default template file or $alt_template_file
# $ssdraw_ref:        RETURN; the esl-ssdraw command
# $stk_list_arr_ref:  RETURN; ref to array of alignment files to operate on
# $mask_list_arr_ref: RETURN; ref to array of alignment files to operate on
# $log_file:          the log file
# $sum_file:          the summary file
#
# Returns:    Nothing, if it returns, everything is valid.
# 
# Exits:      If any of the above validations do not occur, we
#             print a message to STDERR explaining why it's
#             exiting early and then exit with non-zero status.
#
####################################################################
sub validate_and_setup_ssu_draw { 
    my $narg_expected = 11;
    if(scalar(@_) != $narg_expected) { printf STDERR ("\nERROR, validate_and_setup_ssu_draw() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($ssualigndir, $dir, $key_in, $opt_HR, $cm_file_ref, $template_file_ref, $ssdraw_ref, $stk_list_arr_ref, $mask_list_arr_ref, $log_file, $sum_file) = @_;

    #Validate that we can read the CM file
    my $cm_file = "";
    if($opt_HR->{"-m"} ne '') {
	$cm_file = $opt_HR->{"-m"};
	if(!(-e $cm_file)) { printf STDERR ("\nERROR, CM file $cm_file, specified with -m does not exist.\n"); exit(1); }
    }
    else { # -m not enabled, assume the user used the default CM file:
	$cm_file = $ssualigndir . "/ssu-align-0p1.cm";
	if(!(-e $cm_file)) { printf STDERR ("\nERROR, the default CM file $cm_file does not exist.\nIf you used a different CM file to create the alignments in $dir, use the -m option.\n"); exit(1); }
    }

    #Validate that we can read the template postscript diagram file
    if($opt_HR->{"-t"} ne '') {
	$template_file = $opt_HR->{"-t"};
	if(!(-e $template_file)) { printf STDERR ("\nERROR, template postscript file $template_file, specified with -t does not exist.\n"); exit(1); }
    }
    else { # -t not enabled, assume the user used the default CM file:
	$template_file = $ssualigndir . "/ssu-align-0p1.ps";
	if(!(-e $template_file)) { printf STDERR ("\nERROR, the default template file $template_file does not exist.\nIf you want to use a different postscript template file to create the structure diagrams, use the -t option.\n"); exit(1); }
    }

    #Validate that esl-ssdraw exist
    my $ssdraw = "ssu-esl-ssdraw";
    my $command_worked;
    RunExecutable("$ssdraw -h > /dev/null", 1, 0, $log_file, \$command_worked, "ERROR, the required executable $ssdraw is not in your PATH environment\nvariable. See the User's Guide Installation section.");;

    if($opt_HR->{"--in-mask"} ne "") { 
	if(!(-e $opt_HR->{"--in-mask"})) { 
	    printf STDERR ("\nERROR, the --in-mask file %s does not exist.\n", $opt_HR->{"--in-mask"}); exit(1); 
	}
    }

    my $naln = 0;
    my $aln_name = '';
    my $mask_name = '';
    if($opt_HR->{"-a"}) { # special mode, single command line argument is not a directory, it's an alignment
	$aln_name = $dir;
	if(! (-e $aln_name)) { 
	    printf STDERR ("\nERROR, the alignment file $aln_name does not exist.\n"); exit(1); 
	}
	my $aln_root = $aln_name;
	if($aln_root !~ s/\.stk$//) { 
	    printf STDERR ("\nERROR, the alignment file must end with \".stk\", $aln_name does not.\n"); exit(1); 
	}
	push(@{$stk_list_arr_ref}, $aln_name);
	$naln++; 

	if($opt_HR->{"--use-masks"}) { #ensure that the mask for this alignment exists
	    $mask_name = $aln_root . ".mask";
	    if(! (-e $mask_name)) { 
		printf STDERR ("\nERROR, --use-masks enabled, but the mask file $mask_name does not exist.\n"); exit(1); 
	    }
	    push(@{$mask_list_arr_ref}, $mask_name);
	}
	else { push(@{$mask_list_arr_ref}, ""); } # empty string tells later functions: don't use mask for this alignment

    }
    else { 
	# Validate there is at least 1 alignment in the input dir
	if(! (-d $dir)) { 
	    if(-e $dir) { 
		printf STDERR ("\nERROR, the command-line argument $dir is a file, not a directory.\nIt should be the directory that includes the input alignment files,\nor if you want to operate on a single alignment, use the -a option.\n"); exit(1); 
	    }
	    else { 
		printf STDERR ("\nERROR, the directory $dir with input alignment files does not exist.\n"); exit(1); 
	    }
	}
	my ($name, $line);
	my @names_A = ();
	if(! open(CM, $cm_file)) { 
	    my $errmsg = "\nERROR, could not open CM file $cm_file for reading.\n";
	    PrintStringToFile($sum_file, 0, $errmsg);
	    die $errmsg; 
	}
	while($line = <CM>) { 
	    if($line =~ s/NAME\s+//) { 
		chomp $line;
		push(@names_A, $line);
	    }
	}
	close(CM);
	foreach $name (@names_A) { 
	    $aln_name = $dir . "/" . $dir . "." . $name . $key_in . ".stk";
	    if(-e $aln_name) { 
		push(@{$stk_list_arr_ref}, $aln_name);
		$naln++; 
		if($opt_HR->{"--use-masks"}) { 
		    $mask_name = $dir . "/" . $dir . "." . $name . $key_in . ".mask";
		    if(!(-e $mask_name)) { 
			printf STDERR ("\nERROR, --use-masks enabled, but the mask file $mask_name for aln $aln_name does not exist.\n"); exit(1); 
		    }
		    push(@{$mask_list_arr_ref}, $mask_name);
		}
		else { push(@{$mask_list_arr_ref}, ""); } # empty string tells later functions: don't use mask for this alignment
	    }
	}
	if($naln == 0) { 
	    printf STDERR ("\nERROR, found 0 alignments created by ssu-align using the CM file $cm_file\nin directory $dir.\n\n");
	    printf STDERR ("The following alignments were searched for, but none were found:\n");
	    foreach $name (@names_A) { 
		$aln_name = $dir . "/" . $dir . "." . $name . $key_in . ".stk";
		printf STDERR ("\t$aln_name\n");
	    }
	    exit(1);
	}
    }

    $$cm_file_ref  = $cm_file;
    $$template_file_ref  = $template_file;
    $$ssdraw_ref  = $ssdraw;
    
    return;
}



#####################################################################
# Subroutine: draw_alignment()
# Incept:     EPN, Wed Oct  7 13:55:56 2009
# 
# Purpose:    Draw an alignment using the easel miniapp esl-ssdraw.
#
# Arguments:  
#   $ssdraw:            path and name of esl-alimanip/ssu-esl-alimanip executable
#   $template_file:     template file for esl-ssdraw
#   $aln_file:          alignment file with path to draw
#   $aln_file2print:    name of alignment file, minus the directory
#   $mask_file2use:     mask file to use with --mask, or don't use --mask if ''
#   $max_width_aln:     width of output string for printing aln file names
#   $max_width_draw:    width of output string for printing draw file names
#   $key_out:           <s> from --key-out ("" if --key-out not enabled)
#   $opt_HR:            REFERENCE to hash of command-line options
#   $sum_file:          file to print output file notices to
# 
# Returns:  Nothing, if it returns, everything is valid.
# 
####################################################################
sub draw_alignment { 
    my $narg_expected = 10;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, draw_alignment() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my($ssdraw, $template_file, $aln_file, $aln_file2print, $mask_file2use, $max_width_aln, $max_width_draw, $key_out, $opt_HR, $sum_file) = @_;

    my ($all_aln_opts, $mask_opts, $draw_opts, $draw_key);
    if($mask_file2use ne "")  { $mask_opts = " --mask $mask_file2use"; }
    else                      { $mask_opts = ""; }

    # Default multi-page align call, or not if --no-aln enabled
    if(! ($opt_HR->{"--no-aln"})) { 
	$draw_opts = "--prob --ins --dall --dint --struct"; 
	$draw_key = $key_out; #this will be "" unless --key-out was enabled
	run_ssdraw_for_ssu_draw($ssdraw, ($draw_opts . $mask_opts), $aln_file, $aln_file2print, $template_file, 
		   $draw_key, $max_width_aln, $max_width_draw, $opt_HR, $sum_file, $log_file);
    }
    if($opt_HR->{"--prob"}) { 
	$draw_opts = "-q --prob"; 
	$draw_key = $key_out . "prob.";
	run_ssdraw_for_ssu_draw($ssdraw, ($draw_opts . $mask_opts), $aln_file, $aln_file2print, $template_file, 
		   $draw_key, $max_width_aln, $max_width_draw, $opt_HR, $sum_file, $log_file);
    }
    if($opt_HR->{"--ins"}) { 
	$draw_opts = "-q --ins"; 
	$draw_key = $key_out . "ins.";
	run_ssdraw_for_ssu_draw($ssdraw, ($draw_opts . $mask_opts), $aln_file, $aln_file2print, $template_file, 
		   $draw_key, $max_width_aln, $max_width_draw, $opt_HR, $sum_file, $log_file);
    }
    if($opt_HR->{"--dall"}) { 
	$draw_opts = "-q --dall"; 
	$draw_key = $key_out . "dall.";
	run_ssdraw_for_ssu_draw($ssdraw, ($draw_opts . $mask_opts), $aln_file, $aln_file2print, $template_file, 
		   $draw_key, $max_width_aln, $max_width_draw, $opt_HR, $sum_file, $log_file);
    }
    if($opt_HR->{"--dint"}) { 
	$draw_opts = "-q --dint"; 
	$draw_key = $key_out . "dint.";
	run_ssdraw_for_ssu_draw($ssdraw, ($draw_opts . $mask_opts), $aln_file, $aln_file2print, $template_file, 
		   $draw_key, $max_width_aln, $max_width_draw, $opt_HR, $sum_file, $log_file);
    }
    if($opt_HR->{"--info"}) { 
	$draw_opts = ""; 
	$draw_key = $key_out . "info.";
	run_ssdraw_for_ssu_draw($ssdraw, ($draw_opts . $mask_opts), $aln_file, $aln_file2print, $template_file, 
		   $draw_key, $max_width_aln, $max_width_draw, $opt_HR, $sum_file, $log_file);
    }
    if($opt_HR->{"--struct"}) { 
	$draw_opts = "--struct"; 
	$draw_key = $key_out . "struct.";
	run_ssdraw_for_ssu_draw($ssdraw, ($draw_opts . $mask_opts), $aln_file, $aln_file2print, $template_file, 
		   $draw_key, $max_width_aln, $max_width_draw, $opt_HR, $sum_file, $log_file);
    }
    if($opt_HR->{"--indi"}) { 
	if($opt_HR->{"--no-prob"}) { 
	    $draw_opts = "--indi --all"; 
	}
	else { 
	    $draw_opts = "--indi --all --prob"; 
	}
	$draw_key = $key_out . "indi.";
	run_ssdraw_for_ssu_draw($ssdraw, ($draw_opts . $mask_opts), $aln_file, $aln_file2print, $template_file, 
		   $draw_key, $max_width_aln, $max_width_draw, $opt_HR, $sum_file, $log_file);
    }
    if($opt_HR->{"--cons"}) { 
	$draw_opts = "--indi"; 
	$draw_key = $key_out . "cons.";
	run_ssdraw_for_ssu_draw($ssdraw, ($draw_opts . $mask_opts), $aln_file, $aln_file2print, $template_file, 
		   $draw_key, $max_width_aln, $max_width_draw, $opt_HR, $sum_file, $log_file);
    }
    return 1;
}    


#####################################################################
# Subroutine: run_ssdraw_for_ssu_draw
# Incept:     EPN, Sat Oct 10 15:34:33 2009
# 
# Purpose:    Call esl-ssdraw for a given alignment and template file.
#             Try to convert the postscript to pdf.
#
# Arguments:
#   $ssdraw:            path and name of esl-alimanip/ssu-esl-alimanip executable
#   $ssdraw_opts:       string defining options for esl-ssdraw call
#   $aln_file           name of alignment file 
#   $aln_file2print:    name of alignment file, minus the directory
#   $template_file:     name of template file to use
#   $draw_key:          string to use for naming ps and pdf files
#   $max_width_aln:     width of output string for printing align file names
#   $max_width_draw:    width of output string for printing draw file names
#   $opt_HR:            REFERENCE to hash of command-line options
#   $sum_file:          reference to log2print array with log file text
#   $log_file:          log file
#
# Returns:    Nothing, if it returns, everything is valid.
# 
####################################################################
sub run_ssdraw_for_ssu_draw { 
    my $narg_expected = 11;
    if(scalar(@_) != $narg_expected) { printf STDERR ("ERROR, run_ssdraw_for_ssu_draw() entered with %d != %d input arguments.\n", scalar(@_), $narg_expected); exit(1); } 
    my ($ssdraw, $ssdraw_opts, $aln_file, $aln_file2print, $template_file, $draw_key, $max_width_aln,
	$max_width_draw, $opt_HR, $sum_file, $log_file) = @_;

    my($draw_ps, $draw_pdf, $draw_ps2print, $draw_pdf2print, $command_worked);

    $draw_ps  = $aln_file;
    $draw_ps  =~ s/\.stk$/\.$draw_key/; # we've ensured all alignments end with .stk in validate_input
    $draw_ps .= "ps";
    $draw_pdf = $aln_file;
    $draw_pdf =~ s/\.stk$/\.$draw_key/; # we've ensured all alignments end with .stk in validate_input
    $draw_pdf.= "pdf";

    $draw_ps2print  = $aln_file2print;
    $draw_ps2print  =~ s/\.stk$/\.$draw_key/;
    $draw_ps2print .= "ps";
    $draw_pdf2print = $aln_file2print;
    $draw_pdf2print =~ s/\.stk$/\.$draw_key/;
    $draw_pdf2print.= "pdf";

    my $command = "$ssdraw $ssdraw_opts $aln_file $template_file $draw_ps";
    RunExecutable("$command", 1, 1, $log_file, \$command_worked, "ERROR, the command \(\"$command\"\) unexpectedly returned non-zero exit status.");

    # try ps2pdf, it's okay if it doesn't work (unless --pdf, in which case its not ok)
    my $ps2pdf;
    if($opt_HR->{"--pdf"} ne "") { $ps2pdf = $opt_HR->{"--pdf"}; }
    else                         { $ps2pdf = "ps2pdf"; }
    my $die_if_fails = 0;
    my $print_output_upon_failure = 0;
    my $errmsg = "";
    if($opt_HR->{"--pdf"} ne "") { 
	$die_if_fails = 1; 
	$errmsg = "ERROR, --pdf " . $opt_HR->{"--pdf"} . " was enabled, but command $command did not work."; 
    }
    TryPs2Pdf($ps2pdf, $draw_ps, $draw_pdf, $die_if_fails, $print_output_upon_failure, $log_file, \$command_worked, $errmsg);

    if($command_worked) { 
	PrintStringToFile($sum_file, 1, sprintf("  %-*s  %-*s\n", $max_width_aln, $aln_file2print, $max_width_draw, $draw_pdf2print));
    }
    if((! $command_worked) || ($opt_HR->{"--ps-keep"})) { # we don't have a pdf, --ps-keep enabled, or both, print info about postscript file
	PrintStringToFile($sum_file, 1, sprintf("  %-*s  %-*s\n", $max_width_aln, $aln_file2print, $max_width_draw, $draw_ps2print));
    }
    else { UnlinkFile($draw_ps, $log_file); }
}
